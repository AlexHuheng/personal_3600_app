/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "HIRealMonitor.h"

namespace H2103_Host_Invoke {


HIRealMonitor_GetIOAsync_args::~HIRealMonitor_GetIOAsync_args() throw() {
}


uint32_t HIRealMonitor_GetIOAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast49;
          xfer += iprot->readI32(ecast49);
          this->sensor = ( ::OUTPUT_IO::type)ecast49;
          this->__isset.sensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetIOAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetIOAsync_args");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->sensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetIOAsync_pargs::~HIRealMonitor_GetIOAsync_pargs() throw() {
}


uint32_t HIRealMonitor_GetIOAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetIOAsync_pargs");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->sensor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetIOAsync_result::~HIRealMonitor_GetIOAsync_result() throw() {
}


uint32_t HIRealMonitor_GetIOAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast50;
          xfer += iprot->readI32(ecast50);
          this->success = ( ::EXE_STATE::type)ecast50;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetIOAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetIOAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetIOAsync_presult::~HIRealMonitor_GetIOAsync_presult() throw() {
}


uint32_t HIRealMonitor_GetIOAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast51;
          xfer += iprot->readI32(ecast51);
          (*(this->success)) = ( ::EXE_STATE::type)ecast51;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_GetTemperatureAsync_args::~HIRealMonitor_GetTemperatureAsync_args() throw() {
}


uint32_t HIRealMonitor_GetTemperatureAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->sensor = ( ::TEMPERATURE_SENSOR::type)ecast52;
          this->__isset.sensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetTemperatureAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetTemperatureAsync_args");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->sensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetTemperatureAsync_pargs::~HIRealMonitor_GetTemperatureAsync_pargs() throw() {
}


uint32_t HIRealMonitor_GetTemperatureAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetTemperatureAsync_pargs");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->sensor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetTemperatureAsync_result::~HIRealMonitor_GetTemperatureAsync_result() throw() {
}


uint32_t HIRealMonitor_GetTemperatureAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast53;
          xfer += iprot->readI32(ecast53);
          this->success = ( ::EXE_STATE::type)ecast53;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetTemperatureAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetTemperatureAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetTemperatureAsync_presult::~HIRealMonitor_GetTemperatureAsync_presult() throw() {
}


uint32_t HIRealMonitor_GetTemperatureAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast54;
          xfer += iprot->readI32(ecast54);
          (*(this->success)) = ( ::EXE_STATE::type)ecast54;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_GetPressureAsync_args::~HIRealMonitor_GetPressureAsync_args() throw() {
}


uint32_t HIRealMonitor_GetPressureAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->sensor);
          this->__isset.sensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetPressureAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetPressureAsync_args");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->sensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetPressureAsync_pargs::~HIRealMonitor_GetPressureAsync_pargs() throw() {
}


uint32_t HIRealMonitor_GetPressureAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetPressureAsync_pargs");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->sensor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetPressureAsync_result::~HIRealMonitor_GetPressureAsync_result() throw() {
}


uint32_t HIRealMonitor_GetPressureAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast55;
          xfer += iprot->readI32(ecast55);
          this->success = ( ::EXE_STATE::type)ecast55;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetPressureAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetPressureAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetPressureAsync_presult::~HIRealMonitor_GetPressureAsync_presult() throw() {
}


uint32_t HIRealMonitor_GetPressureAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast56;
          xfer += iprot->readI32(ecast56);
          (*(this->success)) = ( ::EXE_STATE::type)ecast56;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetIOAsync_args::~HIRealMonitor_SetIOAsync_args() throw() {
}


uint32_t HIRealMonitor_SetIOAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast57;
          xfer += iprot->readI32(ecast57);
          this->sensor = ( ::INPUT_IO::type)ecast57;
          this->__isset.sensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iState);
          this->__isset.iState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetIOAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetIOAsync_args");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->sensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iState", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIOAsync_pargs::~HIRealMonitor_SetIOAsync_pargs() throw() {
}


uint32_t HIRealMonitor_SetIOAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetIOAsync_pargs");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->sensor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iState", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iState)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIOAsync_result::~HIRealMonitor_SetIOAsync_result() throw() {
}


uint32_t HIRealMonitor_SetIOAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast58;
          xfer += iprot->readI32(ecast58);
          this->success = ( ::EXE_STATE::type)ecast58;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetIOAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetIOAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIOAsync_presult::~HIRealMonitor_SetIOAsync_presult() throw() {
}


uint32_t HIRealMonitor_SetIOAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast59;
          xfer += iprot->readI32(ecast59);
          (*(this->success)) = ( ::EXE_STATE::type)ecast59;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_ManualUnlockSlotAsync_args::~HIRealMonitor_ManualUnlockSlotAsync_args() throw() {
}


uint32_t HIRealMonitor_ManualUnlockSlotAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast60;
          xfer += iprot->readI32(ecast60);
          this->sensor = ( ::INPUT_IO::type)ecast60;
          this->__isset.sensor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_ManualUnlockSlotAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_ManualUnlockSlotAsync_args");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->sensor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualUnlockSlotAsync_pargs::~HIRealMonitor_ManualUnlockSlotAsync_pargs() throw() {
}


uint32_t HIRealMonitor_ManualUnlockSlotAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_ManualUnlockSlotAsync_pargs");

  xfer += oprot->writeFieldBegin("sensor", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)(*(this->sensor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualUnlockSlotAsync_result::~HIRealMonitor_ManualUnlockSlotAsync_result() throw() {
}


uint32_t HIRealMonitor_ManualUnlockSlotAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast61;
          xfer += iprot->readI32(ecast61);
          this->success = ( ::EXE_STATE::type)ecast61;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_ManualUnlockSlotAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_ManualUnlockSlotAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualUnlockSlotAsync_presult::~HIRealMonitor_ManualUnlockSlotAsync_presult() throw() {
}


uint32_t HIRealMonitor_ManualUnlockSlotAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          (*(this->success)) = ( ::EXE_STATE::type)ecast62;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_GetLightSignalAsync_args::~HIRealMonitor_GetLightSignalAsync_args() throw() {
}


uint32_t HIRealMonitor_GetLightSignalAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iWave);
          this->__isset.iWave = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetLightSignalAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetLightSignalAsync_args");

  xfer += oprot->writeFieldBegin("iWave", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iWave);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetLightSignalAsync_pargs::~HIRealMonitor_GetLightSignalAsync_pargs() throw() {
}


uint32_t HIRealMonitor_GetLightSignalAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetLightSignalAsync_pargs");

  xfer += oprot->writeFieldBegin("iWave", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iWave)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetLightSignalAsync_result::~HIRealMonitor_GetLightSignalAsync_result() throw() {
}


uint32_t HIRealMonitor_GetLightSignalAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->success = ( ::EXE_STATE::type)ecast63;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetLightSignalAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetLightSignalAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetLightSignalAsync_presult::~HIRealMonitor_GetLightSignalAsync_presult() throw() {
}


uint32_t HIRealMonitor_GetLightSignalAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast64;
          xfer += iprot->readI32(ecast64);
          (*(this->success)) = ( ::EXE_STATE::type)ecast64;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetIndicatorLightAsync_args::~HIRealMonitor_SetIndicatorLightAsync_args() throw() {
}


uint32_t HIRealMonitor_SetIndicatorLightAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIndicatorLightNo);
          this->__isset.iIndicatorLightNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iColor);
          this->__isset.iColor = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iBlink);
          this->__isset.iBlink = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetIndicatorLightAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetIndicatorLightAsync_args");

  xfer += oprot->writeFieldBegin("iIndicatorLightNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iIndicatorLightNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iColor", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iColor);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBlink", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iBlink);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIndicatorLightAsync_pargs::~HIRealMonitor_SetIndicatorLightAsync_pargs() throw() {
}


uint32_t HIRealMonitor_SetIndicatorLightAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetIndicatorLightAsync_pargs");

  xfer += oprot->writeFieldBegin("iIndicatorLightNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iIndicatorLightNo)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iColor", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iColor)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBlink", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iBlink)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIndicatorLightAsync_result::~HIRealMonitor_SetIndicatorLightAsync_result() throw() {
}


uint32_t HIRealMonitor_SetIndicatorLightAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast65;
          xfer += iprot->readI32(ecast65);
          this->success = ( ::EXE_STATE::type)ecast65;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetIndicatorLightAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetIndicatorLightAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetIndicatorLightAsync_presult::~HIRealMonitor_SetIndicatorLightAsync_presult() throw() {
}


uint32_t HIRealMonitor_SetIndicatorLightAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          (*(this->success)) = ( ::EXE_STATE::type)ecast66;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetAlarmSoundAsync_args::~HIRealMonitor_SetAlarmSoundAsync_args() throw() {
}


uint32_t HIRealMonitor_SetAlarmSoundAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bOpen);
          this->__isset.bOpen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSound);
          this->__isset.iSound = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetAlarmSoundAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetAlarmSoundAsync_args");

  xfer += oprot->writeFieldBegin("bOpen", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bOpen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSound", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iSound);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetAlarmSoundAsync_pargs::~HIRealMonitor_SetAlarmSoundAsync_pargs() throw() {
}


uint32_t HIRealMonitor_SetAlarmSoundAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetAlarmSoundAsync_pargs");

  xfer += oprot->writeFieldBegin("bOpen", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool((*(this->bOpen)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSound", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iSound)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetAlarmSoundAsync_result::~HIRealMonitor_SetAlarmSoundAsync_result() throw() {
}


uint32_t HIRealMonitor_SetAlarmSoundAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->success = ( ::EXE_STATE::type)ecast67;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetAlarmSoundAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetAlarmSoundAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetAlarmSoundAsync_presult::~HIRealMonitor_SetAlarmSoundAsync_presult() throw() {
}


uint32_t HIRealMonitor_SetAlarmSoundAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          (*(this->success)) = ( ::EXE_STATE::type)ecast68;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_ManualStopAsync_args::~HIRealMonitor_ManualStopAsync_args() throw() {
}


uint32_t HIRealMonitor_ManualStopAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_ManualStopAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_ManualStopAsync_args");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualStopAsync_pargs::~HIRealMonitor_ManualStopAsync_pargs() throw() {
}


uint32_t HIRealMonitor_ManualStopAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_ManualStopAsync_pargs");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualStopAsync_result::~HIRealMonitor_ManualStopAsync_result() throw() {
}


uint32_t HIRealMonitor_ManualStopAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast69;
          xfer += iprot->readI32(ecast69);
          this->success = ( ::EXE_STATE::type)ecast69;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_ManualStopAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_ManualStopAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_ManualStopAsync_presult::~HIRealMonitor_ManualStopAsync_presult() throw() {
}


uint32_t HIRealMonitor_ManualStopAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast70;
          xfer += iprot->readI32(ecast70);
          (*(this->success)) = ( ::EXE_STATE::type)ecast70;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetConsumablesInfo_args::~HIRealMonitor_SetConsumablesInfo_args() throw() {
}


uint32_t HIRealMonitor_SetConsumablesInfo_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tConsumablesInfo.read(iprot);
          this->__isset.tConsumablesInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetConsumablesInfo_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetConsumablesInfo_args");

  xfer += oprot->writeFieldBegin("tConsumablesInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tConsumablesInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetConsumablesInfo_pargs::~HIRealMonitor_SetConsumablesInfo_pargs() throw() {
}


uint32_t HIRealMonitor_SetConsumablesInfo_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetConsumablesInfo_pargs");

  xfer += oprot->writeFieldBegin("tConsumablesInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tConsumablesInfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetConsumablesInfo_result::~HIRealMonitor_SetConsumablesInfo_result() throw() {
}


uint32_t HIRealMonitor_SetConsumablesInfo_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast71;
          xfer += iprot->readI32(ecast71);
          this->success = ( ::EXE_STATE::type)ecast71;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetConsumablesInfo_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetConsumablesInfo_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetConsumablesInfo_presult::~HIRealMonitor_SetConsumablesInfo_presult() throw() {
}


uint32_t HIRealMonitor_SetConsumablesInfo_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast72;
          xfer += iprot->readI32(ecast72);
          (*(this->success)) = ( ::EXE_STATE::type)ecast72;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_GetCurrentInstrumentState_args::~HIRealMonitor_GetCurrentInstrumentState_args() throw() {
}


uint32_t HIRealMonitor_GetCurrentInstrumentState_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetCurrentInstrumentState_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetCurrentInstrumentState_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetCurrentInstrumentState_pargs::~HIRealMonitor_GetCurrentInstrumentState_pargs() throw() {
}


uint32_t HIRealMonitor_GetCurrentInstrumentState_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetCurrentInstrumentState_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetCurrentInstrumentState_result::~HIRealMonitor_GetCurrentInstrumentState_result() throw() {
}


uint32_t HIRealMonitor_GetCurrentInstrumentState_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetCurrentInstrumentState_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetCurrentInstrumentState_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetCurrentInstrumentState_presult::~HIRealMonitor_GetCurrentInstrumentState_presult() throw() {
}


uint32_t HIRealMonitor_GetCurrentInstrumentState_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetCounterOrTimer_args::~HIRealMonitor_SetCounterOrTimer_args() throw() {
}


uint32_t HIRealMonitor_SetCounterOrTimer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCounterOrTimerID);
          this->__isset.iCounterOrTimerID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iNumberOfTimesOrElapsedTime);
          this->__isset.iNumberOfTimesOrElapsedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetCounterOrTimer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetCounterOrTimer_args");

  xfer += oprot->writeFieldBegin("iCounterOrTimerID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iCounterOrTimerID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iNumberOfTimesOrElapsedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetCounterOrTimer_pargs::~HIRealMonitor_SetCounterOrTimer_pargs() throw() {
}


uint32_t HIRealMonitor_SetCounterOrTimer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetCounterOrTimer_pargs");

  xfer += oprot->writeFieldBegin("iCounterOrTimerID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iCounterOrTimerID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iNumberOfTimesOrElapsedTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetCounterOrTimer_result::~HIRealMonitor_SetCounterOrTimer_result() throw() {
}


uint32_t HIRealMonitor_SetCounterOrTimer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast73;
          xfer += iprot->readI32(ecast73);
          this->success = ( ::EXE_STATE::type)ecast73;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetCounterOrTimer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetCounterOrTimer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetCounterOrTimer_presult::~HIRealMonitor_SetCounterOrTimer_presult() throw() {
}


uint32_t HIRealMonitor_SetCounterOrTimer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast74;
          xfer += iprot->readI32(ecast74);
          (*(this->success)) = ( ::EXE_STATE::type)ecast74;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_SetTotalCounterOrTimer_args::~HIRealMonitor_SetTotalCounterOrTimer_args() throw() {
}


uint32_t HIRealMonitor_SetTotalCounterOrTimer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCounterOrTimerID);
          this->__isset.iCounterOrTimerID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTotalNumberOfTimesOrElapsedTime);
          this->__isset.iTotalNumberOfTimesOrElapsedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetTotalCounterOrTimer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetTotalCounterOrTimer_args");

  xfer += oprot->writeFieldBegin("iCounterOrTimerID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iCounterOrTimerID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTotalNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iTotalNumberOfTimesOrElapsedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetTotalCounterOrTimer_pargs::~HIRealMonitor_SetTotalCounterOrTimer_pargs() throw() {
}


uint32_t HIRealMonitor_SetTotalCounterOrTimer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_SetTotalCounterOrTimer_pargs");

  xfer += oprot->writeFieldBegin("iCounterOrTimerID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iCounterOrTimerID)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTotalNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iTotalNumberOfTimesOrElapsedTime)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetTotalCounterOrTimer_result::~HIRealMonitor_SetTotalCounterOrTimer_result() throw() {
}


uint32_t HIRealMonitor_SetTotalCounterOrTimer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast75;
          xfer += iprot->readI32(ecast75);
          this->success = ( ::EXE_STATE::type)ecast75;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_SetTotalCounterOrTimer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_SetTotalCounterOrTimer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_SetTotalCounterOrTimer_presult::~HIRealMonitor_SetTotalCounterOrTimer_presult() throw() {
}


uint32_t HIRealMonitor_SetTotalCounterOrTimer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast76;
          xfer += iprot->readI32(ecast76);
          (*(this->success)) = ( ::EXE_STATE::type)ecast76;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HIRealMonitor_GetAllCounterOrTimer_args::~HIRealMonitor_GetAllCounterOrTimer_args() throw() {
}


uint32_t HIRealMonitor_GetAllCounterOrTimer_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetAllCounterOrTimer_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetAllCounterOrTimer_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetAllCounterOrTimer_pargs::~HIRealMonitor_GetAllCounterOrTimer_pargs() throw() {
}


uint32_t HIRealMonitor_GetAllCounterOrTimer_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HIRealMonitor_GetAllCounterOrTimer_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetAllCounterOrTimer_result::~HIRealMonitor_GetAllCounterOrTimer_result() throw() {
}


uint32_t HIRealMonitor_GetAllCounterOrTimer_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->success.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->success[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HIRealMonitor_GetAllCounterOrTimer_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HIRealMonitor_GetAllCounterOrTimer_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->success.size()));
      std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> ::const_iterator _iter82;
      for (_iter82 = this->success.begin(); _iter82 != this->success.end(); ++_iter82)
      {
        xfer += (*_iter82).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HIRealMonitor_GetAllCounterOrTimer_presult::~HIRealMonitor_GetAllCounterOrTimer_presult() throw() {
}


uint32_t HIRealMonitor_GetAllCounterOrTimer_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size83;
            ::apache::thrift::protocol::TType _etype86;
            xfer += iprot->readListBegin(_etype86, _size83);
            (*(this->success)).resize(_size83);
            uint32_t _i87;
            for (_i87 = 0; _i87 < _size83; ++_i87)
            {
              xfer += (*(this->success))[_i87].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

 ::EXE_STATE::type HIRealMonitorClient::GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData)
{
  send_GetIOAsync(sensor, iUserData);
  return recv_GetIOAsync();
}

void HIRealMonitorClient::send_GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetIOAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetIOAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_GetIOAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetIOAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_GetIOAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetIOAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData)
{
  send_GetTemperatureAsync(sensor, iUserData);
  return recv_GetTemperatureAsync();
}

void HIRealMonitorClient::send_GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetTemperatureAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetTemperatureAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_GetTemperatureAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetTemperatureAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_GetTemperatureAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetTemperatureAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::GetPressureAsync(const int32_t sensor, const int32_t iUserData)
{
  send_GetPressureAsync(sensor, iUserData);
  return recv_GetPressureAsync();
}

void HIRealMonitorClient::send_GetPressureAsync(const int32_t sensor, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetPressureAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetPressureAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_GetPressureAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetPressureAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_GetPressureAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetPressureAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData)
{
  send_SetIOAsync(sensor, iState, iUserData);
  return recv_SetIOAsync();
}

void HIRealMonitorClient::send_SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetIOAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetIOAsync_pargs args;
  args.sensor = &sensor;
  args.iState = &iState;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetIOAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetIOAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetIOAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetIOAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData)
{
  send_ManualUnlockSlotAsync(sensor, iUserData);
  return recv_ManualUnlockSlotAsync();
}

void HIRealMonitorClient::send_ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ManualUnlockSlotAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_ManualUnlockSlotAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_ManualUnlockSlotAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ManualUnlockSlotAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_ManualUnlockSlotAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ManualUnlockSlotAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::GetLightSignalAsync(const int32_t iWave, const int32_t iUserData)
{
  send_GetLightSignalAsync(iWave, iUserData);
  return recv_GetLightSignalAsync();
}

void HIRealMonitorClient::send_GetLightSignalAsync(const int32_t iWave, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetLightSignalAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetLightSignalAsync_pargs args;
  args.iWave = &iWave;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_GetLightSignalAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetLightSignalAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_GetLightSignalAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLightSignalAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData)
{
  send_SetIndicatorLightAsync(iIndicatorLightNo, iColor, iBlink, iUserData);
  return recv_SetIndicatorLightAsync();
}

void HIRealMonitorClient::send_SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetIndicatorLightAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetIndicatorLightAsync_pargs args;
  args.iIndicatorLightNo = &iIndicatorLightNo;
  args.iColor = &iColor;
  args.iBlink = &iBlink;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetIndicatorLightAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetIndicatorLightAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetIndicatorLightAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetIndicatorLightAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData)
{
  send_SetAlarmSoundAsync(bOpen, iSound, iUserData);
  return recv_SetAlarmSoundAsync();
}

void HIRealMonitorClient::send_SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetAlarmSoundAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetAlarmSoundAsync_pargs args;
  args.bOpen = &bOpen;
  args.iSound = &iSound;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetAlarmSoundAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetAlarmSoundAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetAlarmSoundAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAlarmSoundAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::ManualStopAsync(const int32_t iUserData)
{
  send_ManualStopAsync(iUserData);
  return recv_ManualStopAsync();
}

void HIRealMonitorClient::send_ManualStopAsync(const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ManualStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_ManualStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_ManualStopAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ManualStopAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_ManualStopAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ManualStopAsync failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo)
{
  send_SetConsumablesInfo(tConsumablesInfo);
  return recv_SetConsumablesInfo();
}

void HIRealMonitorClient::send_SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetConsumablesInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetConsumablesInfo_pargs args;
  args.tConsumablesInfo = &tConsumablesInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetConsumablesInfo()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetConsumablesInfo") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetConsumablesInfo_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetConsumablesInfo failed: unknown result");
}

int32_t HIRealMonitorClient::GetCurrentInstrumentState()
{
  send_GetCurrentInstrumentState();
  return recv_GetCurrentInstrumentState();
}

void HIRealMonitorClient::send_GetCurrentInstrumentState()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetCurrentInstrumentState", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetCurrentInstrumentState_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HIRealMonitorClient::recv_GetCurrentInstrumentState()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetCurrentInstrumentState") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HIRealMonitor_GetCurrentInstrumentState_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentInstrumentState failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime)
{
  send_SetCounterOrTimer(iCounterOrTimerID, iNumberOfTimesOrElapsedTime);
  return recv_SetCounterOrTimer();
}

void HIRealMonitorClient::send_SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetCounterOrTimer_pargs args;
  args.iCounterOrTimerID = &iCounterOrTimerID;
  args.iNumberOfTimesOrElapsedTime = &iNumberOfTimesOrElapsedTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetCounterOrTimer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetCounterOrTimer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetCounterOrTimer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetCounterOrTimer failed: unknown result");
}

 ::EXE_STATE::type HIRealMonitorClient::SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime)
{
  send_SetTotalCounterOrTimer(iCounterOrTimerID, iTotalNumberOfTimesOrElapsedTime);
  return recv_SetTotalCounterOrTimer();
}

void HIRealMonitorClient::send_SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetTotalCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetTotalCounterOrTimer_pargs args;
  args.iCounterOrTimerID = &iCounterOrTimerID;
  args.iTotalNumberOfTimesOrElapsedTime = &iTotalNumberOfTimesOrElapsedTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HIRealMonitorClient::recv_SetTotalCounterOrTimer()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetTotalCounterOrTimer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HIRealMonitor_SetTotalCounterOrTimer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTotalCounterOrTimer failed: unknown result");
}

void HIRealMonitorClient::GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return)
{
  send_GetAllCounterOrTimer();
  recv_GetAllCounterOrTimer(_return);
}

void HIRealMonitorClient::send_GetAllCounterOrTimer()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("GetAllCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetAllCounterOrTimer_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HIRealMonitorClient::recv_GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("GetAllCounterOrTimer") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HIRealMonitor_GetAllCounterOrTimer_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetAllCounterOrTimer failed: unknown result");
}

bool HIRealMonitorProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void HIRealMonitorProcessor::process_GetIOAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetIOAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetIOAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetIOAsync");
  }

  HIRealMonitor_GetIOAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetIOAsync", bytes);
  }

  HIRealMonitor_GetIOAsync_result result;
  try {
    result.success = iface_->GetIOAsync(args.sensor, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetIOAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetIOAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetIOAsync");
  }

  oprot->writeMessageBegin("GetIOAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetIOAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_GetTemperatureAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetTemperatureAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetTemperatureAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetTemperatureAsync");
  }

  HIRealMonitor_GetTemperatureAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetTemperatureAsync", bytes);
  }

  HIRealMonitor_GetTemperatureAsync_result result;
  try {
    result.success = iface_->GetTemperatureAsync(args.sensor, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetTemperatureAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetTemperatureAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetTemperatureAsync");
  }

  oprot->writeMessageBegin("GetTemperatureAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetTemperatureAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_GetPressureAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetPressureAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetPressureAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetPressureAsync");
  }

  HIRealMonitor_GetPressureAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetPressureAsync", bytes);
  }

  HIRealMonitor_GetPressureAsync_result result;
  try {
    result.success = iface_->GetPressureAsync(args.sensor, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetPressureAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetPressureAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetPressureAsync");
  }

  oprot->writeMessageBegin("GetPressureAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetPressureAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_SetIOAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetIOAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetIOAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetIOAsync");
  }

  HIRealMonitor_SetIOAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetIOAsync", bytes);
  }

  HIRealMonitor_SetIOAsync_result result;
  try {
    result.success = iface_->SetIOAsync(args.sensor, args.iState, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetIOAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetIOAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetIOAsync");
  }

  oprot->writeMessageBegin("SetIOAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetIOAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_ManualUnlockSlotAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.ManualUnlockSlotAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.ManualUnlockSlotAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.ManualUnlockSlotAsync");
  }

  HIRealMonitor_ManualUnlockSlotAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.ManualUnlockSlotAsync", bytes);
  }

  HIRealMonitor_ManualUnlockSlotAsync_result result;
  try {
    result.success = iface_->ManualUnlockSlotAsync(args.sensor, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.ManualUnlockSlotAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ManualUnlockSlotAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.ManualUnlockSlotAsync");
  }

  oprot->writeMessageBegin("ManualUnlockSlotAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.ManualUnlockSlotAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_GetLightSignalAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetLightSignalAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetLightSignalAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetLightSignalAsync");
  }

  HIRealMonitor_GetLightSignalAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetLightSignalAsync", bytes);
  }

  HIRealMonitor_GetLightSignalAsync_result result;
  try {
    result.success = iface_->GetLightSignalAsync(args.iWave, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetLightSignalAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetLightSignalAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetLightSignalAsync");
  }

  oprot->writeMessageBegin("GetLightSignalAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetLightSignalAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_SetIndicatorLightAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetIndicatorLightAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetIndicatorLightAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetIndicatorLightAsync");
  }

  HIRealMonitor_SetIndicatorLightAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetIndicatorLightAsync", bytes);
  }

  HIRealMonitor_SetIndicatorLightAsync_result result;
  try {
    result.success = iface_->SetIndicatorLightAsync(args.iIndicatorLightNo, args.iColor, args.iBlink, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetIndicatorLightAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetIndicatorLightAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetIndicatorLightAsync");
  }

  oprot->writeMessageBegin("SetIndicatorLightAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetIndicatorLightAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_SetAlarmSoundAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetAlarmSoundAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetAlarmSoundAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetAlarmSoundAsync");
  }

  HIRealMonitor_SetAlarmSoundAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetAlarmSoundAsync", bytes);
  }

  HIRealMonitor_SetAlarmSoundAsync_result result;
  try {
    result.success = iface_->SetAlarmSoundAsync(args.bOpen, args.iSound, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetAlarmSoundAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetAlarmSoundAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetAlarmSoundAsync");
  }

  oprot->writeMessageBegin("SetAlarmSoundAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetAlarmSoundAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_ManualStopAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.ManualStopAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.ManualStopAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.ManualStopAsync");
  }

  HIRealMonitor_ManualStopAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.ManualStopAsync", bytes);
  }

  HIRealMonitor_ManualStopAsync_result result;
  try {
    result.success = iface_->ManualStopAsync(args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.ManualStopAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ManualStopAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.ManualStopAsync");
  }

  oprot->writeMessageBegin("ManualStopAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.ManualStopAsync", bytes);
  }
}

void HIRealMonitorProcessor::process_SetConsumablesInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetConsumablesInfo", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetConsumablesInfo");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetConsumablesInfo");
  }

  HIRealMonitor_SetConsumablesInfo_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetConsumablesInfo", bytes);
  }

  HIRealMonitor_SetConsumablesInfo_result result;
  try {
    result.success = iface_->SetConsumablesInfo(args.tConsumablesInfo);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetConsumablesInfo");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetConsumablesInfo", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetConsumablesInfo");
  }

  oprot->writeMessageBegin("SetConsumablesInfo", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetConsumablesInfo", bytes);
  }
}

void HIRealMonitorProcessor::process_GetCurrentInstrumentState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetCurrentInstrumentState", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetCurrentInstrumentState");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetCurrentInstrumentState");
  }

  HIRealMonitor_GetCurrentInstrumentState_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetCurrentInstrumentState", bytes);
  }

  HIRealMonitor_GetCurrentInstrumentState_result result;
  try {
    result.success = iface_->GetCurrentInstrumentState();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetCurrentInstrumentState");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetCurrentInstrumentState", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetCurrentInstrumentState");
  }

  oprot->writeMessageBegin("GetCurrentInstrumentState", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetCurrentInstrumentState", bytes);
  }
}

void HIRealMonitorProcessor::process_SetCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetCounterOrTimer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetCounterOrTimer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetCounterOrTimer");
  }

  HIRealMonitor_SetCounterOrTimer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetCounterOrTimer", bytes);
  }

  HIRealMonitor_SetCounterOrTimer_result result;
  try {
    result.success = iface_->SetCounterOrTimer(args.iCounterOrTimerID, args.iNumberOfTimesOrElapsedTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetCounterOrTimer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetCounterOrTimer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetCounterOrTimer");
  }

  oprot->writeMessageBegin("SetCounterOrTimer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetCounterOrTimer", bytes);
  }
}

void HIRealMonitorProcessor::process_SetTotalCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.SetTotalCounterOrTimer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.SetTotalCounterOrTimer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.SetTotalCounterOrTimer");
  }

  HIRealMonitor_SetTotalCounterOrTimer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.SetTotalCounterOrTimer", bytes);
  }

  HIRealMonitor_SetTotalCounterOrTimer_result result;
  try {
    result.success = iface_->SetTotalCounterOrTimer(args.iCounterOrTimerID, args.iTotalNumberOfTimesOrElapsedTime);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.SetTotalCounterOrTimer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetTotalCounterOrTimer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.SetTotalCounterOrTimer");
  }

  oprot->writeMessageBegin("SetTotalCounterOrTimer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.SetTotalCounterOrTimer", bytes);
  }
}

void HIRealMonitorProcessor::process_GetAllCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HIRealMonitor.GetAllCounterOrTimer", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HIRealMonitor.GetAllCounterOrTimer");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HIRealMonitor.GetAllCounterOrTimer");
  }

  HIRealMonitor_GetAllCounterOrTimer_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HIRealMonitor.GetAllCounterOrTimer", bytes);
  }

  HIRealMonitor_GetAllCounterOrTimer_result result;
  try {
    iface_->GetAllCounterOrTimer(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HIRealMonitor.GetAllCounterOrTimer");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("GetAllCounterOrTimer", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HIRealMonitor.GetAllCounterOrTimer");
  }

  oprot->writeMessageBegin("GetAllCounterOrTimer", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HIRealMonitor.GetAllCounterOrTimer", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > HIRealMonitorProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< HIRealMonitorIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< HIRealMonitorIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new HIRealMonitorProcessor(handler));
  return processor;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t seqid = send_GetIOAsync(sensor, iUserData);
  return recv_GetIOAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetIOAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetIOAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_GetIOAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetIOAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_GetIOAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetIOAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData)
{
  int32_t seqid = send_GetTemperatureAsync(sensor, iUserData);
  return recv_GetTemperatureAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetTemperatureAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetTemperatureAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_GetTemperatureAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetTemperatureAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_GetTemperatureAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetTemperatureAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::GetPressureAsync(const int32_t sensor, const int32_t iUserData)
{
  int32_t seqid = send_GetPressureAsync(sensor, iUserData);
  return recv_GetPressureAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetPressureAsync(const int32_t sensor, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetPressureAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetPressureAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_GetPressureAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetPressureAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_GetPressureAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetPressureAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData)
{
  int32_t seqid = send_SetIOAsync(sensor, iState, iUserData);
  return recv_SetIOAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetIOAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetIOAsync_pargs args;
  args.sensor = &sensor;
  args.iState = &iState;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetIOAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetIOAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetIOAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetIOAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t seqid = send_ManualUnlockSlotAsync(sensor, iUserData);
  return recv_ManualUnlockSlotAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ManualUnlockSlotAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_ManualUnlockSlotAsync_pargs args;
  args.sensor = &sensor;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_ManualUnlockSlotAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ManualUnlockSlotAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_ManualUnlockSlotAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ManualUnlockSlotAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::GetLightSignalAsync(const int32_t iWave, const int32_t iUserData)
{
  int32_t seqid = send_GetLightSignalAsync(iWave, iUserData);
  return recv_GetLightSignalAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetLightSignalAsync(const int32_t iWave, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetLightSignalAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetLightSignalAsync_pargs args;
  args.iWave = &iWave;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_GetLightSignalAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetLightSignalAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_GetLightSignalAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetLightSignalAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData)
{
  int32_t seqid = send_SetIndicatorLightAsync(iIndicatorLightNo, iColor, iBlink, iUserData);
  return recv_SetIndicatorLightAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetIndicatorLightAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetIndicatorLightAsync_pargs args;
  args.iIndicatorLightNo = &iIndicatorLightNo;
  args.iColor = &iColor;
  args.iBlink = &iBlink;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetIndicatorLightAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetIndicatorLightAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetIndicatorLightAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetIndicatorLightAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData)
{
  int32_t seqid = send_SetAlarmSoundAsync(bOpen, iSound, iUserData);
  return recv_SetAlarmSoundAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetAlarmSoundAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetAlarmSoundAsync_pargs args;
  args.bOpen = &bOpen;
  args.iSound = &iSound;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetAlarmSoundAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetAlarmSoundAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetAlarmSoundAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetAlarmSoundAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::ManualStopAsync(const int32_t iUserData)
{
  int32_t seqid = send_ManualStopAsync(iUserData);
  return recv_ManualStopAsync(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_ManualStopAsync(const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ManualStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_ManualStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_ManualStopAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ManualStopAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_ManualStopAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ManualStopAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo)
{
  int32_t seqid = send_SetConsumablesInfo(tConsumablesInfo);
  return recv_SetConsumablesInfo(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetConsumablesInfo", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetConsumablesInfo_pargs args;
  args.tConsumablesInfo = &tConsumablesInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetConsumablesInfo(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetConsumablesInfo") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetConsumablesInfo_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetConsumablesInfo failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t HIRealMonitorConcurrentClient::GetCurrentInstrumentState()
{
  int32_t seqid = send_GetCurrentInstrumentState();
  return recv_GetCurrentInstrumentState(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetCurrentInstrumentState()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetCurrentInstrumentState", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetCurrentInstrumentState_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HIRealMonitorConcurrentClient::recv_GetCurrentInstrumentState(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetCurrentInstrumentState") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HIRealMonitor_GetCurrentInstrumentState_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetCurrentInstrumentState failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime)
{
  int32_t seqid = send_SetCounterOrTimer(iCounterOrTimerID, iNumberOfTimesOrElapsedTime);
  return recv_SetCounterOrTimer(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetCounterOrTimer_pargs args;
  args.iCounterOrTimerID = &iCounterOrTimerID;
  args.iNumberOfTimesOrElapsedTime = &iNumberOfTimesOrElapsedTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetCounterOrTimer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetCounterOrTimer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetCounterOrTimer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetCounterOrTimer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime)
{
  int32_t seqid = send_SetTotalCounterOrTimer(iCounterOrTimerID, iTotalNumberOfTimesOrElapsedTime);
  return recv_SetTotalCounterOrTimer(seqid);
}

int32_t HIRealMonitorConcurrentClient::send_SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetTotalCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_SetTotalCounterOrTimer_pargs args;
  args.iCounterOrTimerID = &iCounterOrTimerID;
  args.iTotalNumberOfTimesOrElapsedTime = &iTotalNumberOfTimesOrElapsedTime;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HIRealMonitorConcurrentClient::recv_SetTotalCounterOrTimer(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetTotalCounterOrTimer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HIRealMonitor_SetTotalCounterOrTimer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetTotalCounterOrTimer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void HIRealMonitorConcurrentClient::GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return)
{
  int32_t seqid = send_GetAllCounterOrTimer();
  recv_GetAllCounterOrTimer(_return, seqid);
}

int32_t HIRealMonitorConcurrentClient::send_GetAllCounterOrTimer()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("GetAllCounterOrTimer", ::apache::thrift::protocol::T_CALL, cseqid);

  HIRealMonitor_GetAllCounterOrTimer_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HIRealMonitorConcurrentClient::recv_GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("GetAllCounterOrTimer") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HIRealMonitor_GetAllCounterOrTimer_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "GetAllCounterOrTimer failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

} // namespace

