/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Defs_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kEXE_STATEValues[] = {
  EXE_STATE::SUCCESS,
  EXE_STATE::FAIL
};
const char* _kEXE_STATENames[] = {
  "SUCCESS",
  "FAIL"
};
const std::map<int, const char*> _EXE_STATE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kEXE_STATEValues, _kEXE_STATENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const EXE_STATE::type& val) {
  std::map<int, const char*>::const_iterator it = _EXE_STATE_VALUES_TO_NAMES.find(val);
  if (it != _EXE_STATE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kNEEDLE_TYPEValues[] = {
  NEEDLE_TYPE::SAMPLENEEDLE,
  NEEDLE_TYPE::REAGENTNEEDLE1,
  NEEDLE_TYPE::REAGENTNEEDLE2
};
const char* _kNEEDLE_TYPENames[] = {
  "SAMPLENEEDLE",
  "REAGENTNEEDLE1",
  "REAGENTNEEDLE2"
};
const std::map<int, const char*> _NEEDLE_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kNEEDLE_TYPEValues, _kNEEDLE_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const NEEDLE_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _NEEDLE_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _NEEDLE_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kOUTPUT_IOValues[] = {
  OUTPUT_IO::PE_REGENT_TABLE_GATE,
  OUTPUT_IO::MICRO_GATE_CUVETTE,
  OUTPUT_IO::PE_DILU_1,
  OUTPUT_IO::PE_DILU_2,
  OUTPUT_IO::PE_INSTRUMENT_GATE,
  OUTPUT_IO::PE_WASTE_FULL,
  OUTPUT_IO::PE_WASTE_EXIST,
  OUTPUT_IO::PE_WASHA,
  OUTPUT_IO::WASHA_BUBBLE_SENSOR,
  OUTPUT_IO::WASHB_BUBBLE_SENSOR,
  OUTPUT_IO::WASTESENSOR,
  OUTPUT_IO::WASHSENSOR,
  OUTPUT_IO::MAGNETIC_BEAD_AD_1,
  OUTPUT_IO::MAGNETIC_BEAD_AD_2,
  OUTPUT_IO::MAGNETIC_BEAD_AD_3,
  OUTPUT_IO::MAGNETIC_BEAD_AD_4,
  OUTPUT_IO::OPTICAL_AD_1,
  OUTPUT_IO::OPTICAL_AD_2,
  OUTPUT_IO::OPTICAL_AD_3,
  OUTPUT_IO::OPTICAL_AD_4,
  OUTPUT_IO::OPTICAL_AD_5,
  OUTPUT_IO::OPTICAL_AD_6,
  OUTPUT_IO::OPTICAL_AD_7,
  OUTPUT_IO::OPTICAL_AD_8,
  OUTPUT_IO::SAMPLE_SLOT_IO1,
  OUTPUT_IO::SAMPLE_SLOT_IO2,
  OUTPUT_IO::SAMPLE_SLOT_IO3,
  OUTPUT_IO::SAMPLE_SLOT_IO4,
  OUTPUT_IO::SAMPLE_SLOT_IO5,
  OUTPUT_IO::SAMPLE_SLOT_IO6
};
const char* _kOUTPUT_IONames[] = {
  "PE_REGENT_TABLE_GATE",
  "MICRO_GATE_CUVETTE",
  "PE_DILU_1",
  "PE_DILU_2",
  "PE_INSTRUMENT_GATE",
  "PE_WASTE_FULL",
  "PE_WASTE_EXIST",
  "PE_WASHA",
  "WASHA_BUBBLE_SENSOR",
  "WASHB_BUBBLE_SENSOR",
  "WASTESENSOR",
  "WASHSENSOR",
  "MAGNETIC_BEAD_AD_1",
  "MAGNETIC_BEAD_AD_2",
  "MAGNETIC_BEAD_AD_3",
  "MAGNETIC_BEAD_AD_4",
  "OPTICAL_AD_1",
  "OPTICAL_AD_2",
  "OPTICAL_AD_3",
  "OPTICAL_AD_4",
  "OPTICAL_AD_5",
  "OPTICAL_AD_6",
  "OPTICAL_AD_7",
  "OPTICAL_AD_8",
  "SAMPLE_SLOT_IO1",
  "SAMPLE_SLOT_IO2",
  "SAMPLE_SLOT_IO3",
  "SAMPLE_SLOT_IO4",
  "SAMPLE_SLOT_IO5",
  "SAMPLE_SLOT_IO6"
};
const std::map<int, const char*> _OUTPUT_IO_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(30, _kOUTPUT_IOValues, _kOUTPUT_IONames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const OUTPUT_IO::type& val) {
  std::map<int, const char*>::const_iterator it = _OUTPUT_IO_VALUES_TO_NAMES.find(val);
  if (it != _OUTPUT_IO_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kTEMPERATURE_SENSORValues[] = {
  TEMPERATURE_SENSOR::REAGENTCASE,
  TEMPERATURE_SENSOR::REAGENTPIPE,
  TEMPERATURE_SENSOR::INCUBATIONAREA,
  TEMPERATURE_SENSOR::MAGNETICBEAD,
  TEMPERATURE_SENSOR::ENVIRONMENTAREA,
  TEMPERATURE_SENSOR::REAGENTCASEGLASS,
  TEMPERATURE_SENSOR::OPTICAL1,
  TEMPERATURE_SENSOR::OPTICAL2
};
const char* _kTEMPERATURE_SENSORNames[] = {
  "REAGENTCASE",
  "REAGENTPIPE",
  "INCUBATIONAREA",
  "MAGNETICBEAD",
  "ENVIRONMENTAREA",
  "REAGENTCASEGLASS",
  "OPTICAL1",
  "OPTICAL2"
};
const std::map<int, const char*> _TEMPERATURE_SENSOR_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kTEMPERATURE_SENSORValues, _kTEMPERATURE_SENSORNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const TEMPERATURE_SENSOR::type& val) {
  std::map<int, const char*>::const_iterator it = _TEMPERATURE_SENSOR_VALUES_TO_NAMES.find(val);
  if (it != _TEMPERATURE_SENSOR_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kINPUT_IOValues[] = {
  INPUT_IO::CUPLOADPOS1,
  INPUT_IO::CUPLOADPOS2,
  INPUT_IO::SAMPLE_SLOT_IO1,
  INPUT_IO::SAMPLE_SLOT_IO2,
  INPUT_IO::SAMPLE_SLOT_IO3,
  INPUT_IO::SAMPLE_SLOT_IO4,
  INPUT_IO::SAMPLE_SLOT_IO5,
  INPUT_IO::SAMPLE_SLOT_IO6
};
const char* _kINPUT_IONames[] = {
  "CUPLOADPOS1",
  "CUPLOADPOS2",
  "SAMPLE_SLOT_IO1",
  "SAMPLE_SLOT_IO2",
  "SAMPLE_SLOT_IO3",
  "SAMPLE_SLOT_IO4",
  "SAMPLE_SLOT_IO5",
  "SAMPLE_SLOT_IO6"
};
const std::map<int, const char*> _INPUT_IO_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kINPUT_IOValues, _kINPUT_IONames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const INPUT_IO::type& val) {
  std::map<int, const char*>::const_iterator it = _INPUT_IO_VALUES_TO_NAMES.find(val);
  if (it != _INPUT_IO_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kBOTTLE_TYPEValues[] = {
  BOTTLE_TYPE::BT_UNKNOWN,
  BOTTLE_TYPE::BT_REAGENT_7_ML,
  BOTTLE_TYPE::BT_REAGENT_15_ML,
  BOTTLE_TYPE::BT_REAGENT_25_ML,
  BOTTLE_TYPE::BT_REAGENT_3_ML,
  BOTTLE_TYPE::BT_REAGENT_200_ML,
  BOTTLE_TYPE::BT_TUBE_MICRO,
  BOTTLE_TYPE::BT_TUBE_EP15
};
const char* _kBOTTLE_TYPENames[] = {
  "BT_UNKNOWN",
  "BT_REAGENT_7_ML",
  "BT_REAGENT_15_ML",
  "BT_REAGENT_25_ML",
  "BT_REAGENT_3_ML",
  "BT_REAGENT_200_ML",
  "BT_TUBE_MICRO",
  "BT_TUBE_EP15"
};
const std::map<int, const char*> _BOTTLE_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kBOTTLE_TYPEValues, _kBOTTLE_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const BOTTLE_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _BOTTLE_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _BOTTLE_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kSAMPLE_TUBE_TYPEValues[] = {
  SAMPLE_TUBE_TYPE::STANARD_CUP,
  SAMPLE_TUBE_TYPE::EP_CUP,
  SAMPLE_TUBE_TYPE::PP_1_8,
  SAMPLE_TUBE_TYPE::PP_2_7,
  SAMPLE_TUBE_TYPE::BT_V3,
  SAMPLE_TUBE_TYPE::BT_V7,
  SAMPLE_TUBE_TYPE::BT_V15
};
const char* _kSAMPLE_TUBE_TYPENames[] = {
  "STANARD_CUP",
  "EP_CUP",
  "PP_1_8",
  "PP_2_7",
  "BT_V3",
  "BT_V7",
  "BT_V15"
};
const std::map<int, const char*> _SAMPLE_TUBE_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kSAMPLE_TUBE_TYPEValues, _kSAMPLE_TUBE_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const SAMPLE_TUBE_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _SAMPLE_TUBE_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _SAMPLE_TUBE_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kORDER_STATEValues[] = {
  ORDER_STATE::OD_SAMPLECOMPLETION,
  ORDER_STATE::OD_INCUBATING,
  ORDER_STATE::OD_DETECTING,
  ORDER_STATE::OD_COMPLETION,
  ORDER_STATE::OD_ERROR,
  ORDER_STATE::OD_INIT,
  ORDER_STATE::OD_DEPRECATED
};
const char* _kORDER_STATENames[] = {
  "OD_SAMPLECOMPLETION",
  "OD_INCUBATING",
  "OD_DETECTING",
  "OD_COMPLETION",
  "OD_ERROR",
  "OD_INIT",
  "OD_DEPRECATED"
};
const std::map<int, const char*> _ORDER_STATE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kORDER_STATEValues, _kORDER_STATENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ORDER_STATE::type& val) {
  std::map<int, const char*>::const_iterator it = _ORDER_STATE_VALUES_TO_NAMES.find(val);
  if (it != _ORDER_STATE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kRESULT_STATEValues[] = {
  RESULT_STATE::NORMAL,
  RESULT_STATE::UN_CLOT,
  RESULT_STATE::ABNORMAL,
  RESULT_STATE::AD_OUT_OF_RANGE,
  RESULT_STATE::NO_BEAD
};
const char* _kRESULT_STATENames[] = {
  "NORMAL",
  "UN_CLOT",
  "ABNORMAL",
  "AD_OUT_OF_RANGE",
  "NO_BEAD"
};
const std::map<int, const char*> _RESULT_STATE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kRESULT_STATEValues, _kRESULT_STATENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RESULT_STATE::type& val) {
  std::map<int, const char*>::const_iterator it = _RESULT_STATE_VALUES_TO_NAMES.find(val);
  if (it != _RESULT_STATE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kREAGENT_SUPPLY_TYPEValues[] = {
  REAGENT_SUPPLY_TYPE::REAGENT,
  REAGENT_SUPPLY_TYPE::DILUENT,
  REAGENT_SUPPLY_TYPE::CUP,
  REAGENT_SUPPLY_TYPE::WASTE_CUP,
  REAGENT_SUPPLY_TYPE::WASH_B,
  REAGENT_SUPPLY_TYPE::WASH_A,
  REAGENT_SUPPLY_TYPE::WASTE_WATER,
  REAGENT_SUPPLY_TYPE::PUNCTURE_NEEDLE,
  REAGENT_SUPPLY_TYPE::AIR_PUMP,
  REAGENT_SUPPLY_TYPE::REAGENT_QC
};
const char* _kREAGENT_SUPPLY_TYPENames[] = {
  "REAGENT",
  "DILUENT",
  "CUP",
  "WASTE_CUP",
  "WASH_B",
  "WASH_A",
  "WASTE_WATER",
  "PUNCTURE_NEEDLE",
  "AIR_PUMP",
  "REAGENT_QC"
};
const std::map<int, const char*> _REAGENT_SUPPLY_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(10, _kREAGENT_SUPPLY_TYPEValues, _kREAGENT_SUPPLY_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const REAGENT_SUPPLY_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _REAGENT_SUPPLY_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _REAGENT_SUPPLY_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kENGINEER_DEBUG_AXIS_TYPEValues[] = {
  ENGINEER_DEBUG_AXIS_TYPE::R_NONE,
  ENGINEER_DEBUG_AXIS_TYPE::R_AXIS,
  ENGINEER_DEBUG_AXIS_TYPE::X_AXIS,
  ENGINEER_DEBUG_AXIS_TYPE::Y_AXIS,
  ENGINEER_DEBUG_AXIS_TYPE::Z_AXIS
};
const char* _kENGINEER_DEBUG_AXIS_TYPENames[] = {
  "R_NONE",
  "R_AXIS",
  "X_AXIS",
  "Y_AXIS",
  "Z_AXIS"
};
const std::map<int, const char*> _ENGINEER_DEBUG_AXIS_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kENGINEER_DEBUG_AXIS_TYPEValues, _kENGINEER_DEBUG_AXIS_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_AXIS_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _ENGINEER_DEBUG_AXIS_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _ENGINEER_DEBUG_AXIS_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kENGINEER_DEBUG_ACTION_TYPEValues[] = {
  ENGINEER_DEBUG_ACTION_TYPE::EDAT_NONE,
  ENGINEER_DEBUG_ACTION_TYPE::MOVE,
  ENGINEER_DEBUG_ACTION_TYPE::MOVE_TO,
  ENGINEER_DEBUG_ACTION_TYPE::RESET,
  ENGINEER_DEBUG_ACTION_TYPE::POWER_ON_RESET,
  ENGINEER_DEBUG_ACTION_TYPE::LIQUID_DETECT
};
const char* _kENGINEER_DEBUG_ACTION_TYPENames[] = {
  "EDAT_NONE",
  "MOVE",
  "MOVE_TO",
  "RESET",
  "POWER_ON_RESET",
  "LIQUID_DETECT"
};
const std::map<int, const char*> _ENGINEER_DEBUG_ACTION_TYPE_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kENGINEER_DEBUG_ACTION_TYPEValues, _kENGINEER_DEBUG_ACTION_TYPENames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_ACTION_TYPE::type& val) {
  std::map<int, const char*>::const_iterator it = _ENGINEER_DEBUG_ACTION_TYPE_VALUES_TO_NAMES.find(val);
  if (it != _ENGINEER_DEBUG_ACTION_TYPE_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


EXE_RESULT_T::~EXE_RESULT_T() throw() {
}


void EXE_RESULT_T::__set_state(const EXE_STATE::type val) {
  this->state = val;
}

void EXE_RESULT_T::__set_iResult(const int32_t val) {
  this->iResult = val;
}

void EXE_RESULT_T::__set_strResult(const std::string& val) {
  this->strResult = val;
}
std::ostream& operator<<(std::ostream& out, const EXE_RESULT_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EXE_RESULT_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->state = (EXE_STATE::type)ecast0;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iResult);
          this->__isset.iResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strResult);
          this->__isset.strResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t EXE_RESULT_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EXE_RESULT_T");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iResult", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strResult", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->strResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EXE_RESULT_T &a, EXE_RESULT_T &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.iResult, b.iResult);
  swap(a.strResult, b.strResult);
  swap(a.__isset, b.__isset);
}

EXE_RESULT_T::EXE_RESULT_T(const EXE_RESULT_T& other1) {
  state = other1.state;
  iResult = other1.iResult;
  strResult = other1.strResult;
  __isset = other1.__isset;
}
EXE_RESULT_T& EXE_RESULT_T::operator=(const EXE_RESULT_T& other2) {
  state = other2.state;
  iResult = other2.iResult;
  strResult = other2.strResult;
  __isset = other2.__isset;
  return *this;
}
void EXE_RESULT_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EXE_RESULT_T(";
  out << "state=" << to_string(state);
  out << ", " << "iResult=" << to_string(iResult);
  out << ", " << "strResult=" << to_string(strResult);
  out << ")";
}


RINSE_INFO_T::~RINSE_INFO_T() throw() {
}


void RINSE_INFO_T::__set_bEnable(const IBOOL val) {
  this->bEnable = val;
}

void RINSE_INFO_T::__set_bEnableWashA(const IBOOL val) {
  this->bEnableWashA = val;
}
std::ostream& operator<<(std::ostream& out, const RINSE_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RINSE_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnableWashA);
          this->__isset.bEnableWashA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RINSE_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RINSE_INFO_T");

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnableWashA", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bEnableWashA);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RINSE_INFO_T &a, RINSE_INFO_T &b) {
  using ::std::swap;
  swap(a.bEnable, b.bEnable);
  swap(a.bEnableWashA, b.bEnableWashA);
  swap(a.__isset, b.__isset);
}

RINSE_INFO_T::RINSE_INFO_T(const RINSE_INFO_T& other3) {
  bEnable = other3.bEnable;
  bEnableWashA = other3.bEnableWashA;
  __isset = other3.__isset;
}
RINSE_INFO_T& RINSE_INFO_T::operator=(const RINSE_INFO_T& other4) {
  bEnable = other4.bEnable;
  bEnableWashA = other4.bEnableWashA;
  __isset = other4.__isset;
  return *this;
}
void RINSE_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RINSE_INFO_T(";
  out << "bEnable=" << to_string(bEnable);
  out << ", " << "bEnableWashA=" << to_string(bEnableWashA);
  out << ")";
}


REAGENT_INFO_T::~REAGENT_INFO_T() throw() {
}


void REAGENT_INFO_T::__set_iR(const int32_t val) {
  this->iR = val;
}

void REAGENT_INFO_T::__set_iPosIndex(const int32_t val) {
  this->iPosIndex = val;
}

void REAGENT_INFO_T::__set_iBottleType(const int32_t val) {
  this->iBottleType = val;
}

void REAGENT_INFO_T::__set_tPreRinseInfo(const RINSE_INFO_T& val) {
  this->tPreRinseInfo = val;
}

void REAGENT_INFO_T::__set_tPostRinseInfo(const RINSE_INFO_T& val) {
  this->tPostRinseInfo = val;
}

void REAGENT_INFO_T::__set_iAspriationVol(const int32_t val) {
  this->iAspriationVol = val;
}

void REAGENT_INFO_T::__set_bEnableHeat(const IBOOL val) {
  this->bEnableHeat = val;
}

void REAGENT_INFO_T::__set_bEnableMixing(const IBOOL val) {
  this->bEnableMixing = val;
}

void REAGENT_INFO_T::__set_iMixingType(const int32_t val) {
  this->iMixingType = val;
}

void REAGENT_INFO_T::__set_iMixingRate(const int32_t val) {
  this->iMixingRate = val;
}
std::ostream& operator<<(std::ostream& out, const REAGENT_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t REAGENT_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iR);
          this->__isset.iR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPosIndex);
          this->__isset.iPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iBottleType);
          this->__isset.iBottleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tPreRinseInfo.read(iprot);
          this->__isset.tPreRinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tPostRinseInfo.read(iprot);
          this->__isset.tPostRinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iAspriationVol);
          this->__isset.iAspriationVol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnableHeat);
          this->__isset.bEnableHeat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnableMixing);
          this->__isset.bEnableMixing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMixingType);
          this->__isset.iMixingType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMixingRate);
          this->__isset.iMixingRate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t REAGENT_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("REAGENT_INFO_T");

  xfer += oprot->writeFieldBegin("iR", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPosIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBottleType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iBottleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tPreRinseInfo", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->tPreRinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tPostRinseInfo", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->tPostRinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iAspriationVol", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iAspriationVol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnableHeat", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bEnableHeat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnableMixing", ::apache::thrift::protocol::T_BOOL, 8);
  xfer += oprot->writeBool(this->bEnableMixing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMixingType", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->iMixingType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMixingRate", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->iMixingRate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(REAGENT_INFO_T &a, REAGENT_INFO_T &b) {
  using ::std::swap;
  swap(a.iR, b.iR);
  swap(a.iPosIndex, b.iPosIndex);
  swap(a.iBottleType, b.iBottleType);
  swap(a.tPreRinseInfo, b.tPreRinseInfo);
  swap(a.tPostRinseInfo, b.tPostRinseInfo);
  swap(a.iAspriationVol, b.iAspriationVol);
  swap(a.bEnableHeat, b.bEnableHeat);
  swap(a.bEnableMixing, b.bEnableMixing);
  swap(a.iMixingType, b.iMixingType);
  swap(a.iMixingRate, b.iMixingRate);
  swap(a.__isset, b.__isset);
}

REAGENT_INFO_T::REAGENT_INFO_T(const REAGENT_INFO_T& other5) {
  iR = other5.iR;
  iPosIndex = other5.iPosIndex;
  iBottleType = other5.iBottleType;
  tPreRinseInfo = other5.tPreRinseInfo;
  tPostRinseInfo = other5.tPostRinseInfo;
  iAspriationVol = other5.iAspriationVol;
  bEnableHeat = other5.bEnableHeat;
  bEnableMixing = other5.bEnableMixing;
  iMixingType = other5.iMixingType;
  iMixingRate = other5.iMixingRate;
  __isset = other5.__isset;
}
REAGENT_INFO_T& REAGENT_INFO_T::operator=(const REAGENT_INFO_T& other6) {
  iR = other6.iR;
  iPosIndex = other6.iPosIndex;
  iBottleType = other6.iBottleType;
  tPreRinseInfo = other6.tPreRinseInfo;
  tPostRinseInfo = other6.tPostRinseInfo;
  iAspriationVol = other6.iAspriationVol;
  bEnableHeat = other6.bEnableHeat;
  bEnableMixing = other6.bEnableMixing;
  iMixingType = other6.iMixingType;
  iMixingRate = other6.iMixingRate;
  __isset = other6.__isset;
  return *this;
}
void REAGENT_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "REAGENT_INFO_T(";
  out << "iR=" << to_string(iR);
  out << ", " << "iPosIndex=" << to_string(iPosIndex);
  out << ", " << "iBottleType=" << to_string(iBottleType);
  out << ", " << "tPreRinseInfo=" << to_string(tPreRinseInfo);
  out << ", " << "tPostRinseInfo=" << to_string(tPostRinseInfo);
  out << ", " << "iAspriationVol=" << to_string(iAspriationVol);
  out << ", " << "bEnableHeat=" << to_string(bEnableHeat);
  out << ", " << "bEnableMixing=" << to_string(bEnableMixing);
  out << ", " << "iMixingType=" << to_string(iMixingType);
  out << ", " << "iMixingRate=" << to_string(iMixingRate);
  out << ")";
}


DILUTION_FRACTION_T::~DILUTION_FRACTION_T() throw() {
}


void DILUTION_FRACTION_T::__set_iUp(const int32_t val) {
  this->iUp = val;
}

void DILUTION_FRACTION_T::__set_iDown(const int32_t val) {
  this->iDown = val;
}
std::ostream& operator<<(std::ostream& out, const DILUTION_FRACTION_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DILUTION_FRACTION_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUp);
          this->__isset.iUp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDown);
          this->__isset.iDown = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DILUTION_FRACTION_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DILUTION_FRACTION_T");

  xfer += oprot->writeFieldBegin("iUp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iUp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDown", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iDown);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DILUTION_FRACTION_T &a, DILUTION_FRACTION_T &b) {
  using ::std::swap;
  swap(a.iUp, b.iUp);
  swap(a.iDown, b.iDown);
  swap(a.__isset, b.__isset);
}

DILUTION_FRACTION_T::DILUTION_FRACTION_T(const DILUTION_FRACTION_T& other7) {
  iUp = other7.iUp;
  iDown = other7.iDown;
  __isset = other7.__isset;
}
DILUTION_FRACTION_T& DILUTION_FRACTION_T::operator=(const DILUTION_FRACTION_T& other8) {
  iUp = other8.iUp;
  iDown = other8.iDown;
  __isset = other8.__isset;
  return *this;
}
void DILUTION_FRACTION_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DILUTION_FRACTION_T(";
  out << "iUp=" << to_string(iUp);
  out << ", " << "iDown=" << to_string(iDown);
  out << ")";
}


ORDER_INFO_T::~ORDER_INFO_T() throw() {
}


void ORDER_INFO_T::__set_iOrderNo(const int32_t val) {
  this->iOrderNo = val;
}

void ORDER_INFO_T::__set_strAssayGroup(const std::string& val) {
  this->strAssayGroup = val;
}

void ORDER_INFO_T::__set_iOrderType(const int32_t val) {
  this->iOrderType = val;
}

void ORDER_INFO_T::__set_iMethod(const int32_t val) {
  this->iMethod = val;
}

void ORDER_INFO_T::__set_iMagBeedClotPercent(const int32_t val) {
  this->iMagBeedClotPercent = val;
}

void ORDER_INFO_T::__set_iMagBeedDriveForce(const int32_t val) {
  this->iMagBeedDriveForce = val;
}

void ORDER_INFO_T::__set_iMagBeedMaxDetectSeconds(const int32_t val) {
  this->iMagBeedMaxDetectSeconds = val;
}

void ORDER_INFO_T::__set_iMagBeedMinDetectSeconds(const int32_t val) {
  this->iMagBeedMinDetectSeconds = val;
}

void ORDER_INFO_T::__set_iOpticsMainMeasurementSeconds(const int32_t val) {
  this->iOpticsMainMeasurementSeconds = val;
}

void ORDER_INFO_T::__set_iMainWavelenght(const int32_t val) {
  this->iMainWavelenght = val;
}

void ORDER_INFO_T::__set_iGain(const int32_t val) {
  this->iGain = val;
}

void ORDER_INFO_T::__set_iOpticsSubMeasurementSeconds(const int32_t val) {
  this->iOpticsSubMeasurementSeconds = val;
}

void ORDER_INFO_T::__set_iSubWavelenght(const int32_t val) {
  this->iSubWavelenght = val;
}

void ORDER_INFO_T::__set_iSampleVolume(const int32_t val) {
  this->iSampleVolume = val;
}

void ORDER_INFO_T::__set_tDiluentRatio(const DILUTION_FRACTION_T& val) {
  this->tDiluentRatio = val;
}

void ORDER_INFO_T::__set_iDiluentPos(const int32_t val) {
  this->iDiluentPos = val;
}

void ORDER_INFO_T::__set_tSamplePreRinseInfo(const RINSE_INFO_T& val) {
  this->tSamplePreRinseInfo = val;
}

void ORDER_INFO_T::__set_tSamplePostRinseInfo(const RINSE_INFO_T& val) {
  this->tSamplePostRinseInfo = val;
}

void ORDER_INFO_T::__set_bAddFactorDeficientPlasma(const IBOOL val) {
  this->bAddFactorDeficientPlasma = val;
}

void ORDER_INFO_T::__set_tFactorDeficientPlasmaInfo(const REAGENT_INFO_T& val) {
  this->tFactorDeficientPlasmaInfo = val;
}

void ORDER_INFO_T::__set_lstIncuReagentInfos(const std::vector<REAGENT_INFO_T> & val) {
  this->lstIncuReagentInfos = val;
}

void ORDER_INFO_T::__set_iIncubationSeconds(const int32_t val) {
  this->iIncubationSeconds = val;
}

void ORDER_INFO_T::__set_lstDeteReagentInfos(const std::vector<REAGENT_INFO_T> & val) {
  this->lstDeteReagentInfos = val;
}

void ORDER_INFO_T::__set_iCalibratorIndex(const int32_t val) {
  this->iCalibratorIndex = val;
}
std::ostream& operator<<(std::ostream& out, const ORDER_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ORDER_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOrderNo);
          this->__isset.iOrderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strAssayGroup);
          this->__isset.strAssayGroup = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOrderType);
          this->__isset.iOrderType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMethod);
          this->__isset.iMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMagBeedClotPercent);
          this->__isset.iMagBeedClotPercent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMagBeedDriveForce);
          this->__isset.iMagBeedDriveForce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMagBeedMaxDetectSeconds);
          this->__isset.iMagBeedMaxDetectSeconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMagBeedMinDetectSeconds);
          this->__isset.iMagBeedMinDetectSeconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOpticsMainMeasurementSeconds);
          this->__isset.iOpticsMainMeasurementSeconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMainWavelenght);
          this->__isset.iMainWavelenght = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iGain);
          this->__isset.iGain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOpticsSubMeasurementSeconds);
          this->__isset.iOpticsSubMeasurementSeconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSubWavelenght);
          this->__isset.iSubWavelenght = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSampleVolume);
          this->__isset.iSampleVolume = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tDiluentRatio.read(iprot);
          this->__isset.tDiluentRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDiluentPos);
          this->__isset.iDiluentPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tSamplePreRinseInfo.read(iprot);
          this->__isset.tSamplePreRinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tSamplePostRinseInfo.read(iprot);
          this->__isset.tSamplePostRinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bAddFactorDeficientPlasma);
          this->__isset.bAddFactorDeficientPlasma = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tFactorDeficientPlasmaInfo.read(iprot);
          this->__isset.tFactorDeficientPlasmaInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstIncuReagentInfos.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->lstIncuReagentInfos.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->lstIncuReagentInfos[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstIncuReagentInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIncubationSeconds);
          this->__isset.iIncubationSeconds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstDeteReagentInfos.clear();
            uint32_t _size14;
            ::apache::thrift::protocol::TType _etype17;
            xfer += iprot->readListBegin(_etype17, _size14);
            this->lstDeteReagentInfos.resize(_size14);
            uint32_t _i18;
            for (_i18 = 0; _i18 < _size14; ++_i18)
            {
              xfer += this->lstDeteReagentInfos[_i18].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstDeteReagentInfos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCalibratorIndex);
          this->__isset.iCalibratorIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ORDER_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ORDER_INFO_T");

  xfer += oprot->writeFieldBegin("iOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iOrderNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strAssayGroup", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strAssayGroup);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iOrderType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iOrderType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMethod", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iMethod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMagBeedClotPercent", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iMagBeedClotPercent);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMagBeedDriveForce", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iMagBeedDriveForce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMagBeedMaxDetectSeconds", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iMagBeedMaxDetectSeconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMagBeedMinDetectSeconds", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iMagBeedMinDetectSeconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iOpticsMainMeasurementSeconds", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->iOpticsMainMeasurementSeconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMainWavelenght", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->iMainWavelenght);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iGain", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->iGain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iOpticsSubMeasurementSeconds", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->iOpticsSubMeasurementSeconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSubWavelenght", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->iSubWavelenght);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSampleVolume", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->iSampleVolume);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tDiluentRatio", ::apache::thrift::protocol::T_STRUCT, 15);
  xfer += this->tDiluentRatio.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDiluentPos", ::apache::thrift::protocol::T_I32, 16);
  xfer += oprot->writeI32(this->iDiluentPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tSamplePreRinseInfo", ::apache::thrift::protocol::T_STRUCT, 17);
  xfer += this->tSamplePreRinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tSamplePostRinseInfo", ::apache::thrift::protocol::T_STRUCT, 18);
  xfer += this->tSamplePostRinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bAddFactorDeficientPlasma", ::apache::thrift::protocol::T_BOOL, 19);
  xfer += oprot->writeBool(this->bAddFactorDeficientPlasma);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tFactorDeficientPlasmaInfo", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->tFactorDeficientPlasmaInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstIncuReagentInfos", ::apache::thrift::protocol::T_LIST, 21);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lstIncuReagentInfos.size()));
    std::vector<REAGENT_INFO_T> ::const_iterator _iter19;
    for (_iter19 = this->lstIncuReagentInfos.begin(); _iter19 != this->lstIncuReagentInfos.end(); ++_iter19)
    {
      xfer += (*_iter19).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIncubationSeconds", ::apache::thrift::protocol::T_I32, 22);
  xfer += oprot->writeI32(this->iIncubationSeconds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstDeteReagentInfos", ::apache::thrift::protocol::T_LIST, 23);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lstDeteReagentInfos.size()));
    std::vector<REAGENT_INFO_T> ::const_iterator _iter20;
    for (_iter20 = this->lstDeteReagentInfos.begin(); _iter20 != this->lstDeteReagentInfos.end(); ++_iter20)
    {
      xfer += (*_iter20).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iCalibratorIndex", ::apache::thrift::protocol::T_I32, 24);
  xfer += oprot->writeI32(this->iCalibratorIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ORDER_INFO_T &a, ORDER_INFO_T &b) {
  using ::std::swap;
  swap(a.iOrderNo, b.iOrderNo);
  swap(a.strAssayGroup, b.strAssayGroup);
  swap(a.iOrderType, b.iOrderType);
  swap(a.iMethod, b.iMethod);
  swap(a.iMagBeedClotPercent, b.iMagBeedClotPercent);
  swap(a.iMagBeedDriveForce, b.iMagBeedDriveForce);
  swap(a.iMagBeedMaxDetectSeconds, b.iMagBeedMaxDetectSeconds);
  swap(a.iMagBeedMinDetectSeconds, b.iMagBeedMinDetectSeconds);
  swap(a.iOpticsMainMeasurementSeconds, b.iOpticsMainMeasurementSeconds);
  swap(a.iMainWavelenght, b.iMainWavelenght);
  swap(a.iGain, b.iGain);
  swap(a.iOpticsSubMeasurementSeconds, b.iOpticsSubMeasurementSeconds);
  swap(a.iSubWavelenght, b.iSubWavelenght);
  swap(a.iSampleVolume, b.iSampleVolume);
  swap(a.tDiluentRatio, b.tDiluentRatio);
  swap(a.iDiluentPos, b.iDiluentPos);
  swap(a.tSamplePreRinseInfo, b.tSamplePreRinseInfo);
  swap(a.tSamplePostRinseInfo, b.tSamplePostRinseInfo);
  swap(a.bAddFactorDeficientPlasma, b.bAddFactorDeficientPlasma);
  swap(a.tFactorDeficientPlasmaInfo, b.tFactorDeficientPlasmaInfo);
  swap(a.lstIncuReagentInfos, b.lstIncuReagentInfos);
  swap(a.iIncubationSeconds, b.iIncubationSeconds);
  swap(a.lstDeteReagentInfos, b.lstDeteReagentInfos);
  swap(a.iCalibratorIndex, b.iCalibratorIndex);
  swap(a.__isset, b.__isset);
}

ORDER_INFO_T::ORDER_INFO_T(const ORDER_INFO_T& other21) {
  iOrderNo = other21.iOrderNo;
  strAssayGroup = other21.strAssayGroup;
  iOrderType = other21.iOrderType;
  iMethod = other21.iMethod;
  iMagBeedClotPercent = other21.iMagBeedClotPercent;
  iMagBeedDriveForce = other21.iMagBeedDriveForce;
  iMagBeedMaxDetectSeconds = other21.iMagBeedMaxDetectSeconds;
  iMagBeedMinDetectSeconds = other21.iMagBeedMinDetectSeconds;
  iOpticsMainMeasurementSeconds = other21.iOpticsMainMeasurementSeconds;
  iMainWavelenght = other21.iMainWavelenght;
  iGain = other21.iGain;
  iOpticsSubMeasurementSeconds = other21.iOpticsSubMeasurementSeconds;
  iSubWavelenght = other21.iSubWavelenght;
  iSampleVolume = other21.iSampleVolume;
  tDiluentRatio = other21.tDiluentRatio;
  iDiluentPos = other21.iDiluentPos;
  tSamplePreRinseInfo = other21.tSamplePreRinseInfo;
  tSamplePostRinseInfo = other21.tSamplePostRinseInfo;
  bAddFactorDeficientPlasma = other21.bAddFactorDeficientPlasma;
  tFactorDeficientPlasmaInfo = other21.tFactorDeficientPlasmaInfo;
  lstIncuReagentInfos = other21.lstIncuReagentInfos;
  iIncubationSeconds = other21.iIncubationSeconds;
  lstDeteReagentInfos = other21.lstDeteReagentInfos;
  iCalibratorIndex = other21.iCalibratorIndex;
  __isset = other21.__isset;
}
ORDER_INFO_T& ORDER_INFO_T::operator=(const ORDER_INFO_T& other22) {
  iOrderNo = other22.iOrderNo;
  strAssayGroup = other22.strAssayGroup;
  iOrderType = other22.iOrderType;
  iMethod = other22.iMethod;
  iMagBeedClotPercent = other22.iMagBeedClotPercent;
  iMagBeedDriveForce = other22.iMagBeedDriveForce;
  iMagBeedMaxDetectSeconds = other22.iMagBeedMaxDetectSeconds;
  iMagBeedMinDetectSeconds = other22.iMagBeedMinDetectSeconds;
  iOpticsMainMeasurementSeconds = other22.iOpticsMainMeasurementSeconds;
  iMainWavelenght = other22.iMainWavelenght;
  iGain = other22.iGain;
  iOpticsSubMeasurementSeconds = other22.iOpticsSubMeasurementSeconds;
  iSubWavelenght = other22.iSubWavelenght;
  iSampleVolume = other22.iSampleVolume;
  tDiluentRatio = other22.tDiluentRatio;
  iDiluentPos = other22.iDiluentPos;
  tSamplePreRinseInfo = other22.tSamplePreRinseInfo;
  tSamplePostRinseInfo = other22.tSamplePostRinseInfo;
  bAddFactorDeficientPlasma = other22.bAddFactorDeficientPlasma;
  tFactorDeficientPlasmaInfo = other22.tFactorDeficientPlasmaInfo;
  lstIncuReagentInfos = other22.lstIncuReagentInfos;
  iIncubationSeconds = other22.iIncubationSeconds;
  lstDeteReagentInfos = other22.lstDeteReagentInfos;
  iCalibratorIndex = other22.iCalibratorIndex;
  __isset = other22.__isset;
  return *this;
}
void ORDER_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ORDER_INFO_T(";
  out << "iOrderNo=" << to_string(iOrderNo);
  out << ", " << "strAssayGroup=" << to_string(strAssayGroup);
  out << ", " << "iOrderType=" << to_string(iOrderType);
  out << ", " << "iMethod=" << to_string(iMethod);
  out << ", " << "iMagBeedClotPercent=" << to_string(iMagBeedClotPercent);
  out << ", " << "iMagBeedDriveForce=" << to_string(iMagBeedDriveForce);
  out << ", " << "iMagBeedMaxDetectSeconds=" << to_string(iMagBeedMaxDetectSeconds);
  out << ", " << "iMagBeedMinDetectSeconds=" << to_string(iMagBeedMinDetectSeconds);
  out << ", " << "iOpticsMainMeasurementSeconds=" << to_string(iOpticsMainMeasurementSeconds);
  out << ", " << "iMainWavelenght=" << to_string(iMainWavelenght);
  out << ", " << "iGain=" << to_string(iGain);
  out << ", " << "iOpticsSubMeasurementSeconds=" << to_string(iOpticsSubMeasurementSeconds);
  out << ", " << "iSubWavelenght=" << to_string(iSubWavelenght);
  out << ", " << "iSampleVolume=" << to_string(iSampleVolume);
  out << ", " << "tDiluentRatio=" << to_string(tDiluentRatio);
  out << ", " << "iDiluentPos=" << to_string(iDiluentPos);
  out << ", " << "tSamplePreRinseInfo=" << to_string(tSamplePreRinseInfo);
  out << ", " << "tSamplePostRinseInfo=" << to_string(tSamplePostRinseInfo);
  out << ", " << "bAddFactorDeficientPlasma=" << to_string(bAddFactorDeficientPlasma);
  out << ", " << "tFactorDeficientPlasmaInfo=" << to_string(tFactorDeficientPlasmaInfo);
  out << ", " << "lstIncuReagentInfos=" << to_string(lstIncuReagentInfos);
  out << ", " << "iIncubationSeconds=" << to_string(iIncubationSeconds);
  out << ", " << "lstDeteReagentInfos=" << to_string(lstDeteReagentInfos);
  out << ", " << "iCalibratorIndex=" << to_string(iCalibratorIndex);
  out << ")";
}


SAMPLE_QUALITY_SET_INFO_T::~SAMPLE_QUALITY_SET_INFO_T() throw() {
}


void SAMPLE_QUALITY_SET_INFO_T::__set_bIsCheckAnticoagulationRatio(const IBOOL val) {
  this->bIsCheckAnticoagulationRatio = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_iAnticoagulationRatioHandlingMode(const int32_t val) {
  this->iAnticoagulationRatioHandlingMode = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_dTubeInsideDiameter(const double val) {
  this->dTubeInsideDiameter = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_dBloodCapacity(const double val) {
  this->dBloodCapacity = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_dBloodCapacityFloat(const double val) {
  this->dBloodCapacityFloat = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_bIsCheckClot(const IBOOL val) {
  this->bIsCheckClot = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_iClotSensitivity(const int32_t val) {
  this->iClotSensitivity = val;
}

void SAMPLE_QUALITY_SET_INFO_T::__set_iClotHandlingMode(const int32_t val) {
  this->iClotHandlingMode = val;
}
std::ostream& operator<<(std::ostream& out, const SAMPLE_QUALITY_SET_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SAMPLE_QUALITY_SET_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsCheckAnticoagulationRatio);
          this->__isset.bIsCheckAnticoagulationRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iAnticoagulationRatioHandlingMode);
          this->__isset.iAnticoagulationRatioHandlingMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dTubeInsideDiameter);
          this->__isset.dTubeInsideDiameter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dBloodCapacity);
          this->__isset.dBloodCapacity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dBloodCapacityFloat);
          this->__isset.dBloodCapacityFloat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsCheckClot);
          this->__isset.bIsCheckClot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iClotSensitivity);
          this->__isset.iClotSensitivity = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iClotHandlingMode);
          this->__isset.iClotHandlingMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SAMPLE_QUALITY_SET_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SAMPLE_QUALITY_SET_INFO_T");

  xfer += oprot->writeFieldBegin("bIsCheckAnticoagulationRatio", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bIsCheckAnticoagulationRatio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iAnticoagulationRatioHandlingMode", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iAnticoagulationRatioHandlingMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dTubeInsideDiameter", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dTubeInsideDiameter);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dBloodCapacity", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dBloodCapacity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dBloodCapacityFloat", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->dBloodCapacityFloat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsCheckClot", ::apache::thrift::protocol::T_BOOL, 6);
  xfer += oprot->writeBool(this->bIsCheckClot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iClotSensitivity", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iClotSensitivity);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iClotHandlingMode", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iClotHandlingMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SAMPLE_QUALITY_SET_INFO_T &a, SAMPLE_QUALITY_SET_INFO_T &b) {
  using ::std::swap;
  swap(a.bIsCheckAnticoagulationRatio, b.bIsCheckAnticoagulationRatio);
  swap(a.iAnticoagulationRatioHandlingMode, b.iAnticoagulationRatioHandlingMode);
  swap(a.dTubeInsideDiameter, b.dTubeInsideDiameter);
  swap(a.dBloodCapacity, b.dBloodCapacity);
  swap(a.dBloodCapacityFloat, b.dBloodCapacityFloat);
  swap(a.bIsCheckClot, b.bIsCheckClot);
  swap(a.iClotSensitivity, b.iClotSensitivity);
  swap(a.iClotHandlingMode, b.iClotHandlingMode);
  swap(a.__isset, b.__isset);
}

SAMPLE_QUALITY_SET_INFO_T::SAMPLE_QUALITY_SET_INFO_T(const SAMPLE_QUALITY_SET_INFO_T& other23) {
  bIsCheckAnticoagulationRatio = other23.bIsCheckAnticoagulationRatio;
  iAnticoagulationRatioHandlingMode = other23.iAnticoagulationRatioHandlingMode;
  dTubeInsideDiameter = other23.dTubeInsideDiameter;
  dBloodCapacity = other23.dBloodCapacity;
  dBloodCapacityFloat = other23.dBloodCapacityFloat;
  bIsCheckClot = other23.bIsCheckClot;
  iClotSensitivity = other23.iClotSensitivity;
  iClotHandlingMode = other23.iClotHandlingMode;
  __isset = other23.__isset;
}
SAMPLE_QUALITY_SET_INFO_T& SAMPLE_QUALITY_SET_INFO_T::operator=(const SAMPLE_QUALITY_SET_INFO_T& other24) {
  bIsCheckAnticoagulationRatio = other24.bIsCheckAnticoagulationRatio;
  iAnticoagulationRatioHandlingMode = other24.iAnticoagulationRatioHandlingMode;
  dTubeInsideDiameter = other24.dTubeInsideDiameter;
  dBloodCapacity = other24.dBloodCapacity;
  dBloodCapacityFloat = other24.dBloodCapacityFloat;
  bIsCheckClot = other24.bIsCheckClot;
  iClotSensitivity = other24.iClotSensitivity;
  iClotHandlingMode = other24.iClotHandlingMode;
  __isset = other24.__isset;
  return *this;
}
void SAMPLE_QUALITY_SET_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SAMPLE_QUALITY_SET_INFO_T(";
  out << "bIsCheckAnticoagulationRatio=" << to_string(bIsCheckAnticoagulationRatio);
  out << ", " << "iAnticoagulationRatioHandlingMode=" << to_string(iAnticoagulationRatioHandlingMode);
  out << ", " << "dTubeInsideDiameter=" << to_string(dTubeInsideDiameter);
  out << ", " << "dBloodCapacity=" << to_string(dBloodCapacity);
  out << ", " << "dBloodCapacityFloat=" << to_string(dBloodCapacityFloat);
  out << ", " << "bIsCheckClot=" << to_string(bIsCheckClot);
  out << ", " << "iClotSensitivity=" << to_string(iClotSensitivity);
  out << ", " << "iClotHandlingMode=" << to_string(iClotHandlingMode);
  out << ")";
}


SAMPLE_ORDER_INFO_T::~SAMPLE_ORDER_INFO_T() throw() {
}


void SAMPLE_ORDER_INFO_T::__set_iSampleOrderNo(const int32_t val) {
  this->iSampleOrderNo = val;
}

void SAMPLE_ORDER_INFO_T::__set_tSampleQualitySet(const SAMPLE_QUALITY_SET_INFO_T& val) {
  this->tSampleQualitySet = val;
}

void SAMPLE_ORDER_INFO_T::__set_eSampleTubeType(const SAMPLE_TUBE_TYPE::type val) {
  this->eSampleTubeType = val;
}

void SAMPLE_ORDER_INFO_T::__set_iSlotNo(const int32_t val) {
  this->iSlotNo = val;
}

void SAMPLE_ORDER_INFO_T::__set_iRackIndex(const int32_t val) {
  this->iRackIndex = val;
}

void SAMPLE_ORDER_INFO_T::__set_iSamplePosIndex(const int32_t val) {
  this->iSamplePosIndex = val;
}

void SAMPLE_ORDER_INFO_T::__set_iPriority(const int32_t val) {
  this->iPriority = val;
}

void SAMPLE_ORDER_INFO_T::__set_lstOrderInfo(const std::vector<ORDER_INFO_T> & val) {
  this->lstOrderInfo = val;
}
std::ostream& operator<<(std::ostream& out, const SAMPLE_ORDER_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SAMPLE_ORDER_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSampleOrderNo);
          this->__isset.iSampleOrderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tSampleQualitySet.read(iprot);
          this->__isset.tSampleQualitySet = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast25;
          xfer += iprot->readI32(ecast25);
          this->eSampleTubeType = (SAMPLE_TUBE_TYPE::type)ecast25;
          this->__isset.eSampleTubeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlotNo);
          this->__isset.iSlotNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iRackIndex);
          this->__isset.iRackIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSamplePosIndex);
          this->__isset.iSamplePosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPriority);
          this->__isset.iPriority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstOrderInfo.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->lstOrderInfo.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->lstOrderInfo[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstOrderInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SAMPLE_ORDER_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SAMPLE_ORDER_INFO_T");

  xfer += oprot->writeFieldBegin("iSampleOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSampleOrderNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tSampleQualitySet", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tSampleQualitySet.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eSampleTubeType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->eSampleTubeType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSlotNo", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iSlotNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iRackIndex", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iRackIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSamplePosIndex", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iSamplePosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPriority", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iPriority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstOrderInfo", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lstOrderInfo.size()));
    std::vector<ORDER_INFO_T> ::const_iterator _iter31;
    for (_iter31 = this->lstOrderInfo.begin(); _iter31 != this->lstOrderInfo.end(); ++_iter31)
    {
      xfer += (*_iter31).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SAMPLE_ORDER_INFO_T &a, SAMPLE_ORDER_INFO_T &b) {
  using ::std::swap;
  swap(a.iSampleOrderNo, b.iSampleOrderNo);
  swap(a.tSampleQualitySet, b.tSampleQualitySet);
  swap(a.eSampleTubeType, b.eSampleTubeType);
  swap(a.iSlotNo, b.iSlotNo);
  swap(a.iRackIndex, b.iRackIndex);
  swap(a.iSamplePosIndex, b.iSamplePosIndex);
  swap(a.iPriority, b.iPriority);
  swap(a.lstOrderInfo, b.lstOrderInfo);
  swap(a.__isset, b.__isset);
}

SAMPLE_ORDER_INFO_T::SAMPLE_ORDER_INFO_T(const SAMPLE_ORDER_INFO_T& other32) {
  iSampleOrderNo = other32.iSampleOrderNo;
  tSampleQualitySet = other32.tSampleQualitySet;
  eSampleTubeType = other32.eSampleTubeType;
  iSlotNo = other32.iSlotNo;
  iRackIndex = other32.iRackIndex;
  iSamplePosIndex = other32.iSamplePosIndex;
  iPriority = other32.iPriority;
  lstOrderInfo = other32.lstOrderInfo;
  __isset = other32.__isset;
}
SAMPLE_ORDER_INFO_T& SAMPLE_ORDER_INFO_T::operator=(const SAMPLE_ORDER_INFO_T& other33) {
  iSampleOrderNo = other33.iSampleOrderNo;
  tSampleQualitySet = other33.tSampleQualitySet;
  eSampleTubeType = other33.eSampleTubeType;
  iSlotNo = other33.iSlotNo;
  iRackIndex = other33.iRackIndex;
  iSamplePosIndex = other33.iSamplePosIndex;
  iPriority = other33.iPriority;
  lstOrderInfo = other33.lstOrderInfo;
  __isset = other33.__isset;
  return *this;
}
void SAMPLE_ORDER_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SAMPLE_ORDER_INFO_T(";
  out << "iSampleOrderNo=" << to_string(iSampleOrderNo);
  out << ", " << "tSampleQualitySet=" << to_string(tSampleQualitySet);
  out << ", " << "eSampleTubeType=" << to_string(eSampleTubeType);
  out << ", " << "iSlotNo=" << to_string(iSlotNo);
  out << ", " << "iRackIndex=" << to_string(iRackIndex);
  out << ", " << "iSamplePosIndex=" << to_string(iSamplePosIndex);
  out << ", " << "iPriority=" << to_string(iPriority);
  out << ", " << "lstOrderInfo=" << to_string(lstOrderInfo);
  out << ")";
}


SAMPLE_QUALITY_T::~SAMPLE_QUALITY_T() throw() {
}


void SAMPLE_QUALITY_T::__set_bIsCheckAnticoagulationRatio(const IBOOL val) {
  this->bIsCheckAnticoagulationRatio = val;
}

void SAMPLE_QUALITY_T::__set_bIsARError(const IBOOL val) {
  this->bIsARError = val;
}

void SAMPLE_QUALITY_T::__set_bIsCheckClot(const IBOOL val) {
  this->bIsCheckClot = val;
}

void SAMPLE_QUALITY_T::__set_bIsClotError(const IBOOL val) {
  this->bIsClotError = val;
}
std::ostream& operator<<(std::ostream& out, const SAMPLE_QUALITY_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SAMPLE_QUALITY_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsCheckAnticoagulationRatio);
          this->__isset.bIsCheckAnticoagulationRatio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsARError);
          this->__isset.bIsARError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsCheckClot);
          this->__isset.bIsCheckClot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bIsClotError);
          this->__isset.bIsClotError = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SAMPLE_QUALITY_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SAMPLE_QUALITY_T");

  xfer += oprot->writeFieldBegin("bIsCheckAnticoagulationRatio", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->bIsCheckAnticoagulationRatio);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsARError", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bIsARError);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsCheckClot", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->bIsCheckClot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bIsClotError", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bIsClotError);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SAMPLE_QUALITY_T &a, SAMPLE_QUALITY_T &b) {
  using ::std::swap;
  swap(a.bIsCheckAnticoagulationRatio, b.bIsCheckAnticoagulationRatio);
  swap(a.bIsARError, b.bIsARError);
  swap(a.bIsCheckClot, b.bIsCheckClot);
  swap(a.bIsClotError, b.bIsClotError);
  swap(a.__isset, b.__isset);
}

SAMPLE_QUALITY_T::SAMPLE_QUALITY_T(const SAMPLE_QUALITY_T& other34) {
  bIsCheckAnticoagulationRatio = other34.bIsCheckAnticoagulationRatio;
  bIsARError = other34.bIsARError;
  bIsCheckClot = other34.bIsCheckClot;
  bIsClotError = other34.bIsClotError;
  __isset = other34.__isset;
}
SAMPLE_QUALITY_T& SAMPLE_QUALITY_T::operator=(const SAMPLE_QUALITY_T& other35) {
  bIsCheckAnticoagulationRatio = other35.bIsCheckAnticoagulationRatio;
  bIsARError = other35.bIsARError;
  bIsCheckClot = other35.bIsCheckClot;
  bIsClotError = other35.bIsClotError;
  __isset = other35.__isset;
  return *this;
}
void SAMPLE_QUALITY_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SAMPLE_QUALITY_T(";
  out << "bIsCheckAnticoagulationRatio=" << to_string(bIsCheckAnticoagulationRatio);
  out << ", " << "bIsARError=" << to_string(bIsARError);
  out << ", " << "bIsCheckClot=" << to_string(bIsCheckClot);
  out << ", " << "bIsClotError=" << to_string(bIsClotError);
  out << ")";
}


BOOT_PARAM_T::~BOOT_PARAM_T() throw() {
}


void BOOT_PARAM_T::__set_iWeek(const int32_t val) {
  this->iWeek = val;
}

void BOOT_PARAM_T::__set_iHour(const int32_t val) {
  this->iHour = val;
}

void BOOT_PARAM_T::__set_iMinute(const int32_t val) {
  this->iMinute = val;
}

void BOOT_PARAM_T::__set_bEnable(const IBOOL val) {
  this->bEnable = val;
}
std::ostream& operator<<(std::ostream& out, const BOOT_PARAM_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t BOOT_PARAM_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iWeek);
          this->__isset.iWeek = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHour);
          this->__isset.iHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMinute);
          this->__isset.iMinute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bEnable);
          this->__isset.bEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BOOT_PARAM_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BOOT_PARAM_T");

  xfer += oprot->writeFieldBegin("iWeek", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iWeek);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHour", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMinute", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iMinute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bEnable", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BOOT_PARAM_T &a, BOOT_PARAM_T &b) {
  using ::std::swap;
  swap(a.iWeek, b.iWeek);
  swap(a.iHour, b.iHour);
  swap(a.iMinute, b.iMinute);
  swap(a.bEnable, b.bEnable);
  swap(a.__isset, b.__isset);
}

BOOT_PARAM_T::BOOT_PARAM_T(const BOOT_PARAM_T& other36) {
  iWeek = other36.iWeek;
  iHour = other36.iHour;
  iMinute = other36.iMinute;
  bEnable = other36.bEnable;
  __isset = other36.__isset;
}
BOOT_PARAM_T& BOOT_PARAM_T::operator=(const BOOT_PARAM_T& other37) {
  iWeek = other37.iWeek;
  iHour = other37.iHour;
  iMinute = other37.iMinute;
  bEnable = other37.bEnable;
  __isset = other37.__isset;
  return *this;
}
void BOOT_PARAM_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BOOT_PARAM_T(";
  out << "iWeek=" << to_string(iWeek);
  out << ", " << "iHour=" << to_string(iHour);
  out << ", " << "iMinute=" << to_string(iMinute);
  out << ", " << "bEnable=" << to_string(bEnable);
  out << ")";
}


PIPELINE_FILL_INFO_T::~PIPELINE_FILL_INFO_T() throw() {
}


void PIPELINE_FILL_INFO_T::__set_tSampleRinseInfo(const RINSE_INFO_T& val) {
  this->tSampleRinseInfo = val;
}

void PIPELINE_FILL_INFO_T::__set_tReagnet1RinseInfo(const RINSE_INFO_T& val) {
  this->tReagnet1RinseInfo = val;
}

void PIPELINE_FILL_INFO_T::__set_tReagnet2RinseInfo(const RINSE_INFO_T& val) {
  this->tReagnet2RinseInfo = val;
}
std::ostream& operator<<(std::ostream& out, const PIPELINE_FILL_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PIPELINE_FILL_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tSampleRinseInfo.read(iprot);
          this->__isset.tSampleRinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tReagnet1RinseInfo.read(iprot);
          this->__isset.tReagnet1RinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tReagnet2RinseInfo.read(iprot);
          this->__isset.tReagnet2RinseInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PIPELINE_FILL_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PIPELINE_FILL_INFO_T");

  xfer += oprot->writeFieldBegin("tSampleRinseInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tSampleRinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tReagnet1RinseInfo", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tReagnet1RinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tReagnet2RinseInfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tReagnet2RinseInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PIPELINE_FILL_INFO_T &a, PIPELINE_FILL_INFO_T &b) {
  using ::std::swap;
  swap(a.tSampleRinseInfo, b.tSampleRinseInfo);
  swap(a.tReagnet1RinseInfo, b.tReagnet1RinseInfo);
  swap(a.tReagnet2RinseInfo, b.tReagnet2RinseInfo);
  swap(a.__isset, b.__isset);
}

PIPELINE_FILL_INFO_T::PIPELINE_FILL_INFO_T(const PIPELINE_FILL_INFO_T& other38) {
  tSampleRinseInfo = other38.tSampleRinseInfo;
  tReagnet1RinseInfo = other38.tReagnet1RinseInfo;
  tReagnet2RinseInfo = other38.tReagnet2RinseInfo;
  __isset = other38.__isset;
}
PIPELINE_FILL_INFO_T& PIPELINE_FILL_INFO_T::operator=(const PIPELINE_FILL_INFO_T& other39) {
  tSampleRinseInfo = other39.tSampleRinseInfo;
  tReagnet1RinseInfo = other39.tReagnet1RinseInfo;
  tReagnet2RinseInfo = other39.tReagnet2RinseInfo;
  __isset = other39.__isset;
  return *this;
}
void PIPELINE_FILL_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PIPELINE_FILL_INFO_T(";
  out << "tSampleRinseInfo=" << to_string(tSampleRinseInfo);
  out << ", " << "tReagnet1RinseInfo=" << to_string(tReagnet1RinseInfo);
  out << ", " << "tReagnet2RinseInfo=" << to_string(tReagnet2RinseInfo);
  out << ")";
}


REAGENT_POS_INFO_T::~REAGENT_POS_INFO_T() throw() {
}


void REAGENT_POS_INFO_T::__set_iPosIndex(const int32_t val) {
  this->iPosIndex = val;
}

void REAGENT_POS_INFO_T::__set_iIsRemainDetect(const int32_t val) {
  this->iIsRemainDetect = val;
}

void REAGENT_POS_INFO_T::__set_iBottleType(const int32_t val) {
  this->iBottleType = val;
}

void REAGENT_POS_INFO_T::__set_strReagentName(const std::string& val) {
  this->strReagentName = val;
}

void REAGENT_POS_INFO_T::__set_strReagentLot(const std::string& val) {
  this->strReagentLot = val;
}

void REAGENT_POS_INFO_T::__set_iReagentSerialNo(const int32_t val) {
  this->iReagentSerialNo = val;
}

void REAGENT_POS_INFO_T::__set_iReagentCategory(const int32_t val) {
  this->iReagentCategory = val;
}

void REAGENT_POS_INFO_T::__set_iRx(const int32_t val) {
  this->iRx = val;
}

void REAGENT_POS_INFO_T::__set_iBottleMaterial(const int32_t val) {
  this->iBottleMaterial = val;
}
std::ostream& operator<<(std::ostream& out, const REAGENT_POS_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t REAGENT_POS_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPosIndex);
          this->__isset.iPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsRemainDetect);
          this->__isset.iIsRemainDetect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iBottleType);
          this->__isset.iBottleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strReagentName);
          this->__isset.strReagentName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strReagentLot);
          this->__isset.strReagentLot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagentSerialNo);
          this->__isset.iReagentSerialNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagentCategory);
          this->__isset.iReagentCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iRx);
          this->__isset.iRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iBottleMaterial);
          this->__isset.iBottleMaterial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t REAGENT_POS_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("REAGENT_POS_INFO_T");

  xfer += oprot->writeFieldBegin("iPosIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsRemainDetect", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iIsRemainDetect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBottleType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iBottleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strReagentName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->strReagentName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strReagentLot", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->strReagentLot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentSerialNo", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iReagentSerialNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentCategory", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iReagentCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iRx", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBottleMaterial", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->iBottleMaterial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(REAGENT_POS_INFO_T &a, REAGENT_POS_INFO_T &b) {
  using ::std::swap;
  swap(a.iPosIndex, b.iPosIndex);
  swap(a.iIsRemainDetect, b.iIsRemainDetect);
  swap(a.iBottleType, b.iBottleType);
  swap(a.strReagentName, b.strReagentName);
  swap(a.strReagentLot, b.strReagentLot);
  swap(a.iReagentSerialNo, b.iReagentSerialNo);
  swap(a.iReagentCategory, b.iReagentCategory);
  swap(a.iRx, b.iRx);
  swap(a.iBottleMaterial, b.iBottleMaterial);
  swap(a.__isset, b.__isset);
}

REAGENT_POS_INFO_T::REAGENT_POS_INFO_T(const REAGENT_POS_INFO_T& other40) {
  iPosIndex = other40.iPosIndex;
  iIsRemainDetect = other40.iIsRemainDetect;
  iBottleType = other40.iBottleType;
  strReagentName = other40.strReagentName;
  strReagentLot = other40.strReagentLot;
  iReagentSerialNo = other40.iReagentSerialNo;
  iReagentCategory = other40.iReagentCategory;
  iRx = other40.iRx;
  iBottleMaterial = other40.iBottleMaterial;
  __isset = other40.__isset;
}
REAGENT_POS_INFO_T& REAGENT_POS_INFO_T::operator=(const REAGENT_POS_INFO_T& other41) {
  iPosIndex = other41.iPosIndex;
  iIsRemainDetect = other41.iIsRemainDetect;
  iBottleType = other41.iBottleType;
  strReagentName = other41.strReagentName;
  strReagentLot = other41.strReagentLot;
  iReagentSerialNo = other41.iReagentSerialNo;
  iReagentCategory = other41.iReagentCategory;
  iRx = other41.iRx;
  iBottleMaterial = other41.iBottleMaterial;
  __isset = other41.__isset;
  return *this;
}
void REAGENT_POS_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "REAGENT_POS_INFO_T(";
  out << "iPosIndex=" << to_string(iPosIndex);
  out << ", " << "iIsRemainDetect=" << to_string(iIsRemainDetect);
  out << ", " << "iBottleType=" << to_string(iBottleType);
  out << ", " << "strReagentName=" << to_string(strReagentName);
  out << ", " << "strReagentLot=" << to_string(strReagentLot);
  out << ", " << "iReagentSerialNo=" << to_string(iReagentSerialNo);
  out << ", " << "iReagentCategory=" << to_string(iReagentCategory);
  out << ", " << "iRx=" << to_string(iRx);
  out << ", " << "iBottleMaterial=" << to_string(iBottleMaterial);
  out << ")";
}


REAGENT_MIX_INFO_T::~REAGENT_MIX_INFO_T() throw() {
}


void REAGENT_MIX_INFO_T::__set_iPosIndex(const int32_t val) {
  this->iPosIndex = val;
}

void REAGENT_MIX_INFO_T::__set_iMixingType(const int32_t val) {
  this->iMixingType = val;
}

void REAGENT_MIX_INFO_T::__set_iBottleType(const int32_t val) {
  this->iBottleType = val;
}

void REAGENT_MIX_INFO_T::__set_strReagentName(const std::string& val) {
  this->strReagentName = val;
}

void REAGENT_MIX_INFO_T::__set_strReagentLot(const std::string& val) {
  this->strReagentLot = val;
}

void REAGENT_MIX_INFO_T::__set_iReagentSerialNo(const int32_t val) {
  this->iReagentSerialNo = val;
}

void REAGENT_MIX_INFO_T::__set_iReagentCategory(const int32_t val) {
  this->iReagentCategory = val;
}

void REAGENT_MIX_INFO_T::__set_iRx(const int32_t val) {
  this->iRx = val;
}
std::ostream& operator<<(std::ostream& out, const REAGENT_MIX_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t REAGENT_MIX_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPosIndex);
          this->__isset.iPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMixingType);
          this->__isset.iMixingType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iBottleType);
          this->__isset.iBottleType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strReagentName);
          this->__isset.strReagentName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strReagentLot);
          this->__isset.strReagentLot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagentSerialNo);
          this->__isset.iReagentSerialNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagentCategory);
          this->__isset.iReagentCategory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iRx);
          this->__isset.iRx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t REAGENT_MIX_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("REAGENT_MIX_INFO_T");

  xfer += oprot->writeFieldBegin("iPosIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMixingType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iMixingType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iBottleType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iBottleType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strReagentName", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->strReagentName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strReagentLot", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->strReagentLot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentSerialNo", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iReagentSerialNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentCategory", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iReagentCategory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iRx", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iRx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(REAGENT_MIX_INFO_T &a, REAGENT_MIX_INFO_T &b) {
  using ::std::swap;
  swap(a.iPosIndex, b.iPosIndex);
  swap(a.iMixingType, b.iMixingType);
  swap(a.iBottleType, b.iBottleType);
  swap(a.strReagentName, b.strReagentName);
  swap(a.strReagentLot, b.strReagentLot);
  swap(a.iReagentSerialNo, b.iReagentSerialNo);
  swap(a.iReagentCategory, b.iReagentCategory);
  swap(a.iRx, b.iRx);
  swap(a.__isset, b.__isset);
}

REAGENT_MIX_INFO_T::REAGENT_MIX_INFO_T(const REAGENT_MIX_INFO_T& other42) {
  iPosIndex = other42.iPosIndex;
  iMixingType = other42.iMixingType;
  iBottleType = other42.iBottleType;
  strReagentName = other42.strReagentName;
  strReagentLot = other42.strReagentLot;
  iReagentSerialNo = other42.iReagentSerialNo;
  iReagentCategory = other42.iReagentCategory;
  iRx = other42.iRx;
  __isset = other42.__isset;
}
REAGENT_MIX_INFO_T& REAGENT_MIX_INFO_T::operator=(const REAGENT_MIX_INFO_T& other43) {
  iPosIndex = other43.iPosIndex;
  iMixingType = other43.iMixingType;
  iBottleType = other43.iBottleType;
  strReagentName = other43.strReagentName;
  strReagentLot = other43.strReagentLot;
  iReagentSerialNo = other43.iReagentSerialNo;
  iReagentCategory = other43.iReagentCategory;
  iRx = other43.iRx;
  __isset = other43.__isset;
  return *this;
}
void REAGENT_MIX_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "REAGENT_MIX_INFO_T(";
  out << "iPosIndex=" << to_string(iPosIndex);
  out << ", " << "iMixingType=" << to_string(iMixingType);
  out << ", " << "iBottleType=" << to_string(iBottleType);
  out << ", " << "strReagentName=" << to_string(strReagentName);
  out << ", " << "strReagentLot=" << to_string(strReagentLot);
  out << ", " << "iReagentSerialNo=" << to_string(iReagentSerialNo);
  out << ", " << "iReagentCategory=" << to_string(iReagentCategory);
  out << ", " << "iRx=" << to_string(iRx);
  out << ")";
}


SAMPLE_TUBE_INFO_T::~SAMPLE_TUBE_INFO_T() throw() {
}


void SAMPLE_TUBE_INFO_T::__set_iSlotNo(const int32_t val) {
  this->iSlotNo = val;
}

void SAMPLE_TUBE_INFO_T::__set_iRackIndex(const int32_t val) {
  this->iRackIndex = val;
}

void SAMPLE_TUBE_INFO_T::__set_iPosIndex(const int32_t val) {
  this->iPosIndex = val;
}

void SAMPLE_TUBE_INFO_T::__set_bScanStatus(const IBOOL val) {
  this->bScanStatus = val;
}

void SAMPLE_TUBE_INFO_T::__set_bExist(const IBOOL val) {
  this->bExist = val;
}

void SAMPLE_TUBE_INFO_T::__set_barcode(const std::string& val) {
  this->barcode = val;
}

void SAMPLE_TUBE_INFO_T::__set_iTubeType(const int32_t val) {
  this->iTubeType = val;
}

void SAMPLE_TUBE_INFO_T::__set_iIsExistCap(const int32_t val) {
  this->iIsExistCap = val;
}
std::ostream& operator<<(std::ostream& out, const SAMPLE_TUBE_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SAMPLE_TUBE_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlotNo);
          this->__isset.iSlotNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iRackIndex);
          this->__isset.iRackIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPosIndex);
          this->__isset.iPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bScanStatus);
          this->__isset.bScanStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bExist);
          this->__isset.bExist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->barcode);
          this->__isset.barcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTubeType);
          this->__isset.iTubeType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsExistCap);
          this->__isset.iIsExistCap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SAMPLE_TUBE_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SAMPLE_TUBE_INFO_T");

  xfer += oprot->writeFieldBegin("iSlotNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSlotNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iRackIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iRackIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPosIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bScanStatus", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->bScanStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bExist", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->bExist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("barcode", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->barcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTubeType", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iTubeType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsExistCap", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iIsExistCap);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SAMPLE_TUBE_INFO_T &a, SAMPLE_TUBE_INFO_T &b) {
  using ::std::swap;
  swap(a.iSlotNo, b.iSlotNo);
  swap(a.iRackIndex, b.iRackIndex);
  swap(a.iPosIndex, b.iPosIndex);
  swap(a.bScanStatus, b.bScanStatus);
  swap(a.bExist, b.bExist);
  swap(a.barcode, b.barcode);
  swap(a.iTubeType, b.iTubeType);
  swap(a.iIsExistCap, b.iIsExistCap);
  swap(a.__isset, b.__isset);
}

SAMPLE_TUBE_INFO_T::SAMPLE_TUBE_INFO_T(const SAMPLE_TUBE_INFO_T& other44) {
  iSlotNo = other44.iSlotNo;
  iRackIndex = other44.iRackIndex;
  iPosIndex = other44.iPosIndex;
  bScanStatus = other44.bScanStatus;
  bExist = other44.bExist;
  barcode = other44.barcode;
  iTubeType = other44.iTubeType;
  iIsExistCap = other44.iIsExistCap;
  __isset = other44.__isset;
}
SAMPLE_TUBE_INFO_T& SAMPLE_TUBE_INFO_T::operator=(const SAMPLE_TUBE_INFO_T& other45) {
  iSlotNo = other45.iSlotNo;
  iRackIndex = other45.iRackIndex;
  iPosIndex = other45.iPosIndex;
  bScanStatus = other45.bScanStatus;
  bExist = other45.bExist;
  barcode = other45.barcode;
  iTubeType = other45.iTubeType;
  iIsExistCap = other45.iIsExistCap;
  __isset = other45.__isset;
  return *this;
}
void SAMPLE_TUBE_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SAMPLE_TUBE_INFO_T(";
  out << "iSlotNo=" << to_string(iSlotNo);
  out << ", " << "iRackIndex=" << to_string(iRackIndex);
  out << ", " << "iPosIndex=" << to_string(iPosIndex);
  out << ", " << "bScanStatus=" << to_string(bScanStatus);
  out << ", " << "bExist=" << to_string(bExist);
  out << ", " << "barcode=" << to_string(barcode);
  out << ", " << "iTubeType=" << to_string(iTubeType);
  out << ", " << "iIsExistCap=" << to_string(iIsExistCap);
  out << ")";
}


RESULT_INFO_T::~RESULT_INFO_T() throw() {
}


void RESULT_INFO_T::__set_eResultState(const RESULT_STATE::type val) {
  this->eResultState = val;
}

void RESULT_INFO_T::__set_iDetectPos(const int32_t val) {
  this->iDetectPos = val;
}

void RESULT_INFO_T::__set_iClotTime(const int32_t val) {
  this->iClotTime = val;
}

void RESULT_INFO_T::__set_lstADData(const std::vector<int32_t> & val) {
  this->lstADData = val;
}

void RESULT_INFO_T::__set_lstSubADData(const std::vector<int32_t> & val) {
  this->lstSubADData = val;
}

void RESULT_INFO_T::__set_strCupLotNo(const std::string& val) {
  this->strCupLotNo = val;
}

void RESULT_INFO_T::__set_iCupSerialNo(const int32_t val) {
  this->iCupSerialNo = val;
}
std::ostream& operator<<(std::ostream& out, const RESULT_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RESULT_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast46;
          xfer += iprot->readI32(ecast46);
          this->eResultState = (RESULT_STATE::type)ecast46;
          this->__isset.eResultState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDetectPos);
          this->__isset.iDetectPos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iClotTime);
          this->__isset.iClotTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstADData.clear();
            uint32_t _size47;
            ::apache::thrift::protocol::TType _etype50;
            xfer += iprot->readListBegin(_etype50, _size47);
            this->lstADData.resize(_size47);
            uint32_t _i51;
            for (_i51 = 0; _i51 < _size47; ++_i51)
            {
              xfer += iprot->readI32(this->lstADData[_i51]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstADData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstSubADData.clear();
            uint32_t _size52;
            ::apache::thrift::protocol::TType _etype55;
            xfer += iprot->readListBegin(_etype55, _size52);
            this->lstSubADData.resize(_size52);
            uint32_t _i56;
            for (_i56 = 0; _i56 < _size52; ++_i56)
            {
              xfer += iprot->readI32(this->lstSubADData[_i56]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstSubADData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strCupLotNo);
          this->__isset.strCupLotNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCupSerialNo);
          this->__isset.iCupSerialNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RESULT_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RESULT_INFO_T");

  xfer += oprot->writeFieldBegin("eResultState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->eResultState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDetectPos", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iDetectPos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iClotTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iClotTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstADData", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->lstADData.size()));
    std::vector<int32_t> ::const_iterator _iter57;
    for (_iter57 = this->lstADData.begin(); _iter57 != this->lstADData.end(); ++_iter57)
    {
      xfer += oprot->writeI32((*_iter57));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstSubADData", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->lstSubADData.size()));
    std::vector<int32_t> ::const_iterator _iter58;
    for (_iter58 = this->lstSubADData.begin(); _iter58 != this->lstSubADData.end(); ++_iter58)
    {
      xfer += oprot->writeI32((*_iter58));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strCupLotNo", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->strCupLotNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iCupSerialNo", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iCupSerialNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RESULT_INFO_T &a, RESULT_INFO_T &b) {
  using ::std::swap;
  swap(a.eResultState, b.eResultState);
  swap(a.iDetectPos, b.iDetectPos);
  swap(a.iClotTime, b.iClotTime);
  swap(a.lstADData, b.lstADData);
  swap(a.lstSubADData, b.lstSubADData);
  swap(a.strCupLotNo, b.strCupLotNo);
  swap(a.iCupSerialNo, b.iCupSerialNo);
  swap(a.__isset, b.__isset);
}

RESULT_INFO_T::RESULT_INFO_T(const RESULT_INFO_T& other59) {
  eResultState = other59.eResultState;
  iDetectPos = other59.iDetectPos;
  iClotTime = other59.iClotTime;
  lstADData = other59.lstADData;
  lstSubADData = other59.lstSubADData;
  strCupLotNo = other59.strCupLotNo;
  iCupSerialNo = other59.iCupSerialNo;
  __isset = other59.__isset;
}
RESULT_INFO_T& RESULT_INFO_T::operator=(const RESULT_INFO_T& other60) {
  eResultState = other60.eResultState;
  iDetectPos = other60.iDetectPos;
  iClotTime = other60.iClotTime;
  lstADData = other60.lstADData;
  lstSubADData = other60.lstSubADData;
  strCupLotNo = other60.strCupLotNo;
  iCupSerialNo = other60.iCupSerialNo;
  __isset = other60.__isset;
  return *this;
}
void RESULT_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RESULT_INFO_T(";
  out << "eResultState=" << to_string(eResultState);
  out << ", " << "iDetectPos=" << to_string(iDetectPos);
  out << ", " << "iClotTime=" << to_string(iClotTime);
  out << ", " << "lstADData=" << to_string(lstADData);
  out << ", " << "lstSubADData=" << to_string(lstSubADData);
  out << ", " << "strCupLotNo=" << to_string(strCupLotNo);
  out << ", " << "iCupSerialNo=" << to_string(iCupSerialNo);
  out << ")";
}


ASYNC_RETURN_T::~ASYNC_RETURN_T() throw() {
}


void ASYNC_RETURN_T::__set_iReturnType(const int32_t val) {
  this->iReturnType = val;
}

void ASYNC_RETURN_T::__set_iReturn(const int32_t val) {
  this->iReturn = val;
}

void ASYNC_RETURN_T::__set_dReturn(const double val) {
  this->dReturn = val;
}

void ASYNC_RETURN_T::__set_strReturn(const std::string& val) {
  this->strReturn = val;
}
std::ostream& operator<<(std::ostream& out, const ASYNC_RETURN_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ASYNC_RETURN_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReturnType);
          this->__isset.iReturnType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReturn);
          this->__isset.iReturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dReturn);
          this->__isset.dReturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strReturn);
          this->__isset.strReturn = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ASYNC_RETURN_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ASYNC_RETURN_T");

  xfer += oprot->writeFieldBegin("iReturnType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iReturnType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReturn", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iReturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dReturn", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dReturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strReturn", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->strReturn);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ASYNC_RETURN_T &a, ASYNC_RETURN_T &b) {
  using ::std::swap;
  swap(a.iReturnType, b.iReturnType);
  swap(a.iReturn, b.iReturn);
  swap(a.dReturn, b.dReturn);
  swap(a.strReturn, b.strReturn);
  swap(a.__isset, b.__isset);
}

ASYNC_RETURN_T::ASYNC_RETURN_T(const ASYNC_RETURN_T& other61) {
  iReturnType = other61.iReturnType;
  iReturn = other61.iReturn;
  dReturn = other61.dReturn;
  strReturn = other61.strReturn;
  __isset = other61.__isset;
}
ASYNC_RETURN_T& ASYNC_RETURN_T::operator=(const ASYNC_RETURN_T& other62) {
  iReturnType = other62.iReturnType;
  iReturn = other62.iReturn;
  dReturn = other62.dReturn;
  strReturn = other62.strReturn;
  __isset = other62.__isset;
  return *this;
}
void ASYNC_RETURN_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ASYNC_RETURN_T(";
  out << "iReturnType=" << to_string(iReturnType);
  out << ", " << "iReturn=" << to_string(iReturn);
  out << ", " << "dReturn=" << to_string(dReturn);
  out << ", " << "strReturn=" << to_string(strReturn);
  out << ")";
}


THRIFT_MOTOR_PARA_T::~THRIFT_MOTOR_PARA_T() throw() {
}


void THRIFT_MOTOR_PARA_T::__set_iMotorID(const int32_t val) {
  this->iMotorID = val;
}

void THRIFT_MOTOR_PARA_T::__set_iSpeed(const int32_t val) {
  this->iSpeed = val;
}

void THRIFT_MOTOR_PARA_T::__set_iAcc(const int32_t val) {
  this->iAcc = val;
}
std::ostream& operator<<(std::ostream& out, const THRIFT_MOTOR_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRIFT_MOTOR_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMotorID);
          this->__isset.iMotorID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSpeed);
          this->__isset.iSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iAcc);
          this->__isset.iAcc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THRIFT_MOTOR_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRIFT_MOTOR_PARA_T");

  xfer += oprot->writeFieldBegin("iMotorID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iMotorID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSpeed", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iAcc", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iAcc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRIFT_MOTOR_PARA_T &a, THRIFT_MOTOR_PARA_T &b) {
  using ::std::swap;
  swap(a.iMotorID, b.iMotorID);
  swap(a.iSpeed, b.iSpeed);
  swap(a.iAcc, b.iAcc);
  swap(a.__isset, b.__isset);
}

THRIFT_MOTOR_PARA_T::THRIFT_MOTOR_PARA_T(const THRIFT_MOTOR_PARA_T& other63) {
  iMotorID = other63.iMotorID;
  iSpeed = other63.iSpeed;
  iAcc = other63.iAcc;
  __isset = other63.__isset;
}
THRIFT_MOTOR_PARA_T& THRIFT_MOTOR_PARA_T::operator=(const THRIFT_MOTOR_PARA_T& other64) {
  iMotorID = other64.iMotorID;
  iSpeed = other64.iSpeed;
  iAcc = other64.iAcc;
  __isset = other64.__isset;
  return *this;
}
void THRIFT_MOTOR_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRIFT_MOTOR_PARA_T(";
  out << "iMotorID=" << to_string(iMotorID);
  out << ", " << "iSpeed=" << to_string(iSpeed);
  out << ", " << "iAcc=" << to_string(iAcc);
  out << ")";
}


DATE_TIME_T::~DATE_TIME_T() throw() {
}


void DATE_TIME_T::__set_iYear(const int32_t val) {
  this->iYear = val;
}

void DATE_TIME_T::__set_iMonth(const int32_t val) {
  this->iMonth = val;
}

void DATE_TIME_T::__set_iDayOfWeek(const int32_t val) {
  this->iDayOfWeek = val;
}

void DATE_TIME_T::__set_iDay(const int32_t val) {
  this->iDay = val;
}

void DATE_TIME_T::__set_iHour(const int32_t val) {
  this->iHour = val;
}

void DATE_TIME_T::__set_iMinute(const int32_t val) {
  this->iMinute = val;
}

void DATE_TIME_T::__set_iSecond(const int32_t val) {
  this->iSecond = val;
}
std::ostream& operator<<(std::ostream& out, const DATE_TIME_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DATE_TIME_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iYear);
          this->__isset.iYear = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMonth);
          this->__isset.iMonth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDayOfWeek);
          this->__isset.iDayOfWeek = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDay);
          this->__isset.iDay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHour);
          this->__isset.iHour = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMinute);
          this->__isset.iMinute = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSecond);
          this->__isset.iSecond = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DATE_TIME_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DATE_TIME_T");

  xfer += oprot->writeFieldBegin("iYear", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iYear);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMonth", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iMonth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDayOfWeek", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iDayOfWeek);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDay", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iDay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHour", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iHour);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iMinute", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iMinute);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSecond", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iSecond);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DATE_TIME_T &a, DATE_TIME_T &b) {
  using ::std::swap;
  swap(a.iYear, b.iYear);
  swap(a.iMonth, b.iMonth);
  swap(a.iDayOfWeek, b.iDayOfWeek);
  swap(a.iDay, b.iDay);
  swap(a.iHour, b.iHour);
  swap(a.iMinute, b.iMinute);
  swap(a.iSecond, b.iSecond);
  swap(a.__isset, b.__isset);
}

DATE_TIME_T::DATE_TIME_T(const DATE_TIME_T& other65) {
  iYear = other65.iYear;
  iMonth = other65.iMonth;
  iDayOfWeek = other65.iDayOfWeek;
  iDay = other65.iDay;
  iHour = other65.iHour;
  iMinute = other65.iMinute;
  iSecond = other65.iSecond;
  __isset = other65.__isset;
}
DATE_TIME_T& DATE_TIME_T::operator=(const DATE_TIME_T& other66) {
  iYear = other66.iYear;
  iMonth = other66.iMonth;
  iDayOfWeek = other66.iDayOfWeek;
  iDay = other66.iDay;
  iHour = other66.iHour;
  iMinute = other66.iMinute;
  iSecond = other66.iSecond;
  __isset = other66.__isset;
  return *this;
}
void DATE_TIME_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DATE_TIME_T(";
  out << "iYear=" << to_string(iYear);
  out << ", " << "iMonth=" << to_string(iMonth);
  out << ", " << "iDayOfWeek=" << to_string(iDayOfWeek);
  out << ", " << "iDay=" << to_string(iDay);
  out << ", " << "iHour=" << to_string(iHour);
  out << ", " << "iMinute=" << to_string(iMinute);
  out << ", " << "iSecond=" << to_string(iSecond);
  out << ")";
}


CONSUMABLES_INFO_T::~CONSUMABLES_INFO_T() throw() {
}


void CONSUMABLES_INFO_T::__set_iConsumableType(const REAGENT_SUPPLY_TYPE::type val) {
  this->iConsumableType = val;
}

void CONSUMABLES_INFO_T::__set_iEnable(const int32_t val) {
  this->iEnable = val;
}

void CONSUMABLES_INFO_T::__set_iIndex(const int32_t val) {
  this->iIndex = val;
}

void CONSUMABLES_INFO_T::__set_iPriorityOfUse(const int32_t val) {
  this->iPriorityOfUse = val;
}

void CONSUMABLES_INFO_T::__set_strLotNo(const std::string& val) {
  this->strLotNo = val;
}

void CONSUMABLES_INFO_T::__set_iSerialNo(const int32_t val) {
  this->iSerialNo = val;
}

void CONSUMABLES_INFO_T::__set_bInit(const IBOOL val) {
  this->bInit = val;
}
std::ostream& operator<<(std::ostream& out, const CONSUMABLES_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CONSUMABLES_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->iConsumableType = (REAGENT_SUPPLY_TYPE::type)ecast67;
          this->__isset.iConsumableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iEnable);
          this->__isset.iEnable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIndex);
          this->__isset.iIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPriorityOfUse);
          this->__isset.iPriorityOfUse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strLotNo);
          this->__isset.strLotNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSerialNo);
          this->__isset.iSerialNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bInit);
          this->__isset.bInit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CONSUMABLES_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CONSUMABLES_INFO_T");

  xfer += oprot->writeFieldBegin("iConsumableType", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->iConsumableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iEnable", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iEnable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPriorityOfUse", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iPriorityOfUse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strLotNo", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->strLotNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSerialNo", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iSerialNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bInit", ::apache::thrift::protocol::T_BOOL, 7);
  xfer += oprot->writeBool(this->bInit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CONSUMABLES_INFO_T &a, CONSUMABLES_INFO_T &b) {
  using ::std::swap;
  swap(a.iConsumableType, b.iConsumableType);
  swap(a.iEnable, b.iEnable);
  swap(a.iIndex, b.iIndex);
  swap(a.iPriorityOfUse, b.iPriorityOfUse);
  swap(a.strLotNo, b.strLotNo);
  swap(a.iSerialNo, b.iSerialNo);
  swap(a.bInit, b.bInit);
  swap(a.__isset, b.__isset);
}

CONSUMABLES_INFO_T::CONSUMABLES_INFO_T(const CONSUMABLES_INFO_T& other68) {
  iConsumableType = other68.iConsumableType;
  iEnable = other68.iEnable;
  iIndex = other68.iIndex;
  iPriorityOfUse = other68.iPriorityOfUse;
  strLotNo = other68.strLotNo;
  iSerialNo = other68.iSerialNo;
  bInit = other68.bInit;
  __isset = other68.__isset;
}
CONSUMABLES_INFO_T& CONSUMABLES_INFO_T::operator=(const CONSUMABLES_INFO_T& other69) {
  iConsumableType = other69.iConsumableType;
  iEnable = other69.iEnable;
  iIndex = other69.iIndex;
  iPriorityOfUse = other69.iPriorityOfUse;
  strLotNo = other69.strLotNo;
  iSerialNo = other69.iSerialNo;
  bInit = other69.bInit;
  __isset = other69.__isset;
  return *this;
}
void CONSUMABLES_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CONSUMABLES_INFO_T(";
  out << "iConsumableType=" << to_string(iConsumableType);
  out << ", " << "iEnable=" << to_string(iEnable);
  out << ", " << "iIndex=" << to_string(iIndex);
  out << ", " << "iPriorityOfUse=" << to_string(iPriorityOfUse);
  out << ", " << "strLotNo=" << to_string(strLotNo);
  out << ", " << "iSerialNo=" << to_string(iSerialNo);
  out << ", " << "bInit=" << to_string(bInit);
  out << ")";
}


REAGENT_SCAN_INFO_T::~REAGENT_SCAN_INFO_T() throw() {
}


void REAGENT_SCAN_INFO_T::__set_iReagBracketIndex(const int32_t val) {
  this->iReagBracketIndex = val;
}

void REAGENT_SCAN_INFO_T::__set_iIsReagBracketExist(const int32_t val) {
  this->iIsReagBracketExist = val;
}

void REAGENT_SCAN_INFO_T::__set_iReagPosIndex(const int32_t val) {
  this->iReagPosIndex = val;
}

void REAGENT_SCAN_INFO_T::__set_iExistStatus(const int32_t val) {
  this->iExistStatus = val;
}

void REAGENT_SCAN_INFO_T::__set_strBarcode(const std::string& val) {
  this->strBarcode = val;
}
std::ostream& operator<<(std::ostream& out, const REAGENT_SCAN_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t REAGENT_SCAN_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagBracketIndex);
          this->__isset.iReagBracketIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsReagBracketExist);
          this->__isset.iIsReagBracketExist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagPosIndex);
          this->__isset.iReagPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iExistStatus);
          this->__isset.iExistStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strBarcode);
          this->__isset.strBarcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t REAGENT_SCAN_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("REAGENT_SCAN_INFO_T");

  xfer += oprot->writeFieldBegin("iReagBracketIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iReagBracketIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsReagBracketExist", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iIsReagBracketExist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagPosIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iReagPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iExistStatus", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iExistStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strBarcode", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->strBarcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(REAGENT_SCAN_INFO_T &a, REAGENT_SCAN_INFO_T &b) {
  using ::std::swap;
  swap(a.iReagBracketIndex, b.iReagBracketIndex);
  swap(a.iIsReagBracketExist, b.iIsReagBracketExist);
  swap(a.iReagPosIndex, b.iReagPosIndex);
  swap(a.iExistStatus, b.iExistStatus);
  swap(a.strBarcode, b.strBarcode);
  swap(a.__isset, b.__isset);
}

REAGENT_SCAN_INFO_T::REAGENT_SCAN_INFO_T(const REAGENT_SCAN_INFO_T& other70) {
  iReagBracketIndex = other70.iReagBracketIndex;
  iIsReagBracketExist = other70.iIsReagBracketExist;
  iReagPosIndex = other70.iReagPosIndex;
  iExistStatus = other70.iExistStatus;
  strBarcode = other70.strBarcode;
  __isset = other70.__isset;
}
REAGENT_SCAN_INFO_T& REAGENT_SCAN_INFO_T::operator=(const REAGENT_SCAN_INFO_T& other71) {
  iReagBracketIndex = other71.iReagBracketIndex;
  iIsReagBracketExist = other71.iIsReagBracketExist;
  iReagPosIndex = other71.iReagPosIndex;
  iExistStatus = other71.iExistStatus;
  strBarcode = other71.strBarcode;
  __isset = other71.__isset;
  return *this;
}
void REAGENT_SCAN_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "REAGENT_SCAN_INFO_T(";
  out << "iReagBracketIndex=" << to_string(iReagBracketIndex);
  out << ", " << "iIsReagBracketExist=" << to_string(iIsReagBracketExist);
  out << ", " << "iReagPosIndex=" << to_string(iReagPosIndex);
  out << ", " << "iExistStatus=" << to_string(iExistStatus);
  out << ", " << "strBarcode=" << to_string(strBarcode);
  out << ")";
}


ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::~ENGINEER_DEBUG_VIRTUAL_POS_PARA_T() throw() {
}


void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iModuleIndex(const int32_t val) {
  this->iModuleIndex = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iVirtualPosIndex(const int32_t val) {
  this->iVirtualPosIndex = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_strVirtualPosName(const std::string& val) {
  this->strVirtualPosName = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iEnableR(const int32_t val) {
  this->iEnableR = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iR_Steps(const int32_t val) {
  this->iR_Steps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iR_MaxSteps(const int32_t val) {
  this->iR_MaxSteps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iEnableX(const int32_t val) {
  this->iEnableX = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iX_Steps(const int32_t val) {
  this->iX_Steps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iX_MaxSteps(const int32_t val) {
  this->iX_MaxSteps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iEnableY(const int32_t val) {
  this->iEnableY = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iY_Steps(const int32_t val) {
  this->iY_Steps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iY_MaxSteps(const int32_t val) {
  this->iY_MaxSteps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iEnableZ(const int32_t val) {
  this->iEnableZ = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iZ_Steps(const int32_t val) {
  this->iZ_Steps = val;
}

void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::__set_iZ_MaxSteps(const int32_t val) {
  this->iZ_MaxSteps = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iModuleIndex);
          this->__isset.iModuleIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVirtualPosIndex);
          this->__isset.iVirtualPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strVirtualPosName);
          this->__isset.strVirtualPosName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iEnableR);
          this->__isset.iEnableR = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iR_Steps);
          this->__isset.iR_Steps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iR_MaxSteps);
          this->__isset.iR_MaxSteps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iEnableX);
          this->__isset.iEnableX = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iX_Steps);
          this->__isset.iX_Steps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iX_MaxSteps);
          this->__isset.iX_MaxSteps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iEnableY);
          this->__isset.iEnableY = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iY_Steps);
          this->__isset.iY_Steps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iY_MaxSteps);
          this->__isset.iY_MaxSteps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iEnableZ);
          this->__isset.iEnableZ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iZ_Steps);
          this->__isset.iZ_Steps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iZ_MaxSteps);
          this->__isset.iZ_MaxSteps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_VIRTUAL_POS_PARA_T");

  xfer += oprot->writeFieldBegin("iModuleIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iModuleIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVirtualPosIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iVirtualPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strVirtualPosName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->strVirtualPosName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iEnableR", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iEnableR);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iR_Steps", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iR_Steps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iR_MaxSteps", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iR_MaxSteps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iEnableX", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iEnableX);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iX_Steps", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iX_Steps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iX_MaxSteps", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->iX_MaxSteps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iEnableY", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->iEnableY);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iY_Steps", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->iY_Steps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iY_MaxSteps", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->iY_MaxSteps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iEnableZ", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->iEnableZ);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iZ_Steps", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->iZ_Steps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iZ_MaxSteps", ::apache::thrift::protocol::T_I32, 15);
  xfer += oprot->writeI32(this->iZ_MaxSteps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_VIRTUAL_POS_PARA_T &a, ENGINEER_DEBUG_VIRTUAL_POS_PARA_T &b) {
  using ::std::swap;
  swap(a.iModuleIndex, b.iModuleIndex);
  swap(a.iVirtualPosIndex, b.iVirtualPosIndex);
  swap(a.strVirtualPosName, b.strVirtualPosName);
  swap(a.iEnableR, b.iEnableR);
  swap(a.iR_Steps, b.iR_Steps);
  swap(a.iR_MaxSteps, b.iR_MaxSteps);
  swap(a.iEnableX, b.iEnableX);
  swap(a.iX_Steps, b.iX_Steps);
  swap(a.iX_MaxSteps, b.iX_MaxSteps);
  swap(a.iEnableY, b.iEnableY);
  swap(a.iY_Steps, b.iY_Steps);
  swap(a.iY_MaxSteps, b.iY_MaxSteps);
  swap(a.iEnableZ, b.iEnableZ);
  swap(a.iZ_Steps, b.iZ_Steps);
  swap(a.iZ_MaxSteps, b.iZ_MaxSteps);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::ENGINEER_DEBUG_VIRTUAL_POS_PARA_T(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& other72) {
  iModuleIndex = other72.iModuleIndex;
  iVirtualPosIndex = other72.iVirtualPosIndex;
  strVirtualPosName = other72.strVirtualPosName;
  iEnableR = other72.iEnableR;
  iR_Steps = other72.iR_Steps;
  iR_MaxSteps = other72.iR_MaxSteps;
  iEnableX = other72.iEnableX;
  iX_Steps = other72.iX_Steps;
  iX_MaxSteps = other72.iX_MaxSteps;
  iEnableY = other72.iEnableY;
  iY_Steps = other72.iY_Steps;
  iY_MaxSteps = other72.iY_MaxSteps;
  iEnableZ = other72.iEnableZ;
  iZ_Steps = other72.iZ_Steps;
  iZ_MaxSteps = other72.iZ_MaxSteps;
  __isset = other72.__isset;
}
ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::operator=(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& other73) {
  iModuleIndex = other73.iModuleIndex;
  iVirtualPosIndex = other73.iVirtualPosIndex;
  strVirtualPosName = other73.strVirtualPosName;
  iEnableR = other73.iEnableR;
  iR_Steps = other73.iR_Steps;
  iR_MaxSteps = other73.iR_MaxSteps;
  iEnableX = other73.iEnableX;
  iX_Steps = other73.iX_Steps;
  iX_MaxSteps = other73.iX_MaxSteps;
  iEnableY = other73.iEnableY;
  iY_Steps = other73.iY_Steps;
  iY_MaxSteps = other73.iY_MaxSteps;
  iEnableZ = other73.iEnableZ;
  iZ_Steps = other73.iZ_Steps;
  iZ_MaxSteps = other73.iZ_MaxSteps;
  __isset = other73.__isset;
  return *this;
}
void ENGINEER_DEBUG_VIRTUAL_POS_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_VIRTUAL_POS_PARA_T(";
  out << "iModuleIndex=" << to_string(iModuleIndex);
  out << ", " << "iVirtualPosIndex=" << to_string(iVirtualPosIndex);
  out << ", " << "strVirtualPosName=" << to_string(strVirtualPosName);
  out << ", " << "iEnableR=" << to_string(iEnableR);
  out << ", " << "iR_Steps=" << to_string(iR_Steps);
  out << ", " << "iR_MaxSteps=" << to_string(iR_MaxSteps);
  out << ", " << "iEnableX=" << to_string(iEnableX);
  out << ", " << "iX_Steps=" << to_string(iX_Steps);
  out << ", " << "iX_MaxSteps=" << to_string(iX_MaxSteps);
  out << ", " << "iEnableY=" << to_string(iEnableY);
  out << ", " << "iY_Steps=" << to_string(iY_Steps);
  out << ", " << "iY_MaxSteps=" << to_string(iY_MaxSteps);
  out << ", " << "iEnableZ=" << to_string(iEnableZ);
  out << ", " << "iZ_Steps=" << to_string(iZ_Steps);
  out << ", " << "iZ_MaxSteps=" << to_string(iZ_MaxSteps);
  out << ")";
}


ENGINEER_DEBUG_VIRTUAL_POSITION_T::~ENGINEER_DEBUG_VIRTUAL_POSITION_T() throw() {
}


void ENGINEER_DEBUG_VIRTUAL_POSITION_T::__set_tOldVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val) {
  this->tOldVirautlPosPara = val;
}

void ENGINEER_DEBUG_VIRTUAL_POSITION_T::__set_tCurVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val) {
  this->tCurVirautlPosPara = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_VIRTUAL_POSITION_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_VIRTUAL_POSITION_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tOldVirautlPosPara.read(iprot);
          this->__isset.tOldVirautlPosPara = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tCurVirautlPosPara.read(iprot);
          this->__isset.tCurVirautlPosPara = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_VIRTUAL_POSITION_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_VIRTUAL_POSITION_T");

  xfer += oprot->writeFieldBegin("tOldVirautlPosPara", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tOldVirautlPosPara.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tCurVirautlPosPara", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tCurVirautlPosPara.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_VIRTUAL_POSITION_T &a, ENGINEER_DEBUG_VIRTUAL_POSITION_T &b) {
  using ::std::swap;
  swap(a.tOldVirautlPosPara, b.tOldVirautlPosPara);
  swap(a.tCurVirautlPosPara, b.tCurVirautlPosPara);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_VIRTUAL_POSITION_T::ENGINEER_DEBUG_VIRTUAL_POSITION_T(const ENGINEER_DEBUG_VIRTUAL_POSITION_T& other74) {
  tOldVirautlPosPara = other74.tOldVirautlPosPara;
  tCurVirautlPosPara = other74.tCurVirautlPosPara;
  __isset = other74.__isset;
}
ENGINEER_DEBUG_VIRTUAL_POSITION_T& ENGINEER_DEBUG_VIRTUAL_POSITION_T::operator=(const ENGINEER_DEBUG_VIRTUAL_POSITION_T& other75) {
  tOldVirautlPosPara = other75.tOldVirautlPosPara;
  tCurVirautlPosPara = other75.tCurVirautlPosPara;
  __isset = other75.__isset;
  return *this;
}
void ENGINEER_DEBUG_VIRTUAL_POSITION_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_VIRTUAL_POSITION_T(";
  out << "tOldVirautlPosPara=" << to_string(tOldVirautlPosPara);
  out << ", " << "tCurVirautlPosPara=" << to_string(tCurVirautlPosPara);
  out << ")";
}


ENGINEER_DEBUG_MODULE_PARA_T::~ENGINEER_DEBUG_MODULE_PARA_T() throw() {
}


void ENGINEER_DEBUG_MODULE_PARA_T::__set_tVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val) {
  this->tVirautlPosPara = val;
}

void ENGINEER_DEBUG_MODULE_PARA_T::__set_iIsExistRelativeViraultPosPara(const int32_t val) {
  this->iIsExistRelativeViraultPosPara = val;
}

void ENGINEER_DEBUG_MODULE_PARA_T::__set_tRelativeVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val) {
  this->tRelativeVirautlPosPara = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MODULE_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_MODULE_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tVirautlPosPara.read(iprot);
          this->__isset.tVirautlPosPara = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsExistRelativeViraultPosPara);
          this->__isset.iIsExistRelativeViraultPosPara = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tRelativeVirautlPosPara.read(iprot);
          this->__isset.tRelativeVirautlPosPara = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_MODULE_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_MODULE_PARA_T");

  xfer += oprot->writeFieldBegin("tVirautlPosPara", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tVirautlPosPara.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsExistRelativeViraultPosPara", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iIsExistRelativeViraultPosPara);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tRelativeVirautlPosPara", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tRelativeVirautlPosPara.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_MODULE_PARA_T &a, ENGINEER_DEBUG_MODULE_PARA_T &b) {
  using ::std::swap;
  swap(a.tVirautlPosPara, b.tVirautlPosPara);
  swap(a.iIsExistRelativeViraultPosPara, b.iIsExistRelativeViraultPosPara);
  swap(a.tRelativeVirautlPosPara, b.tRelativeVirautlPosPara);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_MODULE_PARA_T::ENGINEER_DEBUG_MODULE_PARA_T(const ENGINEER_DEBUG_MODULE_PARA_T& other76) {
  tVirautlPosPara = other76.tVirautlPosPara;
  iIsExistRelativeViraultPosPara = other76.iIsExistRelativeViraultPosPara;
  tRelativeVirautlPosPara = other76.tRelativeVirautlPosPara;
  __isset = other76.__isset;
}
ENGINEER_DEBUG_MODULE_PARA_T& ENGINEER_DEBUG_MODULE_PARA_T::operator=(const ENGINEER_DEBUG_MODULE_PARA_T& other77) {
  tVirautlPosPara = other77.tVirautlPosPara;
  iIsExistRelativeViraultPosPara = other77.iIsExistRelativeViraultPosPara;
  tRelativeVirautlPosPara = other77.tRelativeVirautlPosPara;
  __isset = other77.__isset;
  return *this;
}
void ENGINEER_DEBUG_MODULE_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_MODULE_PARA_T(";
  out << "tVirautlPosPara=" << to_string(tVirautlPosPara);
  out << ", " << "iIsExistRelativeViraultPosPara=" << to_string(iIsExistRelativeViraultPosPara);
  out << ", " << "tRelativeVirautlPosPara=" << to_string(tRelativeVirautlPosPara);
  out << ")";
}


ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::~ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T() throw() {
}


void ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::__set_iMotorOrIOIndex(const int32_t val) {
  this->iMotorOrIOIndex = val;
}

void ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::__set_iOnOrOff(const int32_t val) {
  this->iOnOrOff = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iMotorOrIOIndex);
          this->__isset.iMotorOrIOIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOnOrOff);
          this->__isset.iOnOrOff = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T");

  xfer += oprot->writeFieldBegin("iMotorOrIOIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iMotorOrIOIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iOnOrOff", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iOnOrOff);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T &a, ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T &b) {
  using ::std::swap;
  swap(a.iMotorOrIOIndex, b.iMotorOrIOIndex);
  swap(a.iOnOrOff, b.iOnOrOff);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T(const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& other78) {
  iMotorOrIOIndex = other78.iMotorOrIOIndex;
  iOnOrOff = other78.iOnOrOff;
  __isset = other78.__isset;
}
ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::operator=(const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& other79) {
  iMotorOrIOIndex = other79.iMotorOrIOIndex;
  iOnOrOff = other79.iOnOrOff;
  __isset = other79.__isset;
  return *this;
}
void ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T(";
  out << "iMotorOrIOIndex=" << to_string(iMotorOrIOIndex);
  out << ", " << "iOnOrOff=" << to_string(iOnOrOff);
  out << ")";
}


ENGINEER_DEBUG_MOTOR_PARA_T::~ENGINEER_DEBUG_MOTOR_PARA_T() throw() {
}


void ENGINEER_DEBUG_MOTOR_PARA_T::__set_iModuleIndex(const int32_t val) {
  this->iModuleIndex = val;
}

void ENGINEER_DEBUG_MOTOR_PARA_T::__set_iVirtualPosIndex(const int32_t val) {
  this->iVirtualPosIndex = val;
}

void ENGINEER_DEBUG_MOTOR_PARA_T::__set_eAxisType(const ENGINEER_DEBUG_AXIS_TYPE::type val) {
  this->eAxisType = val;
}

void ENGINEER_DEBUG_MOTOR_PARA_T::__set_eActionType(const ENGINEER_DEBUG_ACTION_TYPE::type val) {
  this->eActionType = val;
}

void ENGINEER_DEBUG_MOTOR_PARA_T::__set_iSteps(const int32_t val) {
  this->iSteps = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MOTOR_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_MOTOR_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iModuleIndex);
          this->__isset.iModuleIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iVirtualPosIndex);
          this->__isset.iVirtualPosIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast80;
          xfer += iprot->readI32(ecast80);
          this->eAxisType = (ENGINEER_DEBUG_AXIS_TYPE::type)ecast80;
          this->__isset.eAxisType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast81;
          xfer += iprot->readI32(ecast81);
          this->eActionType = (ENGINEER_DEBUG_ACTION_TYPE::type)ecast81;
          this->__isset.eActionType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSteps);
          this->__isset.iSteps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_MOTOR_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_MOTOR_PARA_T");

  xfer += oprot->writeFieldBegin("iModuleIndex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iModuleIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iVirtualPosIndex", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iVirtualPosIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eAxisType", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->eAxisType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("eActionType", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((int32_t)this->eActionType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSteps", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iSteps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_MOTOR_PARA_T &a, ENGINEER_DEBUG_MOTOR_PARA_T &b) {
  using ::std::swap;
  swap(a.iModuleIndex, b.iModuleIndex);
  swap(a.iVirtualPosIndex, b.iVirtualPosIndex);
  swap(a.eAxisType, b.eAxisType);
  swap(a.eActionType, b.eActionType);
  swap(a.iSteps, b.iSteps);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_MOTOR_PARA_T::ENGINEER_DEBUG_MOTOR_PARA_T(const ENGINEER_DEBUG_MOTOR_PARA_T& other82) {
  iModuleIndex = other82.iModuleIndex;
  iVirtualPosIndex = other82.iVirtualPosIndex;
  eAxisType = other82.eAxisType;
  eActionType = other82.eActionType;
  iSteps = other82.iSteps;
  __isset = other82.__isset;
}
ENGINEER_DEBUG_MOTOR_PARA_T& ENGINEER_DEBUG_MOTOR_PARA_T::operator=(const ENGINEER_DEBUG_MOTOR_PARA_T& other83) {
  iModuleIndex = other83.iModuleIndex;
  iVirtualPosIndex = other83.iVirtualPosIndex;
  eAxisType = other83.eAxisType;
  eActionType = other83.eActionType;
  iSteps = other83.iSteps;
  __isset = other83.__isset;
  return *this;
}
void ENGINEER_DEBUG_MOTOR_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_MOTOR_PARA_T(";
  out << "iModuleIndex=" << to_string(iModuleIndex);
  out << ", " << "iVirtualPosIndex=" << to_string(iVirtualPosIndex);
  out << ", " << "eAxisType=" << to_string(eAxisType);
  out << ", " << "eActionType=" << to_string(eActionType);
  out << ", " << "iSteps=" << to_string(iSteps);
  out << ")";
}


ASSAY_GROUP_TESTS_T::~ASSAY_GROUP_TESTS_T() throw() {
}


void ASSAY_GROUP_TESTS_T::__set_iAssayGroupID(const int32_t val) {
  this->iAssayGroupID = val;
}

void ASSAY_GROUP_TESTS_T::__set_iAssayGroupHostID(const int32_t val) {
  this->iAssayGroupHostID = val;
}

void ASSAY_GROUP_TESTS_T::__set_strAssayGroupName(const std::string& val) {
  this->strAssayGroupName = val;
}

void ASSAY_GROUP_TESTS_T::__set_iTests(const int32_t val) {
  this->iTests = val;
}
std::ostream& operator<<(std::ostream& out, const ASSAY_GROUP_TESTS_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ASSAY_GROUP_TESTS_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iAssayGroupID);
          this->__isset.iAssayGroupID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iAssayGroupHostID);
          this->__isset.iAssayGroupHostID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strAssayGroupName);
          this->__isset.strAssayGroupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTests);
          this->__isset.iTests = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ASSAY_GROUP_TESTS_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ASSAY_GROUP_TESTS_T");

  xfer += oprot->writeFieldBegin("iAssayGroupID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iAssayGroupID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iAssayGroupHostID", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iAssayGroupHostID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strAssayGroupName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->strAssayGroupName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTests", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iTests);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ASSAY_GROUP_TESTS_T &a, ASSAY_GROUP_TESTS_T &b) {
  using ::std::swap;
  swap(a.iAssayGroupID, b.iAssayGroupID);
  swap(a.iAssayGroupHostID, b.iAssayGroupHostID);
  swap(a.strAssayGroupName, b.strAssayGroupName);
  swap(a.iTests, b.iTests);
  swap(a.__isset, b.__isset);
}

ASSAY_GROUP_TESTS_T::ASSAY_GROUP_TESTS_T(const ASSAY_GROUP_TESTS_T& other84) {
  iAssayGroupID = other84.iAssayGroupID;
  iAssayGroupHostID = other84.iAssayGroupHostID;
  strAssayGroupName = other84.strAssayGroupName;
  iTests = other84.iTests;
  __isset = other84.__isset;
}
ASSAY_GROUP_TESTS_T& ASSAY_GROUP_TESTS_T::operator=(const ASSAY_GROUP_TESTS_T& other85) {
  iAssayGroupID = other85.iAssayGroupID;
  iAssayGroupHostID = other85.iAssayGroupHostID;
  strAssayGroupName = other85.strAssayGroupName;
  iTests = other85.iTests;
  __isset = other85.__isset;
  return *this;
}
void ASSAY_GROUP_TESTS_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ASSAY_GROUP_TESTS_T(";
  out << "iAssayGroupID=" << to_string(iAssayGroupID);
  out << ", " << "iAssayGroupHostID=" << to_string(iAssayGroupHostID);
  out << ", " << "strAssayGroupName=" << to_string(strAssayGroupName);
  out << ", " << "iTests=" << to_string(iTests);
  out << ")";
}


ENGINEER_DEBUG_POS_CALIB_T::~ENGINEER_DEBUG_POS_CALIB_T() throw() {
}


void ENGINEER_DEBUG_POS_CALIB_T::__set_iCalibID(const int32_t val) {
  this->iCalibID = val;
}

void ENGINEER_DEBUG_POS_CALIB_T::__set_iPosID(const int32_t val) {
  this->iPosID = val;
}

void ENGINEER_DEBUG_POS_CALIB_T::__set_iOldValue(const int32_t val) {
  this->iOldValue = val;
}

void ENGINEER_DEBUG_POS_CALIB_T::__set_iCurValue(const int32_t val) {
  this->iCurValue = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_POS_CALIB_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_POS_CALIB_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCalibID);
          this->__isset.iCalibID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iPosID);
          this->__isset.iPosID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOldValue);
          this->__isset.iOldValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCurValue);
          this->__isset.iCurValue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_POS_CALIB_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_POS_CALIB_T");

  xfer += oprot->writeFieldBegin("iCalibID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iCalibID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iPosID", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iPosID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iOldValue", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iOldValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iCurValue", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iCurValue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_POS_CALIB_T &a, ENGINEER_DEBUG_POS_CALIB_T &b) {
  using ::std::swap;
  swap(a.iCalibID, b.iCalibID);
  swap(a.iPosID, b.iPosID);
  swap(a.iOldValue, b.iOldValue);
  swap(a.iCurValue, b.iCurValue);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_POS_CALIB_T::ENGINEER_DEBUG_POS_CALIB_T(const ENGINEER_DEBUG_POS_CALIB_T& other86) {
  iCalibID = other86.iCalibID;
  iPosID = other86.iPosID;
  iOldValue = other86.iOldValue;
  iCurValue = other86.iCurValue;
  __isset = other86.__isset;
}
ENGINEER_DEBUG_POS_CALIB_T& ENGINEER_DEBUG_POS_CALIB_T::operator=(const ENGINEER_DEBUG_POS_CALIB_T& other87) {
  iCalibID = other87.iCalibID;
  iPosID = other87.iPosID;
  iOldValue = other87.iOldValue;
  iCurValue = other87.iCurValue;
  __isset = other87.__isset;
  return *this;
}
void ENGINEER_DEBUG_POS_CALIB_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_POS_CALIB_T(";
  out << "iCalibID=" << to_string(iCalibID);
  out << ", " << "iPosID=" << to_string(iPosID);
  out << ", " << "iOldValue=" << to_string(iOldValue);
  out << ", " << "iCurValue=" << to_string(iCurValue);
  out << ")";
}


ENGINEER_DEBUG_INJECTOR_KB_T::~ENGINEER_DEBUG_INJECTOR_KB_T() throw() {
}


void ENGINEER_DEBUG_INJECTOR_KB_T::__set_iInjectID(const int32_t val) {
  this->iInjectID = val;
}

void ENGINEER_DEBUG_INJECTOR_KB_T::__set_strInjectName(const std::string& val) {
  this->strInjectName = val;
}

void ENGINEER_DEBUG_INJECTOR_KB_T::__set_dK(const double val) {
  this->dK = val;
}

void ENGINEER_DEBUG_INJECTOR_KB_T::__set_dB(const double val) {
  this->dB = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_INJECTOR_KB_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_INJECTOR_KB_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iInjectID);
          this->__isset.iInjectID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strInjectName);
          this->__isset.strInjectName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dK);
          this->__isset.dK = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->dB);
          this->__isset.dB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_INJECTOR_KB_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_INJECTOR_KB_T");

  xfer += oprot->writeFieldBegin("iInjectID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iInjectID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strInjectName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strInjectName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dK", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->dK);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dB", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->dB);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_INJECTOR_KB_T &a, ENGINEER_DEBUG_INJECTOR_KB_T &b) {
  using ::std::swap;
  swap(a.iInjectID, b.iInjectID);
  swap(a.strInjectName, b.strInjectName);
  swap(a.dK, b.dK);
  swap(a.dB, b.dB);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_INJECTOR_KB_T::ENGINEER_DEBUG_INJECTOR_KB_T(const ENGINEER_DEBUG_INJECTOR_KB_T& other88) {
  iInjectID = other88.iInjectID;
  strInjectName = other88.strInjectName;
  dK = other88.dK;
  dB = other88.dB;
  __isset = other88.__isset;
}
ENGINEER_DEBUG_INJECTOR_KB_T& ENGINEER_DEBUG_INJECTOR_KB_T::operator=(const ENGINEER_DEBUG_INJECTOR_KB_T& other89) {
  iInjectID = other89.iInjectID;
  strInjectName = other89.strInjectName;
  dK = other89.dK;
  dB = other89.dB;
  __isset = other89.__isset;
  return *this;
}
void ENGINEER_DEBUG_INJECTOR_KB_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_INJECTOR_KB_T(";
  out << "iInjectID=" << to_string(iInjectID);
  out << ", " << "strInjectName=" << to_string(strInjectName);
  out << ", " << "dK=" << to_string(dK);
  out << ", " << "dB=" << to_string(dB);
  out << ")";
}


ENGINEER_DEBUG_RUN_RESULT_T::~ENGINEER_DEBUG_RUN_RESULT_T() throw() {
}


void ENGINEER_DEBUG_RUN_RESULT_T::__set_iRunResult(const int32_t val) {
  this->iRunResult = val;
}

void ENGINEER_DEBUG_RUN_RESULT_T::__set_strBarcode(const std::string& val) {
  this->strBarcode = val;
}
std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_RUN_RESULT_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ENGINEER_DEBUG_RUN_RESULT_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iRunResult);
          this->__isset.iRunResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strBarcode);
          this->__isset.strBarcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ENGINEER_DEBUG_RUN_RESULT_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ENGINEER_DEBUG_RUN_RESULT_T");

  xfer += oprot->writeFieldBegin("iRunResult", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iRunResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strBarcode", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strBarcode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ENGINEER_DEBUG_RUN_RESULT_T &a, ENGINEER_DEBUG_RUN_RESULT_T &b) {
  using ::std::swap;
  swap(a.iRunResult, b.iRunResult);
  swap(a.strBarcode, b.strBarcode);
  swap(a.__isset, b.__isset);
}

ENGINEER_DEBUG_RUN_RESULT_T::ENGINEER_DEBUG_RUN_RESULT_T(const ENGINEER_DEBUG_RUN_RESULT_T& other90) {
  iRunResult = other90.iRunResult;
  strBarcode = other90.strBarcode;
  __isset = other90.__isset;
}
ENGINEER_DEBUG_RUN_RESULT_T& ENGINEER_DEBUG_RUN_RESULT_T::operator=(const ENGINEER_DEBUG_RUN_RESULT_T& other91) {
  iRunResult = other91.iRunResult;
  strBarcode = other91.strBarcode;
  __isset = other91.__isset;
  return *this;
}
void ENGINEER_DEBUG_RUN_RESULT_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ENGINEER_DEBUG_RUN_RESULT_T(";
  out << "iRunResult=" << to_string(iRunResult);
  out << ", " << "strBarcode=" << to_string(strBarcode);
  out << ")";
}


THRIFT_CONFIG_T::~THRIFT_CONFIG_T() throw() {
}


void THRIFT_CONFIG_T::__set_strSlaveIP(const std::string& val) {
  this->strSlaveIP = val;
}

void THRIFT_CONFIG_T::__set_iSlavePort(const int32_t val) {
  this->iSlavePort = val;
}

void THRIFT_CONFIG_T::__set_strHostIP(const std::string& val) {
  this->strHostIP = val;
}

void THRIFT_CONFIG_T::__set_iHostPort(const int32_t val) {
  this->iHostPort = val;
}

void THRIFT_CONFIG_T::__set_iIsPunctureNeedle(const int32_t val) {
  this->iIsPunctureNeedle = val;
}
std::ostream& operator<<(std::ostream& out, const THRIFT_CONFIG_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t THRIFT_CONFIG_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strSlaveIP);
          this->__isset.strSlaveIP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlavePort);
          this->__isset.iSlavePort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strHostIP);
          this->__isset.strHostIP = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHostPort);
          this->__isset.iHostPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsPunctureNeedle);
          this->__isset.iIsPunctureNeedle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t THRIFT_CONFIG_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("THRIFT_CONFIG_T");

  xfer += oprot->writeFieldBegin("strSlaveIP", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->strSlaveIP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSlavePort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iSlavePort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strHostIP", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->strHostIP);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHostPort", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iHostPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsPunctureNeedle", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iIsPunctureNeedle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(THRIFT_CONFIG_T &a, THRIFT_CONFIG_T &b) {
  using ::std::swap;
  swap(a.strSlaveIP, b.strSlaveIP);
  swap(a.iSlavePort, b.iSlavePort);
  swap(a.strHostIP, b.strHostIP);
  swap(a.iHostPort, b.iHostPort);
  swap(a.iIsPunctureNeedle, b.iIsPunctureNeedle);
  swap(a.__isset, b.__isset);
}

THRIFT_CONFIG_T::THRIFT_CONFIG_T(const THRIFT_CONFIG_T& other92) {
  strSlaveIP = other92.strSlaveIP;
  iSlavePort = other92.iSlavePort;
  strHostIP = other92.strHostIP;
  iHostPort = other92.iHostPort;
  iIsPunctureNeedle = other92.iIsPunctureNeedle;
  __isset = other92.__isset;
}
THRIFT_CONFIG_T& THRIFT_CONFIG_T::operator=(const THRIFT_CONFIG_T& other93) {
  strSlaveIP = other93.strSlaveIP;
  iSlavePort = other93.iSlavePort;
  strHostIP = other93.strHostIP;
  iHostPort = other93.iHostPort;
  iIsPunctureNeedle = other93.iIsPunctureNeedle;
  __isset = other93.__isset;
  return *this;
}
void THRIFT_CONFIG_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "THRIFT_CONFIG_T(";
  out << "strSlaveIP=" << to_string(strSlaveIP);
  out << ", " << "iSlavePort=" << to_string(iSlavePort);
  out << ", " << "strHostIP=" << to_string(strHostIP);
  out << ", " << "iHostPort=" << to_string(iHostPort);
  out << ", " << "iIsPunctureNeedle=" << to_string(iIsPunctureNeedle);
  out << ")";
}


SLAVE_PROGRAM_T::~SLAVE_PROGRAM_T() throw() {
}


void SLAVE_PROGRAM_T::__set_iSlaveProgramNo(const int32_t val) {
  this->iSlaveProgramNo = val;
}

void SLAVE_PROGRAM_T::__set_strSlaveProgramFileName(const std::string& val) {
  this->strSlaveProgramFileName = val;
}

void SLAVE_PROGRAM_T::__set_hexSlaveProgram(const std::string& val) {
  this->hexSlaveProgram = val;
}

void SLAVE_PROGRAM_T::__set_strMD5(const std::string& val) {
  this->strMD5 = val;
}

void SLAVE_PROGRAM_T::__set_iHexSlaveProgramLen(const int32_t val) {
  this->iHexSlaveProgramLen = val;
}
std::ostream& operator<<(std::ostream& out, const SLAVE_PROGRAM_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SLAVE_PROGRAM_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlaveProgramNo);
          this->__isset.iSlaveProgramNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strSlaveProgramFileName);
          this->__isset.strSlaveProgramFileName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->hexSlaveProgram);
          this->__isset.hexSlaveProgram = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->strMD5);
          this->__isset.strMD5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iHexSlaveProgramLen);
          this->__isset.iHexSlaveProgramLen = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLAVE_PROGRAM_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLAVE_PROGRAM_T");

  xfer += oprot->writeFieldBegin("iSlaveProgramNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSlaveProgramNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strSlaveProgramFileName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->strSlaveProgramFileName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hexSlaveProgram", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->hexSlaveProgram);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("strMD5", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->strMD5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iHexSlaveProgramLen", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iHexSlaveProgramLen);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLAVE_PROGRAM_T &a, SLAVE_PROGRAM_T &b) {
  using ::std::swap;
  swap(a.iSlaveProgramNo, b.iSlaveProgramNo);
  swap(a.strSlaveProgramFileName, b.strSlaveProgramFileName);
  swap(a.hexSlaveProgram, b.hexSlaveProgram);
  swap(a.strMD5, b.strMD5);
  swap(a.iHexSlaveProgramLen, b.iHexSlaveProgramLen);
  swap(a.__isset, b.__isset);
}

SLAVE_PROGRAM_T::SLAVE_PROGRAM_T(const SLAVE_PROGRAM_T& other94) {
  iSlaveProgramNo = other94.iSlaveProgramNo;
  strSlaveProgramFileName = other94.strSlaveProgramFileName;
  hexSlaveProgram = other94.hexSlaveProgram;
  strMD5 = other94.strMD5;
  iHexSlaveProgramLen = other94.iHexSlaveProgramLen;
  __isset = other94.__isset;
}
SLAVE_PROGRAM_T& SLAVE_PROGRAM_T::operator=(const SLAVE_PROGRAM_T& other95) {
  iSlaveProgramNo = other95.iSlaveProgramNo;
  strSlaveProgramFileName = other95.strSlaveProgramFileName;
  hexSlaveProgram = other95.hexSlaveProgram;
  strMD5 = other95.strMD5;
  iHexSlaveProgramLen = other95.iHexSlaveProgramLen;
  __isset = other95.__isset;
  return *this;
}
void SLAVE_PROGRAM_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLAVE_PROGRAM_T(";
  out << "iSlaveProgramNo=" << to_string(iSlaveProgramNo);
  out << ", " << "strSlaveProgramFileName=" << to_string(strSlaveProgramFileName);
  out << ", " << "hexSlaveProgram=" << to_string(hexSlaveProgram);
  out << ", " << "strMD5=" << to_string(strMD5);
  out << ", " << "iHexSlaveProgramLen=" << to_string(iHexSlaveProgramLen);
  out << ")";
}


SLAVE_PROGRAM_UPDATE_RESULT_T::~SLAVE_PROGRAM_UPDATE_RESULT_T() throw() {
}


void SLAVE_PROGRAM_UPDATE_RESULT_T::__set_iSlaveProgramNo(const int32_t val) {
  this->iSlaveProgramNo = val;
}

void SLAVE_PROGRAM_UPDATE_RESULT_T::__set_iUpdateResult(const int32_t val) {
  this->iUpdateResult = val;
}
std::ostream& operator<<(std::ostream& out, const SLAVE_PROGRAM_UPDATE_RESULT_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SLAVE_PROGRAM_UPDATE_RESULT_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlaveProgramNo);
          this->__isset.iSlaveProgramNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUpdateResult);
          this->__isset.iUpdateResult = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLAVE_PROGRAM_UPDATE_RESULT_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLAVE_PROGRAM_UPDATE_RESULT_T");

  xfer += oprot->writeFieldBegin("iSlaveProgramNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSlaveProgramNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUpdateResult", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUpdateResult);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLAVE_PROGRAM_UPDATE_RESULT_T &a, SLAVE_PROGRAM_UPDATE_RESULT_T &b) {
  using ::std::swap;
  swap(a.iSlaveProgramNo, b.iSlaveProgramNo);
  swap(a.iUpdateResult, b.iUpdateResult);
  swap(a.__isset, b.__isset);
}

SLAVE_PROGRAM_UPDATE_RESULT_T::SLAVE_PROGRAM_UPDATE_RESULT_T(const SLAVE_PROGRAM_UPDATE_RESULT_T& other96) {
  iSlaveProgramNo = other96.iSlaveProgramNo;
  iUpdateResult = other96.iUpdateResult;
  __isset = other96.__isset;
}
SLAVE_PROGRAM_UPDATE_RESULT_T& SLAVE_PROGRAM_UPDATE_RESULT_T::operator=(const SLAVE_PROGRAM_UPDATE_RESULT_T& other97) {
  iSlaveProgramNo = other97.iSlaveProgramNo;
  iUpdateResult = other97.iUpdateResult;
  __isset = other97.__isset;
  return *this;
}
void SLAVE_PROGRAM_UPDATE_RESULT_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLAVE_PROGRAM_UPDATE_RESULT_T(";
  out << "iSlaveProgramNo=" << to_string(iSlaveProgramNo);
  out << ", " << "iUpdateResult=" << to_string(iUpdateResult);
  out << ")";
}


SLAVE_ASSEMBLY_AGING_PARA_T::~SLAVE_ASSEMBLY_AGING_PARA_T() throw() {
}


void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsOnOrOFF(const int32_t val) {
  this->iIsOnOrOFF = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iLoopCounts(const int32_t val) {
  this->iLoopCounts = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableSampler(const int32_t val) {
  this->iIsEnableSampler = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableReagentBin(const int32_t val) {
  this->iIsEnableReagentBin = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableGripperA(const int32_t val) {
  this->iIsEnableGripperA = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableGripperB(const int32_t val) {
  this->iIsEnableGripperB = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableGripperC(const int32_t val) {
  this->iIsEnableGripperC = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableSampleNeedle(const int32_t val) {
  this->iIsEnableSampleNeedle = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableIncubationReagentNeedle(const int32_t val) {
  this->iIsEnableIncubationReagentNeedle = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableDetectionReagentNeedle(const int32_t val) {
  this->iIsEnableDetectionReagentNeedle = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableOnlineLoad(const int32_t val) {
  this->iIsEnableOnlineLoad = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableReactionCupTransferBelt(const int32_t val) {
  this->iIsEnableReactionCupTransferBelt = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableReactionCupMixing(const int32_t val) {
  this->iIsEnableReactionCupMixing = val;
}

void SLAVE_ASSEMBLY_AGING_PARA_T::__set_iIsEnableReactionCupLoad(const int32_t val) {
  this->iIsEnableReactionCupLoad = val;
}
std::ostream& operator<<(std::ostream& out, const SLAVE_ASSEMBLY_AGING_PARA_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SLAVE_ASSEMBLY_AGING_PARA_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsOnOrOFF);
          this->__isset.iIsOnOrOFF = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iLoopCounts);
          this->__isset.iLoopCounts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableSampler);
          this->__isset.iIsEnableSampler = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableReagentBin);
          this->__isset.iIsEnableReagentBin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableGripperA);
          this->__isset.iIsEnableGripperA = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableGripperB);
          this->__isset.iIsEnableGripperB = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableGripperC);
          this->__isset.iIsEnableGripperC = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableSampleNeedle);
          this->__isset.iIsEnableSampleNeedle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableIncubationReagentNeedle);
          this->__isset.iIsEnableIncubationReagentNeedle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableDetectionReagentNeedle);
          this->__isset.iIsEnableDetectionReagentNeedle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableOnlineLoad);
          this->__isset.iIsEnableOnlineLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableReactionCupTransferBelt);
          this->__isset.iIsEnableReactionCupTransferBelt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableReactionCupMixing);
          this->__isset.iIsEnableReactionCupMixing = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iIsEnableReactionCupLoad);
          this->__isset.iIsEnableReactionCupLoad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLAVE_ASSEMBLY_AGING_PARA_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLAVE_ASSEMBLY_AGING_PARA_T");

  xfer += oprot->writeFieldBegin("iIsOnOrOFF", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iIsOnOrOFF);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iLoopCounts", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iLoopCounts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableSampler", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iIsEnableSampler);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableReagentBin", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iIsEnableReagentBin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableGripperA", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->iIsEnableGripperA);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableGripperB", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->iIsEnableGripperB);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableGripperC", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->iIsEnableGripperC);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableSampleNeedle", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iIsEnableSampleNeedle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableIncubationReagentNeedle", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->iIsEnableIncubationReagentNeedle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableDetectionReagentNeedle", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->iIsEnableDetectionReagentNeedle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableOnlineLoad", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->iIsEnableOnlineLoad);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableReactionCupTransferBelt", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->iIsEnableReactionCupTransferBelt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableReactionCupMixing", ::apache::thrift::protocol::T_I32, 13);
  xfer += oprot->writeI32(this->iIsEnableReactionCupMixing);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iIsEnableReactionCupLoad", ::apache::thrift::protocol::T_I32, 14);
  xfer += oprot->writeI32(this->iIsEnableReactionCupLoad);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLAVE_ASSEMBLY_AGING_PARA_T &a, SLAVE_ASSEMBLY_AGING_PARA_T &b) {
  using ::std::swap;
  swap(a.iIsOnOrOFF, b.iIsOnOrOFF);
  swap(a.iLoopCounts, b.iLoopCounts);
  swap(a.iIsEnableSampler, b.iIsEnableSampler);
  swap(a.iIsEnableReagentBin, b.iIsEnableReagentBin);
  swap(a.iIsEnableGripperA, b.iIsEnableGripperA);
  swap(a.iIsEnableGripperB, b.iIsEnableGripperB);
  swap(a.iIsEnableGripperC, b.iIsEnableGripperC);
  swap(a.iIsEnableSampleNeedle, b.iIsEnableSampleNeedle);
  swap(a.iIsEnableIncubationReagentNeedle, b.iIsEnableIncubationReagentNeedle);
  swap(a.iIsEnableDetectionReagentNeedle, b.iIsEnableDetectionReagentNeedle);
  swap(a.iIsEnableOnlineLoad, b.iIsEnableOnlineLoad);
  swap(a.iIsEnableReactionCupTransferBelt, b.iIsEnableReactionCupTransferBelt);
  swap(a.iIsEnableReactionCupMixing, b.iIsEnableReactionCupMixing);
  swap(a.iIsEnableReactionCupLoad, b.iIsEnableReactionCupLoad);
  swap(a.__isset, b.__isset);
}

SLAVE_ASSEMBLY_AGING_PARA_T::SLAVE_ASSEMBLY_AGING_PARA_T(const SLAVE_ASSEMBLY_AGING_PARA_T& other98) {
  iIsOnOrOFF = other98.iIsOnOrOFF;
  iLoopCounts = other98.iLoopCounts;
  iIsEnableSampler = other98.iIsEnableSampler;
  iIsEnableReagentBin = other98.iIsEnableReagentBin;
  iIsEnableGripperA = other98.iIsEnableGripperA;
  iIsEnableGripperB = other98.iIsEnableGripperB;
  iIsEnableGripperC = other98.iIsEnableGripperC;
  iIsEnableSampleNeedle = other98.iIsEnableSampleNeedle;
  iIsEnableIncubationReagentNeedle = other98.iIsEnableIncubationReagentNeedle;
  iIsEnableDetectionReagentNeedle = other98.iIsEnableDetectionReagentNeedle;
  iIsEnableOnlineLoad = other98.iIsEnableOnlineLoad;
  iIsEnableReactionCupTransferBelt = other98.iIsEnableReactionCupTransferBelt;
  iIsEnableReactionCupMixing = other98.iIsEnableReactionCupMixing;
  iIsEnableReactionCupLoad = other98.iIsEnableReactionCupLoad;
  __isset = other98.__isset;
}
SLAVE_ASSEMBLY_AGING_PARA_T& SLAVE_ASSEMBLY_AGING_PARA_T::operator=(const SLAVE_ASSEMBLY_AGING_PARA_T& other99) {
  iIsOnOrOFF = other99.iIsOnOrOFF;
  iLoopCounts = other99.iLoopCounts;
  iIsEnableSampler = other99.iIsEnableSampler;
  iIsEnableReagentBin = other99.iIsEnableReagentBin;
  iIsEnableGripperA = other99.iIsEnableGripperA;
  iIsEnableGripperB = other99.iIsEnableGripperB;
  iIsEnableGripperC = other99.iIsEnableGripperC;
  iIsEnableSampleNeedle = other99.iIsEnableSampleNeedle;
  iIsEnableIncubationReagentNeedle = other99.iIsEnableIncubationReagentNeedle;
  iIsEnableDetectionReagentNeedle = other99.iIsEnableDetectionReagentNeedle;
  iIsEnableOnlineLoad = other99.iIsEnableOnlineLoad;
  iIsEnableReactionCupTransferBelt = other99.iIsEnableReactionCupTransferBelt;
  iIsEnableReactionCupMixing = other99.iIsEnableReactionCupMixing;
  iIsEnableReactionCupLoad = other99.iIsEnableReactionCupLoad;
  __isset = other99.__isset;
  return *this;
}
void SLAVE_ASSEMBLY_AGING_PARA_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLAVE_ASSEMBLY_AGING_PARA_T(";
  out << "iIsOnOrOFF=" << to_string(iIsOnOrOFF);
  out << ", " << "iLoopCounts=" << to_string(iLoopCounts);
  out << ", " << "iIsEnableSampler=" << to_string(iIsEnableSampler);
  out << ", " << "iIsEnableReagentBin=" << to_string(iIsEnableReagentBin);
  out << ", " << "iIsEnableGripperA=" << to_string(iIsEnableGripperA);
  out << ", " << "iIsEnableGripperB=" << to_string(iIsEnableGripperB);
  out << ", " << "iIsEnableGripperC=" << to_string(iIsEnableGripperC);
  out << ", " << "iIsEnableSampleNeedle=" << to_string(iIsEnableSampleNeedle);
  out << ", " << "iIsEnableIncubationReagentNeedle=" << to_string(iIsEnableIncubationReagentNeedle);
  out << ", " << "iIsEnableDetectionReagentNeedle=" << to_string(iIsEnableDetectionReagentNeedle);
  out << ", " << "iIsEnableOnlineLoad=" << to_string(iIsEnableOnlineLoad);
  out << ", " << "iIsEnableReactionCupTransferBelt=" << to_string(iIsEnableReactionCupTransferBelt);
  out << ", " << "iIsEnableReactionCupMixing=" << to_string(iIsEnableReactionCupMixing);
  out << ", " << "iIsEnableReactionCupLoad=" << to_string(iIsEnableReactionCupLoad);
  out << ")";
}


SLAVE_COUNTEROR_TIMER_INFO_T::~SLAVE_COUNTEROR_TIMER_INFO_T() throw() {
}


void SLAVE_COUNTEROR_TIMER_INFO_T::__set_iCounterOrTimerID(const int32_t val) {
  this->iCounterOrTimerID = val;
}

void SLAVE_COUNTEROR_TIMER_INFO_T::__set_iNumberOfTimesOrElapsedTime(const int32_t val) {
  this->iNumberOfTimesOrElapsedTime = val;
}

void SLAVE_COUNTEROR_TIMER_INFO_T::__set_iTotalNumberOfTimesOrElapsedTime(const int32_t val) {
  this->iTotalNumberOfTimesOrElapsedTime = val;
}
std::ostream& operator<<(std::ostream& out, const SLAVE_COUNTEROR_TIMER_INFO_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SLAVE_COUNTEROR_TIMER_INFO_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iCounterOrTimerID);
          this->__isset.iCounterOrTimerID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iNumberOfTimesOrElapsedTime);
          this->__isset.iNumberOfTimesOrElapsedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iTotalNumberOfTimesOrElapsedTime);
          this->__isset.iTotalNumberOfTimesOrElapsedTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLAVE_COUNTEROR_TIMER_INFO_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLAVE_COUNTEROR_TIMER_INFO_T");

  xfer += oprot->writeFieldBegin("iCounterOrTimerID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iCounterOrTimerID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iNumberOfTimesOrElapsedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iTotalNumberOfTimesOrElapsedTime", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iTotalNumberOfTimesOrElapsedTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLAVE_COUNTEROR_TIMER_INFO_T &a, SLAVE_COUNTEROR_TIMER_INFO_T &b) {
  using ::std::swap;
  swap(a.iCounterOrTimerID, b.iCounterOrTimerID);
  swap(a.iNumberOfTimesOrElapsedTime, b.iNumberOfTimesOrElapsedTime);
  swap(a.iTotalNumberOfTimesOrElapsedTime, b.iTotalNumberOfTimesOrElapsedTime);
  swap(a.__isset, b.__isset);
}

SLAVE_COUNTEROR_TIMER_INFO_T::SLAVE_COUNTEROR_TIMER_INFO_T(const SLAVE_COUNTEROR_TIMER_INFO_T& other100) {
  iCounterOrTimerID = other100.iCounterOrTimerID;
  iNumberOfTimesOrElapsedTime = other100.iNumberOfTimesOrElapsedTime;
  iTotalNumberOfTimesOrElapsedTime = other100.iTotalNumberOfTimesOrElapsedTime;
  __isset = other100.__isset;
}
SLAVE_COUNTEROR_TIMER_INFO_T& SLAVE_COUNTEROR_TIMER_INFO_T::operator=(const SLAVE_COUNTEROR_TIMER_INFO_T& other101) {
  iCounterOrTimerID = other101.iCounterOrTimerID;
  iNumberOfTimesOrElapsedTime = other101.iNumberOfTimesOrElapsedTime;
  iTotalNumberOfTimesOrElapsedTime = other101.iTotalNumberOfTimesOrElapsedTime;
  __isset = other101.__isset;
  return *this;
}
void SLAVE_COUNTEROR_TIMER_INFO_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLAVE_COUNTEROR_TIMER_INFO_T(";
  out << "iCounterOrTimerID=" << to_string(iCounterOrTimerID);
  out << ", " << "iNumberOfTimesOrElapsedTime=" << to_string(iNumberOfTimesOrElapsedTime);
  out << ", " << "iTotalNumberOfTimesOrElapsedTime=" << to_string(iTotalNumberOfTimesOrElapsedTime);
  out << ")";
}


CHANNEL_STATUS_T::~CHANNEL_STATUS_T() throw() {
}


void CHANNEL_STATUS_T::__set_iChannelNo(const int32_t val) {
  this->iChannelNo = val;
}

void CHANNEL_STATUS_T::__set_iChannelType(const int32_t val) {
  this->iChannelType = val;
}

void CHANNEL_STATUS_T::__set_iDisable(const int32_t val) {
  this->iDisable = val;
}
std::ostream& operator<<(std::ostream& out, const CHANNEL_STATUS_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CHANNEL_STATUS_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iChannelNo);
          this->__isset.iChannelNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iChannelType);
          this->__isset.iChannelType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iDisable);
          this->__isset.iDisable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CHANNEL_STATUS_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CHANNEL_STATUS_T");

  xfer += oprot->writeFieldBegin("iChannelNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iChannelNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iChannelType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iChannelType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iDisable", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iDisable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CHANNEL_STATUS_T &a, CHANNEL_STATUS_T &b) {
  using ::std::swap;
  swap(a.iChannelNo, b.iChannelNo);
  swap(a.iChannelType, b.iChannelType);
  swap(a.iDisable, b.iDisable);
  swap(a.__isset, b.__isset);
}

CHANNEL_STATUS_T::CHANNEL_STATUS_T(const CHANNEL_STATUS_T& other102) {
  iChannelNo = other102.iChannelNo;
  iChannelType = other102.iChannelType;
  iDisable = other102.iDisable;
  __isset = other102.__isset;
}
CHANNEL_STATUS_T& CHANNEL_STATUS_T::operator=(const CHANNEL_STATUS_T& other103) {
  iChannelNo = other103.iChannelNo;
  iChannelType = other103.iChannelType;
  iDisable = other103.iDisable;
  __isset = other103.__isset;
  return *this;
}
void CHANNEL_STATUS_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CHANNEL_STATUS_T(";
  out << "iChannelNo=" << to_string(iChannelNo);
  out << ", " << "iChannelType=" << to_string(iChannelType);
  out << ", " << "iDisable=" << to_string(iDisable);
  out << ")";
}


CHANNEL_GAIN_T::~CHANNEL_GAIN_T() throw() {
}


void CHANNEL_GAIN_T::__set_i340Gain(const int32_t val) {
  this->i340Gain = val;
}

void CHANNEL_GAIN_T::__set_i405Gain(const int32_t val) {
  this->i405Gain = val;
}

void CHANNEL_GAIN_T::__set_i570Gain(const int32_t val) {
  this->i570Gain = val;
}

void CHANNEL_GAIN_T::__set_i660Gain(const int32_t val) {
  this->i660Gain = val;
}

void CHANNEL_GAIN_T::__set_i800Gain(const int32_t val) {
  this->i800Gain = val;
}
std::ostream& operator<<(std::ostream& out, const CHANNEL_GAIN_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CHANNEL_GAIN_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i340Gain);
          this->__isset.i340Gain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i405Gain);
          this->__isset.i405Gain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i570Gain);
          this->__isset.i570Gain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i660Gain);
          this->__isset.i660Gain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i800Gain);
          this->__isset.i800Gain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CHANNEL_GAIN_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CHANNEL_GAIN_T");

  xfer += oprot->writeFieldBegin("i340Gain", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->i340Gain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i405Gain", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->i405Gain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i570Gain", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->i570Gain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i660Gain", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->i660Gain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i800Gain", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->i800Gain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CHANNEL_GAIN_T &a, CHANNEL_GAIN_T &b) {
  using ::std::swap;
  swap(a.i340Gain, b.i340Gain);
  swap(a.i405Gain, b.i405Gain);
  swap(a.i570Gain, b.i570Gain);
  swap(a.i660Gain, b.i660Gain);
  swap(a.i800Gain, b.i800Gain);
  swap(a.__isset, b.__isset);
}

CHANNEL_GAIN_T::CHANNEL_GAIN_T(const CHANNEL_GAIN_T& other104) {
  i340Gain = other104.i340Gain;
  i405Gain = other104.i405Gain;
  i570Gain = other104.i570Gain;
  i660Gain = other104.i660Gain;
  i800Gain = other104.i800Gain;
  __isset = other104.__isset;
}
CHANNEL_GAIN_T& CHANNEL_GAIN_T::operator=(const CHANNEL_GAIN_T& other105) {
  i340Gain = other105.i340Gain;
  i405Gain = other105.i405Gain;
  i570Gain = other105.i570Gain;
  i660Gain = other105.i660Gain;
  i800Gain = other105.i800Gain;
  __isset = other105.__isset;
  return *this;
}
void CHANNEL_GAIN_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CHANNEL_GAIN_T(";
  out << "i340Gain=" << to_string(i340Gain);
  out << ", " << "i405Gain=" << to_string(i405Gain);
  out << ", " << "i570Gain=" << to_string(i570Gain);
  out << ", " << "i660Gain=" << to_string(i660Gain);
  out << ", " << "i800Gain=" << to_string(i800Gain);
  out << ")";
}


CHANNEL_AD_T::~CHANNEL_AD_T() throw() {
}


void CHANNEL_AD_T::__set_iChannelNo(const int32_t val) {
  this->iChannelNo = val;
}

void CHANNEL_AD_T::__set_iChannelType(const int32_t val) {
  this->iChannelType = val;
}

void CHANNEL_AD_T::__set_i340AD(const int32_t val) {
  this->i340AD = val;
}

void CHANNEL_AD_T::__set_i405AD(const int32_t val) {
  this->i405AD = val;
}

void CHANNEL_AD_T::__set_i570AD(const int32_t val) {
  this->i570AD = val;
}

void CHANNEL_AD_T::__set_i660AD(const int32_t val) {
  this->i660AD = val;
}

void CHANNEL_AD_T::__set_i800AD(const int32_t val) {
  this->i800AD = val;
}

void CHANNEL_AD_T::__set_iReserved(const int32_t val) {
  this->iReserved = val;
}
std::ostream& operator<<(std::ostream& out, const CHANNEL_AD_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CHANNEL_AD_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iChannelNo);
          this->__isset.iChannelNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iChannelType);
          this->__isset.iChannelType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i340AD);
          this->__isset.i340AD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i405AD);
          this->__isset.i405AD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i570AD);
          this->__isset.i570AD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i660AD);
          this->__isset.i660AD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->i800AD);
          this->__isset.i800AD = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReserved);
          this->__isset.iReserved = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CHANNEL_AD_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CHANNEL_AD_T");

  xfer += oprot->writeFieldBegin("iChannelNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iChannelNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iChannelType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iChannelType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i340AD", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->i340AD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i405AD", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->i405AD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i570AD", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->i570AD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i660AD", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->i660AD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("i800AD", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->i800AD);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReserved", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->iReserved);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CHANNEL_AD_T &a, CHANNEL_AD_T &b) {
  using ::std::swap;
  swap(a.iChannelNo, b.iChannelNo);
  swap(a.iChannelType, b.iChannelType);
  swap(a.i340AD, b.i340AD);
  swap(a.i405AD, b.i405AD);
  swap(a.i570AD, b.i570AD);
  swap(a.i660AD, b.i660AD);
  swap(a.i800AD, b.i800AD);
  swap(a.iReserved, b.iReserved);
  swap(a.__isset, b.__isset);
}

CHANNEL_AD_T::CHANNEL_AD_T(const CHANNEL_AD_T& other106) {
  iChannelNo = other106.iChannelNo;
  iChannelType = other106.iChannelType;
  i340AD = other106.i340AD;
  i405AD = other106.i405AD;
  i570AD = other106.i570AD;
  i660AD = other106.i660AD;
  i800AD = other106.i800AD;
  iReserved = other106.iReserved;
  __isset = other106.__isset;
}
CHANNEL_AD_T& CHANNEL_AD_T::operator=(const CHANNEL_AD_T& other107) {
  iChannelNo = other107.iChannelNo;
  iChannelType = other107.iChannelType;
  i340AD = other107.i340AD;
  i405AD = other107.i405AD;
  i570AD = other107.i570AD;
  i660AD = other107.i660AD;
  i800AD = other107.i800AD;
  iReserved = other107.iReserved;
  __isset = other107.__isset;
  return *this;
}
void CHANNEL_AD_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CHANNEL_AD_T(";
  out << "iChannelNo=" << to_string(iChannelNo);
  out << ", " << "iChannelType=" << to_string(iChannelType);
  out << ", " << "i340AD=" << to_string(i340AD);
  out << ", " << "i405AD=" << to_string(i405AD);
  out << ", " << "i570AD=" << to_string(i570AD);
  out << ", " << "i660AD=" << to_string(i660AD);
  out << ", " << "i800AD=" << to_string(i800AD);
  out << ", " << "iReserved=" << to_string(iReserved);
  out << ")";
}


MAINTENANCE_ITEM_T::~MAINTENANCE_ITEM_T() throw() {
}


void MAINTENANCE_ITEM_T::__set_iItemID(const int32_t val) {
  this->iItemID = val;
}

void MAINTENANCE_ITEM_T::__set_iParam(const int32_t val) {
  this->iParam = val;
}
std::ostream& operator<<(std::ostream& out, const MAINTENANCE_ITEM_T& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t MAINTENANCE_ITEM_T::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iItemID);
          this->__isset.iItemID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iParam);
          this->__isset.iParam = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MAINTENANCE_ITEM_T::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MAINTENANCE_ITEM_T");

  xfer += oprot->writeFieldBegin("iItemID", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iItemID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iParam", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iParam);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MAINTENANCE_ITEM_T &a, MAINTENANCE_ITEM_T &b) {
  using ::std::swap;
  swap(a.iItemID, b.iItemID);
  swap(a.iParam, b.iParam);
  swap(a.__isset, b.__isset);
}

MAINTENANCE_ITEM_T::MAINTENANCE_ITEM_T(const MAINTENANCE_ITEM_T& other108) {
  iItemID = other108.iItemID;
  iParam = other108.iParam;
  __isset = other108.__isset;
}
MAINTENANCE_ITEM_T& MAINTENANCE_ITEM_T::operator=(const MAINTENANCE_ITEM_T& other109) {
  iItemID = other109.iItemID;
  iParam = other109.iParam;
  __isset = other109.__isset;
  return *this;
}
void MAINTENANCE_ITEM_T::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MAINTENANCE_ITEM_T(";
  out << "iItemID=" << to_string(iItemID);
  out << ", " << "iParam=" << to_string(iParam);
  out << ")";
}


