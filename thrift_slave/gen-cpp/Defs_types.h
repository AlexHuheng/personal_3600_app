/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Defs_TYPES_H
#define Defs_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>




struct EXE_STATE {
  enum type {
    SUCCESS = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _EXE_STATE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const EXE_STATE::type& val);

struct NEEDLE_TYPE {
  enum type {
    SAMPLENEEDLE = 0,
    REAGENTNEEDLE1 = 1,
    REAGENTNEEDLE2 = 2
  };
};

extern const std::map<int, const char*> _NEEDLE_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const NEEDLE_TYPE::type& val);

struct OUTPUT_IO {
  enum type {
    PE_REGENT_TABLE_GATE = 1007,
    MICRO_GATE_CUVETTE = 1020,
    PE_DILU_1 = 1021,
    PE_DILU_2 = 1022,
    PE_INSTRUMENT_GATE = 1024,
    PE_WASTE_FULL = 1026,
    PE_WASTE_EXIST = 1027,
    PE_WASHA = 1028,
    WASHA_BUBBLE_SENSOR = 1030,
    WASHB_BUBBLE_SENSOR = 1033,
    WASTESENSOR = 1035,
    WASHSENSOR = 1036,
    MAGNETIC_BEAD_AD_1 = 4051,
    MAGNETIC_BEAD_AD_2 = 4052,
    MAGNETIC_BEAD_AD_3 = 4053,
    MAGNETIC_BEAD_AD_4 = 4054,
    OPTICAL_AD_1 = 4061,
    OPTICAL_AD_2 = 4062,
    OPTICAL_AD_3 = 4063,
    OPTICAL_AD_4 = 4064,
    OPTICAL_AD_5 = 4065,
    OPTICAL_AD_6 = 4066,
    OPTICAL_AD_7 = 4067,
    OPTICAL_AD_8 = 4068,
    SAMPLE_SLOT_IO1 = 3008,
    SAMPLE_SLOT_IO2 = 3009,
    SAMPLE_SLOT_IO3 = 3010,
    SAMPLE_SLOT_IO4 = 3011,
    SAMPLE_SLOT_IO5 = 3012,
    SAMPLE_SLOT_IO6 = 3013
  };
};

extern const std::map<int, const char*> _OUTPUT_IO_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const OUTPUT_IO::type& val);

struct TEMPERATURE_SENSOR {
  enum type {
    REAGENTCASE = 1,
    REAGENTPIPE = 2,
    INCUBATIONAREA = 3,
    MAGNETICBEAD = 4,
    ENVIRONMENTAREA = 5,
    REAGENTCASEGLASS = 6,
    OPTICAL1 = 7,
    OPTICAL2 = 8
  };
};

extern const std::map<int, const char*> _TEMPERATURE_SENSOR_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const TEMPERATURE_SENSOR::type& val);

struct INPUT_IO {
  enum type {
    CUPLOADPOS1 = 1,
    CUPLOADPOS2 = 2,
    SAMPLE_SLOT_IO1 = 3001,
    SAMPLE_SLOT_IO2 = 3002,
    SAMPLE_SLOT_IO3 = 3003,
    SAMPLE_SLOT_IO4 = 3004,
    SAMPLE_SLOT_IO5 = 3005,
    SAMPLE_SLOT_IO6 = 3006
  };
};

extern const std::map<int, const char*> _INPUT_IO_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const INPUT_IO::type& val);

struct BOTTLE_TYPE {
  enum type {
    BT_UNKNOWN = 0,
    BT_REAGENT_7_ML = 1,
    BT_REAGENT_15_ML = 2,
    BT_REAGENT_25_ML = 3,
    BT_REAGENT_3_ML = 4,
    BT_REAGENT_200_ML = 5,
    BT_TUBE_MICRO = 6,
    BT_TUBE_EP15 = 7
  };
};

extern const std::map<int, const char*> _BOTTLE_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const BOTTLE_TYPE::type& val);

struct SAMPLE_TUBE_TYPE {
  enum type {
    STANARD_CUP = 0,
    EP_CUP = 1,
    PP_1_8 = 2,
    PP_2_7 = 3,
    BT_V3 = 4,
    BT_V7 = 5,
    BT_V15 = 6
  };
};

extern const std::map<int, const char*> _SAMPLE_TUBE_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SAMPLE_TUBE_TYPE::type& val);

struct ORDER_STATE {
  enum type {
    OD_SAMPLECOMPLETION = 0,
    OD_INCUBATING = 1,
    OD_DETECTING = 2,
    OD_COMPLETION = 3,
    OD_ERROR = 4,
    OD_INIT = 5,
    OD_DEPRECATED = 6
  };
};

extern const std::map<int, const char*> _ORDER_STATE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ORDER_STATE::type& val);

struct RESULT_STATE {
  enum type {
    NORMAL = 0,
    UN_CLOT = 1,
    ABNORMAL = 2,
    AD_OUT_OF_RANGE = 3,
    NO_BEAD = 4
  };
};

extern const std::map<int, const char*> _RESULT_STATE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const RESULT_STATE::type& val);

struct REAGENT_SUPPLY_TYPE {
  enum type {
    REAGENT = 0,
    DILUENT = 1,
    CUP = 2,
    WASTE_CUP = 3,
    WASH_B = 4,
    WASH_A = 5,
    WASTE_WATER = 6,
    PUNCTURE_NEEDLE = 7,
    AIR_PUMP = 8,
    REAGENT_QC = 9
  };
};

extern const std::map<int, const char*> _REAGENT_SUPPLY_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const REAGENT_SUPPLY_TYPE::type& val);

struct ENGINEER_DEBUG_AXIS_TYPE {
  enum type {
    R_NONE = 0,
    R_AXIS = 1,
    X_AXIS = 2,
    Y_AXIS = 3,
    Z_AXIS = 4
  };
};

extern const std::map<int, const char*> _ENGINEER_DEBUG_AXIS_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_AXIS_TYPE::type& val);

struct ENGINEER_DEBUG_ACTION_TYPE {
  enum type {
    EDAT_NONE = 0,
    MOVE = 1,
    MOVE_TO = 2,
    RESET = 3,
    POWER_ON_RESET = 4,
    LIQUID_DETECT = 5
  };
};

extern const std::map<int, const char*> _ENGINEER_DEBUG_ACTION_TYPE_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_ACTION_TYPE::type& val);

typedef bool IBOOL;

class EXE_RESULT_T;

class RINSE_INFO_T;

class REAGENT_INFO_T;

class DILUTION_FRACTION_T;

class ORDER_INFO_T;

class SAMPLE_QUALITY_SET_INFO_T;

class SAMPLE_ORDER_INFO_T;

class SAMPLE_QUALITY_T;

class BOOT_PARAM_T;

class PIPELINE_FILL_INFO_T;

class REAGENT_POS_INFO_T;

class REAGENT_MIX_INFO_T;

class SAMPLE_TUBE_INFO_T;

class RESULT_INFO_T;

class ASYNC_RETURN_T;

class THRIFT_MOTOR_PARA_T;

class DATE_TIME_T;

class CONSUMABLES_INFO_T;

class REAGENT_SCAN_INFO_T;

class ENGINEER_DEBUG_VIRTUAL_POS_PARA_T;

class ENGINEER_DEBUG_VIRTUAL_POSITION_T;

class ENGINEER_DEBUG_MODULE_PARA_T;

class ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T;

class ENGINEER_DEBUG_MOTOR_PARA_T;

class ASSAY_GROUP_TESTS_T;

class ENGINEER_DEBUG_POS_CALIB_T;

class ENGINEER_DEBUG_INJECTOR_KB_T;

class ENGINEER_DEBUG_RUN_RESULT_T;

class THRIFT_CONFIG_T;

class SLAVE_PROGRAM_T;

class SLAVE_PROGRAM_UPDATE_RESULT_T;

class SLAVE_ASSEMBLY_AGING_PARA_T;

class SLAVE_COUNTEROR_TIMER_INFO_T;

class CHANNEL_STATUS_T;

class CHANNEL_GAIN_T;

class CHANNEL_AD_T;

class MAINTENANCE_ITEM_T;

typedef struct _EXE_RESULT_T__isset {
  _EXE_RESULT_T__isset() : state(false), iResult(false), strResult(false) {}
  bool state :1;
  bool iResult :1;
  bool strResult :1;
} _EXE_RESULT_T__isset;

class EXE_RESULT_T : public virtual ::apache::thrift::TBase {
 public:

  EXE_RESULT_T(const EXE_RESULT_T&);
  EXE_RESULT_T& operator=(const EXE_RESULT_T&);
  EXE_RESULT_T() : state((EXE_STATE::type)0), iResult(0), strResult() {
  }

  virtual ~EXE_RESULT_T() throw();
  EXE_STATE::type state;
  int32_t iResult;
  std::string strResult;

  _EXE_RESULT_T__isset __isset;

  void __set_state(const EXE_STATE::type val);

  void __set_iResult(const int32_t val);

  void __set_strResult(const std::string& val);

  bool operator == (const EXE_RESULT_T & rhs) const
  {
    if (!(state == rhs.state))
      return false;
    if (!(iResult == rhs.iResult))
      return false;
    if (!(strResult == rhs.strResult))
      return false;
    return true;
  }
  bool operator != (const EXE_RESULT_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const EXE_RESULT_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(EXE_RESULT_T &a, EXE_RESULT_T &b);

std::ostream& operator<<(std::ostream& out, const EXE_RESULT_T& obj);

typedef struct _RINSE_INFO_T__isset {
  _RINSE_INFO_T__isset() : bEnable(false), bEnableWashA(false) {}
  bool bEnable :1;
  bool bEnableWashA :1;
} _RINSE_INFO_T__isset;

class RINSE_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  RINSE_INFO_T(const RINSE_INFO_T&);
  RINSE_INFO_T& operator=(const RINSE_INFO_T&);
  RINSE_INFO_T() : bEnable(0), bEnableWashA(0) {
  }

  virtual ~RINSE_INFO_T() throw();
  IBOOL bEnable;
  IBOOL bEnableWashA;

  _RINSE_INFO_T__isset __isset;

  void __set_bEnable(const IBOOL val);

  void __set_bEnableWashA(const IBOOL val);

  bool operator == (const RINSE_INFO_T & rhs) const
  {
    if (!(bEnable == rhs.bEnable))
      return false;
    if (!(bEnableWashA == rhs.bEnableWashA))
      return false;
    return true;
  }
  bool operator != (const RINSE_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RINSE_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RINSE_INFO_T &a, RINSE_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const RINSE_INFO_T& obj);

typedef struct _REAGENT_INFO_T__isset {
  _REAGENT_INFO_T__isset() : iR(false), iPosIndex(false), iBottleType(false), tPreRinseInfo(false), tPostRinseInfo(false), iAspriationVol(false), bEnableHeat(false), bEnableMixing(false), iMixingType(false), iMixingRate(false) {}
  bool iR :1;
  bool iPosIndex :1;
  bool iBottleType :1;
  bool tPreRinseInfo :1;
  bool tPostRinseInfo :1;
  bool iAspriationVol :1;
  bool bEnableHeat :1;
  bool bEnableMixing :1;
  bool iMixingType :1;
  bool iMixingRate :1;
} _REAGENT_INFO_T__isset;

class REAGENT_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  REAGENT_INFO_T(const REAGENT_INFO_T&);
  REAGENT_INFO_T& operator=(const REAGENT_INFO_T&);
  REAGENT_INFO_T() : iR(0), iPosIndex(0), iBottleType(0), iAspriationVol(0), bEnableHeat(0), bEnableMixing(0), iMixingType(0), iMixingRate(0) {
  }

  virtual ~REAGENT_INFO_T() throw();
  int32_t iR;
  int32_t iPosIndex;
  int32_t iBottleType;
  RINSE_INFO_T tPreRinseInfo;
  RINSE_INFO_T tPostRinseInfo;
  int32_t iAspriationVol;
  IBOOL bEnableHeat;
  IBOOL bEnableMixing;
  int32_t iMixingType;
  int32_t iMixingRate;

  _REAGENT_INFO_T__isset __isset;

  void __set_iR(const int32_t val);

  void __set_iPosIndex(const int32_t val);

  void __set_iBottleType(const int32_t val);

  void __set_tPreRinseInfo(const RINSE_INFO_T& val);

  void __set_tPostRinseInfo(const RINSE_INFO_T& val);

  void __set_iAspriationVol(const int32_t val);

  void __set_bEnableHeat(const IBOOL val);

  void __set_bEnableMixing(const IBOOL val);

  void __set_iMixingType(const int32_t val);

  void __set_iMixingRate(const int32_t val);

  bool operator == (const REAGENT_INFO_T & rhs) const
  {
    if (!(iR == rhs.iR))
      return false;
    if (!(iPosIndex == rhs.iPosIndex))
      return false;
    if (!(iBottleType == rhs.iBottleType))
      return false;
    if (!(tPreRinseInfo == rhs.tPreRinseInfo))
      return false;
    if (!(tPostRinseInfo == rhs.tPostRinseInfo))
      return false;
    if (!(iAspriationVol == rhs.iAspriationVol))
      return false;
    if (!(bEnableHeat == rhs.bEnableHeat))
      return false;
    if (!(bEnableMixing == rhs.bEnableMixing))
      return false;
    if (!(iMixingType == rhs.iMixingType))
      return false;
    if (!(iMixingRate == rhs.iMixingRate))
      return false;
    return true;
  }
  bool operator != (const REAGENT_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const REAGENT_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(REAGENT_INFO_T &a, REAGENT_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const REAGENT_INFO_T& obj);

typedef struct _DILUTION_FRACTION_T__isset {
  _DILUTION_FRACTION_T__isset() : iUp(false), iDown(false) {}
  bool iUp :1;
  bool iDown :1;
} _DILUTION_FRACTION_T__isset;

class DILUTION_FRACTION_T : public virtual ::apache::thrift::TBase {
 public:

  DILUTION_FRACTION_T(const DILUTION_FRACTION_T&);
  DILUTION_FRACTION_T& operator=(const DILUTION_FRACTION_T&);
  DILUTION_FRACTION_T() : iUp(0), iDown(0) {
  }

  virtual ~DILUTION_FRACTION_T() throw();
  int32_t iUp;
  int32_t iDown;

  _DILUTION_FRACTION_T__isset __isset;

  void __set_iUp(const int32_t val);

  void __set_iDown(const int32_t val);

  bool operator == (const DILUTION_FRACTION_T & rhs) const
  {
    if (!(iUp == rhs.iUp))
      return false;
    if (!(iDown == rhs.iDown))
      return false;
    return true;
  }
  bool operator != (const DILUTION_FRACTION_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DILUTION_FRACTION_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DILUTION_FRACTION_T &a, DILUTION_FRACTION_T &b);

std::ostream& operator<<(std::ostream& out, const DILUTION_FRACTION_T& obj);

typedef struct _ORDER_INFO_T__isset {
  _ORDER_INFO_T__isset() : iOrderNo(false), strAssayGroup(false), iOrderType(false), iMethod(false), iMagBeedClotPercent(false), iMagBeedDriveForce(false), iMagBeedMaxDetectSeconds(false), iMagBeedMinDetectSeconds(false), iOpticsMainMeasurementSeconds(false), iMainWavelenght(false), iGain(false), iOpticsSubMeasurementSeconds(false), iSubWavelenght(false), iSampleVolume(false), tDiluentRatio(false), iDiluentPos(false), tSamplePreRinseInfo(false), tSamplePostRinseInfo(false), bAddFactorDeficientPlasma(false), tFactorDeficientPlasmaInfo(false), lstIncuReagentInfos(false), iIncubationSeconds(false), lstDeteReagentInfos(false), iCalibratorIndex(false) {}
  bool iOrderNo :1;
  bool strAssayGroup :1;
  bool iOrderType :1;
  bool iMethod :1;
  bool iMagBeedClotPercent :1;
  bool iMagBeedDriveForce :1;
  bool iMagBeedMaxDetectSeconds :1;
  bool iMagBeedMinDetectSeconds :1;
  bool iOpticsMainMeasurementSeconds :1;
  bool iMainWavelenght :1;
  bool iGain :1;
  bool iOpticsSubMeasurementSeconds :1;
  bool iSubWavelenght :1;
  bool iSampleVolume :1;
  bool tDiluentRatio :1;
  bool iDiluentPos :1;
  bool tSamplePreRinseInfo :1;
  bool tSamplePostRinseInfo :1;
  bool bAddFactorDeficientPlasma :1;
  bool tFactorDeficientPlasmaInfo :1;
  bool lstIncuReagentInfos :1;
  bool iIncubationSeconds :1;
  bool lstDeteReagentInfos :1;
  bool iCalibratorIndex :1;
} _ORDER_INFO_T__isset;

class ORDER_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  ORDER_INFO_T(const ORDER_INFO_T&);
  ORDER_INFO_T& operator=(const ORDER_INFO_T&);
  ORDER_INFO_T() : iOrderNo(0), strAssayGroup(), iOrderType(0), iMethod(0), iMagBeedClotPercent(0), iMagBeedDriveForce(0), iMagBeedMaxDetectSeconds(0), iMagBeedMinDetectSeconds(0), iOpticsMainMeasurementSeconds(0), iMainWavelenght(0), iGain(0), iOpticsSubMeasurementSeconds(0), iSubWavelenght(0), iSampleVolume(0), iDiluentPos(0), bAddFactorDeficientPlasma(0), iIncubationSeconds(0), iCalibratorIndex(0) {
  }

  virtual ~ORDER_INFO_T() throw();
  int32_t iOrderNo;
  std::string strAssayGroup;
  int32_t iOrderType;
  int32_t iMethod;
  int32_t iMagBeedClotPercent;
  int32_t iMagBeedDriveForce;
  int32_t iMagBeedMaxDetectSeconds;
  int32_t iMagBeedMinDetectSeconds;
  int32_t iOpticsMainMeasurementSeconds;
  int32_t iMainWavelenght;
  int32_t iGain;
  int32_t iOpticsSubMeasurementSeconds;
  int32_t iSubWavelenght;
  int32_t iSampleVolume;
  DILUTION_FRACTION_T tDiluentRatio;
  int32_t iDiluentPos;
  RINSE_INFO_T tSamplePreRinseInfo;
  RINSE_INFO_T tSamplePostRinseInfo;
  IBOOL bAddFactorDeficientPlasma;
  REAGENT_INFO_T tFactorDeficientPlasmaInfo;
  std::vector<REAGENT_INFO_T>  lstIncuReagentInfos;
  int32_t iIncubationSeconds;
  std::vector<REAGENT_INFO_T>  lstDeteReagentInfos;
  int32_t iCalibratorIndex;

  _ORDER_INFO_T__isset __isset;

  void __set_iOrderNo(const int32_t val);

  void __set_strAssayGroup(const std::string& val);

  void __set_iOrderType(const int32_t val);

  void __set_iMethod(const int32_t val);

  void __set_iMagBeedClotPercent(const int32_t val);

  void __set_iMagBeedDriveForce(const int32_t val);

  void __set_iMagBeedMaxDetectSeconds(const int32_t val);

  void __set_iMagBeedMinDetectSeconds(const int32_t val);

  void __set_iOpticsMainMeasurementSeconds(const int32_t val);

  void __set_iMainWavelenght(const int32_t val);

  void __set_iGain(const int32_t val);

  void __set_iOpticsSubMeasurementSeconds(const int32_t val);

  void __set_iSubWavelenght(const int32_t val);

  void __set_iSampleVolume(const int32_t val);

  void __set_tDiluentRatio(const DILUTION_FRACTION_T& val);

  void __set_iDiluentPos(const int32_t val);

  void __set_tSamplePreRinseInfo(const RINSE_INFO_T& val);

  void __set_tSamplePostRinseInfo(const RINSE_INFO_T& val);

  void __set_bAddFactorDeficientPlasma(const IBOOL val);

  void __set_tFactorDeficientPlasmaInfo(const REAGENT_INFO_T& val);

  void __set_lstIncuReagentInfos(const std::vector<REAGENT_INFO_T> & val);

  void __set_iIncubationSeconds(const int32_t val);

  void __set_lstDeteReagentInfos(const std::vector<REAGENT_INFO_T> & val);

  void __set_iCalibratorIndex(const int32_t val);

  bool operator == (const ORDER_INFO_T & rhs) const
  {
    if (!(iOrderNo == rhs.iOrderNo))
      return false;
    if (!(strAssayGroup == rhs.strAssayGroup))
      return false;
    if (!(iOrderType == rhs.iOrderType))
      return false;
    if (!(iMethod == rhs.iMethod))
      return false;
    if (!(iMagBeedClotPercent == rhs.iMagBeedClotPercent))
      return false;
    if (!(iMagBeedDriveForce == rhs.iMagBeedDriveForce))
      return false;
    if (!(iMagBeedMaxDetectSeconds == rhs.iMagBeedMaxDetectSeconds))
      return false;
    if (!(iMagBeedMinDetectSeconds == rhs.iMagBeedMinDetectSeconds))
      return false;
    if (!(iOpticsMainMeasurementSeconds == rhs.iOpticsMainMeasurementSeconds))
      return false;
    if (!(iMainWavelenght == rhs.iMainWavelenght))
      return false;
    if (!(iGain == rhs.iGain))
      return false;
    if (!(iOpticsSubMeasurementSeconds == rhs.iOpticsSubMeasurementSeconds))
      return false;
    if (!(iSubWavelenght == rhs.iSubWavelenght))
      return false;
    if (!(iSampleVolume == rhs.iSampleVolume))
      return false;
    if (!(tDiluentRatio == rhs.tDiluentRatio))
      return false;
    if (!(iDiluentPos == rhs.iDiluentPos))
      return false;
    if (!(tSamplePreRinseInfo == rhs.tSamplePreRinseInfo))
      return false;
    if (!(tSamplePostRinseInfo == rhs.tSamplePostRinseInfo))
      return false;
    if (!(bAddFactorDeficientPlasma == rhs.bAddFactorDeficientPlasma))
      return false;
    if (!(tFactorDeficientPlasmaInfo == rhs.tFactorDeficientPlasmaInfo))
      return false;
    if (!(lstIncuReagentInfos == rhs.lstIncuReagentInfos))
      return false;
    if (!(iIncubationSeconds == rhs.iIncubationSeconds))
      return false;
    if (!(lstDeteReagentInfos == rhs.lstDeteReagentInfos))
      return false;
    if (!(iCalibratorIndex == rhs.iCalibratorIndex))
      return false;
    return true;
  }
  bool operator != (const ORDER_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ORDER_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ORDER_INFO_T &a, ORDER_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const ORDER_INFO_T& obj);

typedef struct _SAMPLE_QUALITY_SET_INFO_T__isset {
  _SAMPLE_QUALITY_SET_INFO_T__isset() : bIsCheckAnticoagulationRatio(false), iAnticoagulationRatioHandlingMode(false), dTubeInsideDiameter(false), dBloodCapacity(false), dBloodCapacityFloat(false), bIsCheckClot(false), iClotSensitivity(false), iClotHandlingMode(false) {}
  bool bIsCheckAnticoagulationRatio :1;
  bool iAnticoagulationRatioHandlingMode :1;
  bool dTubeInsideDiameter :1;
  bool dBloodCapacity :1;
  bool dBloodCapacityFloat :1;
  bool bIsCheckClot :1;
  bool iClotSensitivity :1;
  bool iClotHandlingMode :1;
} _SAMPLE_QUALITY_SET_INFO_T__isset;

class SAMPLE_QUALITY_SET_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  SAMPLE_QUALITY_SET_INFO_T(const SAMPLE_QUALITY_SET_INFO_T&);
  SAMPLE_QUALITY_SET_INFO_T& operator=(const SAMPLE_QUALITY_SET_INFO_T&);
  SAMPLE_QUALITY_SET_INFO_T() : bIsCheckAnticoagulationRatio(0), iAnticoagulationRatioHandlingMode(0), dTubeInsideDiameter(0), dBloodCapacity(0), dBloodCapacityFloat(0), bIsCheckClot(0), iClotSensitivity(0), iClotHandlingMode(0) {
  }

  virtual ~SAMPLE_QUALITY_SET_INFO_T() throw();
  IBOOL bIsCheckAnticoagulationRatio;
  int32_t iAnticoagulationRatioHandlingMode;
  double dTubeInsideDiameter;
  double dBloodCapacity;
  double dBloodCapacityFloat;
  IBOOL bIsCheckClot;
  int32_t iClotSensitivity;
  int32_t iClotHandlingMode;

  _SAMPLE_QUALITY_SET_INFO_T__isset __isset;

  void __set_bIsCheckAnticoagulationRatio(const IBOOL val);

  void __set_iAnticoagulationRatioHandlingMode(const int32_t val);

  void __set_dTubeInsideDiameter(const double val);

  void __set_dBloodCapacity(const double val);

  void __set_dBloodCapacityFloat(const double val);

  void __set_bIsCheckClot(const IBOOL val);

  void __set_iClotSensitivity(const int32_t val);

  void __set_iClotHandlingMode(const int32_t val);

  bool operator == (const SAMPLE_QUALITY_SET_INFO_T & rhs) const
  {
    if (!(bIsCheckAnticoagulationRatio == rhs.bIsCheckAnticoagulationRatio))
      return false;
    if (!(iAnticoagulationRatioHandlingMode == rhs.iAnticoagulationRatioHandlingMode))
      return false;
    if (!(dTubeInsideDiameter == rhs.dTubeInsideDiameter))
      return false;
    if (!(dBloodCapacity == rhs.dBloodCapacity))
      return false;
    if (!(dBloodCapacityFloat == rhs.dBloodCapacityFloat))
      return false;
    if (!(bIsCheckClot == rhs.bIsCheckClot))
      return false;
    if (!(iClotSensitivity == rhs.iClotSensitivity))
      return false;
    if (!(iClotHandlingMode == rhs.iClotHandlingMode))
      return false;
    return true;
  }
  bool operator != (const SAMPLE_QUALITY_SET_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SAMPLE_QUALITY_SET_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SAMPLE_QUALITY_SET_INFO_T &a, SAMPLE_QUALITY_SET_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const SAMPLE_QUALITY_SET_INFO_T& obj);

typedef struct _SAMPLE_ORDER_INFO_T__isset {
  _SAMPLE_ORDER_INFO_T__isset() : iSampleOrderNo(false), tSampleQualitySet(false), eSampleTubeType(false), iSlotNo(false), iRackIndex(false), iSamplePosIndex(false), iPriority(false), lstOrderInfo(false) {}
  bool iSampleOrderNo :1;
  bool tSampleQualitySet :1;
  bool eSampleTubeType :1;
  bool iSlotNo :1;
  bool iRackIndex :1;
  bool iSamplePosIndex :1;
  bool iPriority :1;
  bool lstOrderInfo :1;
} _SAMPLE_ORDER_INFO_T__isset;

class SAMPLE_ORDER_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  SAMPLE_ORDER_INFO_T(const SAMPLE_ORDER_INFO_T&);
  SAMPLE_ORDER_INFO_T& operator=(const SAMPLE_ORDER_INFO_T&);
  SAMPLE_ORDER_INFO_T() : iSampleOrderNo(0), eSampleTubeType((SAMPLE_TUBE_TYPE::type)0), iSlotNo(0), iRackIndex(0), iSamplePosIndex(0), iPriority(0) {
  }

  virtual ~SAMPLE_ORDER_INFO_T() throw();
  int32_t iSampleOrderNo;
  SAMPLE_QUALITY_SET_INFO_T tSampleQualitySet;
  SAMPLE_TUBE_TYPE::type eSampleTubeType;
  int32_t iSlotNo;
  int32_t iRackIndex;
  int32_t iSamplePosIndex;
  int32_t iPriority;
  std::vector<ORDER_INFO_T>  lstOrderInfo;

  _SAMPLE_ORDER_INFO_T__isset __isset;

  void __set_iSampleOrderNo(const int32_t val);

  void __set_tSampleQualitySet(const SAMPLE_QUALITY_SET_INFO_T& val);

  void __set_eSampleTubeType(const SAMPLE_TUBE_TYPE::type val);

  void __set_iSlotNo(const int32_t val);

  void __set_iRackIndex(const int32_t val);

  void __set_iSamplePosIndex(const int32_t val);

  void __set_iPriority(const int32_t val);

  void __set_lstOrderInfo(const std::vector<ORDER_INFO_T> & val);

  bool operator == (const SAMPLE_ORDER_INFO_T & rhs) const
  {
    if (!(iSampleOrderNo == rhs.iSampleOrderNo))
      return false;
    if (!(tSampleQualitySet == rhs.tSampleQualitySet))
      return false;
    if (!(eSampleTubeType == rhs.eSampleTubeType))
      return false;
    if (!(iSlotNo == rhs.iSlotNo))
      return false;
    if (!(iRackIndex == rhs.iRackIndex))
      return false;
    if (!(iSamplePosIndex == rhs.iSamplePosIndex))
      return false;
    if (!(iPriority == rhs.iPriority))
      return false;
    if (!(lstOrderInfo == rhs.lstOrderInfo))
      return false;
    return true;
  }
  bool operator != (const SAMPLE_ORDER_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SAMPLE_ORDER_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SAMPLE_ORDER_INFO_T &a, SAMPLE_ORDER_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const SAMPLE_ORDER_INFO_T& obj);

typedef struct _SAMPLE_QUALITY_T__isset {
  _SAMPLE_QUALITY_T__isset() : bIsCheckAnticoagulationRatio(false), bIsARError(false), bIsCheckClot(false), bIsClotError(false) {}
  bool bIsCheckAnticoagulationRatio :1;
  bool bIsARError :1;
  bool bIsCheckClot :1;
  bool bIsClotError :1;
} _SAMPLE_QUALITY_T__isset;

class SAMPLE_QUALITY_T : public virtual ::apache::thrift::TBase {
 public:

  SAMPLE_QUALITY_T(const SAMPLE_QUALITY_T&);
  SAMPLE_QUALITY_T& operator=(const SAMPLE_QUALITY_T&);
  SAMPLE_QUALITY_T() : bIsCheckAnticoagulationRatio(0), bIsARError(0), bIsCheckClot(0), bIsClotError(0) {
  }

  virtual ~SAMPLE_QUALITY_T() throw();
  IBOOL bIsCheckAnticoagulationRatio;
  IBOOL bIsARError;
  IBOOL bIsCheckClot;
  IBOOL bIsClotError;

  _SAMPLE_QUALITY_T__isset __isset;

  void __set_bIsCheckAnticoagulationRatio(const IBOOL val);

  void __set_bIsARError(const IBOOL val);

  void __set_bIsCheckClot(const IBOOL val);

  void __set_bIsClotError(const IBOOL val);

  bool operator == (const SAMPLE_QUALITY_T & rhs) const
  {
    if (!(bIsCheckAnticoagulationRatio == rhs.bIsCheckAnticoagulationRatio))
      return false;
    if (!(bIsARError == rhs.bIsARError))
      return false;
    if (!(bIsCheckClot == rhs.bIsCheckClot))
      return false;
    if (!(bIsClotError == rhs.bIsClotError))
      return false;
    return true;
  }
  bool operator != (const SAMPLE_QUALITY_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SAMPLE_QUALITY_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SAMPLE_QUALITY_T &a, SAMPLE_QUALITY_T &b);

std::ostream& operator<<(std::ostream& out, const SAMPLE_QUALITY_T& obj);

typedef struct _BOOT_PARAM_T__isset {
  _BOOT_PARAM_T__isset() : iWeek(false), iHour(false), iMinute(false), bEnable(false) {}
  bool iWeek :1;
  bool iHour :1;
  bool iMinute :1;
  bool bEnable :1;
} _BOOT_PARAM_T__isset;

class BOOT_PARAM_T : public virtual ::apache::thrift::TBase {
 public:

  BOOT_PARAM_T(const BOOT_PARAM_T&);
  BOOT_PARAM_T& operator=(const BOOT_PARAM_T&);
  BOOT_PARAM_T() : iWeek(0), iHour(0), iMinute(0), bEnable(0) {
  }

  virtual ~BOOT_PARAM_T() throw();
  int32_t iWeek;
  int32_t iHour;
  int32_t iMinute;
  IBOOL bEnable;

  _BOOT_PARAM_T__isset __isset;

  void __set_iWeek(const int32_t val);

  void __set_iHour(const int32_t val);

  void __set_iMinute(const int32_t val);

  void __set_bEnable(const IBOOL val);

  bool operator == (const BOOT_PARAM_T & rhs) const
  {
    if (!(iWeek == rhs.iWeek))
      return false;
    if (!(iHour == rhs.iHour))
      return false;
    if (!(iMinute == rhs.iMinute))
      return false;
    if (!(bEnable == rhs.bEnable))
      return false;
    return true;
  }
  bool operator != (const BOOT_PARAM_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BOOT_PARAM_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BOOT_PARAM_T &a, BOOT_PARAM_T &b);

std::ostream& operator<<(std::ostream& out, const BOOT_PARAM_T& obj);

typedef struct _PIPELINE_FILL_INFO_T__isset {
  _PIPELINE_FILL_INFO_T__isset() : tSampleRinseInfo(false), tReagnet1RinseInfo(false), tReagnet2RinseInfo(false) {}
  bool tSampleRinseInfo :1;
  bool tReagnet1RinseInfo :1;
  bool tReagnet2RinseInfo :1;
} _PIPELINE_FILL_INFO_T__isset;

class PIPELINE_FILL_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  PIPELINE_FILL_INFO_T(const PIPELINE_FILL_INFO_T&);
  PIPELINE_FILL_INFO_T& operator=(const PIPELINE_FILL_INFO_T&);
  PIPELINE_FILL_INFO_T() {
  }

  virtual ~PIPELINE_FILL_INFO_T() throw();
  RINSE_INFO_T tSampleRinseInfo;
  RINSE_INFO_T tReagnet1RinseInfo;
  RINSE_INFO_T tReagnet2RinseInfo;

  _PIPELINE_FILL_INFO_T__isset __isset;

  void __set_tSampleRinseInfo(const RINSE_INFO_T& val);

  void __set_tReagnet1RinseInfo(const RINSE_INFO_T& val);

  void __set_tReagnet2RinseInfo(const RINSE_INFO_T& val);

  bool operator == (const PIPELINE_FILL_INFO_T & rhs) const
  {
    if (!(tSampleRinseInfo == rhs.tSampleRinseInfo))
      return false;
    if (!(tReagnet1RinseInfo == rhs.tReagnet1RinseInfo))
      return false;
    if (!(tReagnet2RinseInfo == rhs.tReagnet2RinseInfo))
      return false;
    return true;
  }
  bool operator != (const PIPELINE_FILL_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PIPELINE_FILL_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PIPELINE_FILL_INFO_T &a, PIPELINE_FILL_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const PIPELINE_FILL_INFO_T& obj);

typedef struct _REAGENT_POS_INFO_T__isset {
  _REAGENT_POS_INFO_T__isset() : iPosIndex(false), iIsRemainDetect(false), iBottleType(false), strReagentName(false), strReagentLot(false), iReagentSerialNo(false), iReagentCategory(false), iRx(false), iBottleMaterial(false) {}
  bool iPosIndex :1;
  bool iIsRemainDetect :1;
  bool iBottleType :1;
  bool strReagentName :1;
  bool strReagentLot :1;
  bool iReagentSerialNo :1;
  bool iReagentCategory :1;
  bool iRx :1;
  bool iBottleMaterial :1;
} _REAGENT_POS_INFO_T__isset;

class REAGENT_POS_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  REAGENT_POS_INFO_T(const REAGENT_POS_INFO_T&);
  REAGENT_POS_INFO_T& operator=(const REAGENT_POS_INFO_T&);
  REAGENT_POS_INFO_T() : iPosIndex(0), iIsRemainDetect(0), iBottleType(0), strReagentName(), strReagentLot(), iReagentSerialNo(0), iReagentCategory(0), iRx(0), iBottleMaterial(0) {
  }

  virtual ~REAGENT_POS_INFO_T() throw();
  int32_t iPosIndex;
  int32_t iIsRemainDetect;
  int32_t iBottleType;
  std::string strReagentName;
  std::string strReagentLot;
  int32_t iReagentSerialNo;
  int32_t iReagentCategory;
  int32_t iRx;
  int32_t iBottleMaterial;

  _REAGENT_POS_INFO_T__isset __isset;

  void __set_iPosIndex(const int32_t val);

  void __set_iIsRemainDetect(const int32_t val);

  void __set_iBottleType(const int32_t val);

  void __set_strReagentName(const std::string& val);

  void __set_strReagentLot(const std::string& val);

  void __set_iReagentSerialNo(const int32_t val);

  void __set_iReagentCategory(const int32_t val);

  void __set_iRx(const int32_t val);

  void __set_iBottleMaterial(const int32_t val);

  bool operator == (const REAGENT_POS_INFO_T & rhs) const
  {
    if (!(iPosIndex == rhs.iPosIndex))
      return false;
    if (!(iIsRemainDetect == rhs.iIsRemainDetect))
      return false;
    if (!(iBottleType == rhs.iBottleType))
      return false;
    if (!(strReagentName == rhs.strReagentName))
      return false;
    if (!(strReagentLot == rhs.strReagentLot))
      return false;
    if (!(iReagentSerialNo == rhs.iReagentSerialNo))
      return false;
    if (!(iReagentCategory == rhs.iReagentCategory))
      return false;
    if (!(iRx == rhs.iRx))
      return false;
    if (!(iBottleMaterial == rhs.iBottleMaterial))
      return false;
    return true;
  }
  bool operator != (const REAGENT_POS_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const REAGENT_POS_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(REAGENT_POS_INFO_T &a, REAGENT_POS_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const REAGENT_POS_INFO_T& obj);

typedef struct _REAGENT_MIX_INFO_T__isset {
  _REAGENT_MIX_INFO_T__isset() : iPosIndex(false), iMixingType(false), iBottleType(false), strReagentName(false), strReagentLot(false), iReagentSerialNo(false), iReagentCategory(false), iRx(false) {}
  bool iPosIndex :1;
  bool iMixingType :1;
  bool iBottleType :1;
  bool strReagentName :1;
  bool strReagentLot :1;
  bool iReagentSerialNo :1;
  bool iReagentCategory :1;
  bool iRx :1;
} _REAGENT_MIX_INFO_T__isset;

class REAGENT_MIX_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  REAGENT_MIX_INFO_T(const REAGENT_MIX_INFO_T&);
  REAGENT_MIX_INFO_T& operator=(const REAGENT_MIX_INFO_T&);
  REAGENT_MIX_INFO_T() : iPosIndex(0), iMixingType(0), iBottleType(0), strReagentName(), strReagentLot(), iReagentSerialNo(0), iReagentCategory(0), iRx(0) {
  }

  virtual ~REAGENT_MIX_INFO_T() throw();
  int32_t iPosIndex;
  int32_t iMixingType;
  int32_t iBottleType;
  std::string strReagentName;
  std::string strReagentLot;
  int32_t iReagentSerialNo;
  int32_t iReagentCategory;
  int32_t iRx;

  _REAGENT_MIX_INFO_T__isset __isset;

  void __set_iPosIndex(const int32_t val);

  void __set_iMixingType(const int32_t val);

  void __set_iBottleType(const int32_t val);

  void __set_strReagentName(const std::string& val);

  void __set_strReagentLot(const std::string& val);

  void __set_iReagentSerialNo(const int32_t val);

  void __set_iReagentCategory(const int32_t val);

  void __set_iRx(const int32_t val);

  bool operator == (const REAGENT_MIX_INFO_T & rhs) const
  {
    if (!(iPosIndex == rhs.iPosIndex))
      return false;
    if (!(iMixingType == rhs.iMixingType))
      return false;
    if (!(iBottleType == rhs.iBottleType))
      return false;
    if (!(strReagentName == rhs.strReagentName))
      return false;
    if (!(strReagentLot == rhs.strReagentLot))
      return false;
    if (!(iReagentSerialNo == rhs.iReagentSerialNo))
      return false;
    if (!(iReagentCategory == rhs.iReagentCategory))
      return false;
    if (!(iRx == rhs.iRx))
      return false;
    return true;
  }
  bool operator != (const REAGENT_MIX_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const REAGENT_MIX_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(REAGENT_MIX_INFO_T &a, REAGENT_MIX_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const REAGENT_MIX_INFO_T& obj);

typedef struct _SAMPLE_TUBE_INFO_T__isset {
  _SAMPLE_TUBE_INFO_T__isset() : iSlotNo(false), iRackIndex(false), iPosIndex(false), bScanStatus(false), bExist(false), barcode(false), iTubeType(false), iIsExistCap(false) {}
  bool iSlotNo :1;
  bool iRackIndex :1;
  bool iPosIndex :1;
  bool bScanStatus :1;
  bool bExist :1;
  bool barcode :1;
  bool iTubeType :1;
  bool iIsExistCap :1;
} _SAMPLE_TUBE_INFO_T__isset;

class SAMPLE_TUBE_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  SAMPLE_TUBE_INFO_T(const SAMPLE_TUBE_INFO_T&);
  SAMPLE_TUBE_INFO_T& operator=(const SAMPLE_TUBE_INFO_T&);
  SAMPLE_TUBE_INFO_T() : iSlotNo(0), iRackIndex(0), iPosIndex(0), bScanStatus(0), bExist(0), barcode(), iTubeType(0), iIsExistCap(0) {
  }

  virtual ~SAMPLE_TUBE_INFO_T() throw();
  int32_t iSlotNo;
  int32_t iRackIndex;
  int32_t iPosIndex;
  IBOOL bScanStatus;
  IBOOL bExist;
  std::string barcode;
  int32_t iTubeType;
  int32_t iIsExistCap;

  _SAMPLE_TUBE_INFO_T__isset __isset;

  void __set_iSlotNo(const int32_t val);

  void __set_iRackIndex(const int32_t val);

  void __set_iPosIndex(const int32_t val);

  void __set_bScanStatus(const IBOOL val);

  void __set_bExist(const IBOOL val);

  void __set_barcode(const std::string& val);

  void __set_iTubeType(const int32_t val);

  void __set_iIsExistCap(const int32_t val);

  bool operator == (const SAMPLE_TUBE_INFO_T & rhs) const
  {
    if (!(iSlotNo == rhs.iSlotNo))
      return false;
    if (!(iRackIndex == rhs.iRackIndex))
      return false;
    if (!(iPosIndex == rhs.iPosIndex))
      return false;
    if (!(bScanStatus == rhs.bScanStatus))
      return false;
    if (!(bExist == rhs.bExist))
      return false;
    if (!(barcode == rhs.barcode))
      return false;
    if (!(iTubeType == rhs.iTubeType))
      return false;
    if (!(iIsExistCap == rhs.iIsExistCap))
      return false;
    return true;
  }
  bool operator != (const SAMPLE_TUBE_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SAMPLE_TUBE_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SAMPLE_TUBE_INFO_T &a, SAMPLE_TUBE_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const SAMPLE_TUBE_INFO_T& obj);

typedef struct _RESULT_INFO_T__isset {
  _RESULT_INFO_T__isset() : eResultState(false), iDetectPos(false), iClotTime(false), lstADData(false), lstSubADData(false), strCupLotNo(false), iCupSerialNo(false) {}
  bool eResultState :1;
  bool iDetectPos :1;
  bool iClotTime :1;
  bool lstADData :1;
  bool lstSubADData :1;
  bool strCupLotNo :1;
  bool iCupSerialNo :1;
} _RESULT_INFO_T__isset;

class RESULT_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  RESULT_INFO_T(const RESULT_INFO_T&);
  RESULT_INFO_T& operator=(const RESULT_INFO_T&);
  RESULT_INFO_T() : eResultState((RESULT_STATE::type)0), iDetectPos(0), iClotTime(0), strCupLotNo(), iCupSerialNo(0) {
  }

  virtual ~RESULT_INFO_T() throw();
  RESULT_STATE::type eResultState;
  int32_t iDetectPos;
  int32_t iClotTime;
  std::vector<int32_t>  lstADData;
  std::vector<int32_t>  lstSubADData;
  std::string strCupLotNo;
  int32_t iCupSerialNo;

  _RESULT_INFO_T__isset __isset;

  void __set_eResultState(const RESULT_STATE::type val);

  void __set_iDetectPos(const int32_t val);

  void __set_iClotTime(const int32_t val);

  void __set_lstADData(const std::vector<int32_t> & val);

  void __set_lstSubADData(const std::vector<int32_t> & val);

  void __set_strCupLotNo(const std::string& val);

  void __set_iCupSerialNo(const int32_t val);

  bool operator == (const RESULT_INFO_T & rhs) const
  {
    if (!(eResultState == rhs.eResultState))
      return false;
    if (!(iDetectPos == rhs.iDetectPos))
      return false;
    if (!(iClotTime == rhs.iClotTime))
      return false;
    if (!(lstADData == rhs.lstADData))
      return false;
    if (!(lstSubADData == rhs.lstSubADData))
      return false;
    if (!(strCupLotNo == rhs.strCupLotNo))
      return false;
    if (!(iCupSerialNo == rhs.iCupSerialNo))
      return false;
    return true;
  }
  bool operator != (const RESULT_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RESULT_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RESULT_INFO_T &a, RESULT_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const RESULT_INFO_T& obj);

typedef struct _ASYNC_RETURN_T__isset {
  _ASYNC_RETURN_T__isset() : iReturnType(false), iReturn(false), dReturn(false), strReturn(false) {}
  bool iReturnType :1;
  bool iReturn :1;
  bool dReturn :1;
  bool strReturn :1;
} _ASYNC_RETURN_T__isset;

class ASYNC_RETURN_T : public virtual ::apache::thrift::TBase {
 public:

  ASYNC_RETURN_T(const ASYNC_RETURN_T&);
  ASYNC_RETURN_T& operator=(const ASYNC_RETURN_T&);
  ASYNC_RETURN_T() : iReturnType(0), iReturn(0), dReturn(0), strReturn() {
  }

  virtual ~ASYNC_RETURN_T() throw();
  int32_t iReturnType;
  int32_t iReturn;
  double dReturn;
  std::string strReturn;

  _ASYNC_RETURN_T__isset __isset;

  void __set_iReturnType(const int32_t val);

  void __set_iReturn(const int32_t val);

  void __set_dReturn(const double val);

  void __set_strReturn(const std::string& val);

  bool operator == (const ASYNC_RETURN_T & rhs) const
  {
    if (!(iReturnType == rhs.iReturnType))
      return false;
    if (!(iReturn == rhs.iReturn))
      return false;
    if (!(dReturn == rhs.dReturn))
      return false;
    if (!(strReturn == rhs.strReturn))
      return false;
    return true;
  }
  bool operator != (const ASYNC_RETURN_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ASYNC_RETURN_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ASYNC_RETURN_T &a, ASYNC_RETURN_T &b);

std::ostream& operator<<(std::ostream& out, const ASYNC_RETURN_T& obj);

typedef struct _THRIFT_MOTOR_PARA_T__isset {
  _THRIFT_MOTOR_PARA_T__isset() : iMotorID(false), iSpeed(false), iAcc(false) {}
  bool iMotorID :1;
  bool iSpeed :1;
  bool iAcc :1;
} _THRIFT_MOTOR_PARA_T__isset;

class THRIFT_MOTOR_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  THRIFT_MOTOR_PARA_T(const THRIFT_MOTOR_PARA_T&);
  THRIFT_MOTOR_PARA_T& operator=(const THRIFT_MOTOR_PARA_T&);
  THRIFT_MOTOR_PARA_T() : iMotorID(0), iSpeed(0), iAcc(0) {
  }

  virtual ~THRIFT_MOTOR_PARA_T() throw();
  int32_t iMotorID;
  int32_t iSpeed;
  int32_t iAcc;

  _THRIFT_MOTOR_PARA_T__isset __isset;

  void __set_iMotorID(const int32_t val);

  void __set_iSpeed(const int32_t val);

  void __set_iAcc(const int32_t val);

  bool operator == (const THRIFT_MOTOR_PARA_T & rhs) const
  {
    if (!(iMotorID == rhs.iMotorID))
      return false;
    if (!(iSpeed == rhs.iSpeed))
      return false;
    if (!(iAcc == rhs.iAcc))
      return false;
    return true;
  }
  bool operator != (const THRIFT_MOTOR_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THRIFT_MOTOR_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THRIFT_MOTOR_PARA_T &a, THRIFT_MOTOR_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const THRIFT_MOTOR_PARA_T& obj);

typedef struct _DATE_TIME_T__isset {
  _DATE_TIME_T__isset() : iYear(false), iMonth(false), iDayOfWeek(false), iDay(false), iHour(false), iMinute(false), iSecond(false) {}
  bool iYear :1;
  bool iMonth :1;
  bool iDayOfWeek :1;
  bool iDay :1;
  bool iHour :1;
  bool iMinute :1;
  bool iSecond :1;
} _DATE_TIME_T__isset;

class DATE_TIME_T : public virtual ::apache::thrift::TBase {
 public:

  DATE_TIME_T(const DATE_TIME_T&);
  DATE_TIME_T& operator=(const DATE_TIME_T&);
  DATE_TIME_T() : iYear(0), iMonth(0), iDayOfWeek(0), iDay(0), iHour(0), iMinute(0), iSecond(0) {
  }

  virtual ~DATE_TIME_T() throw();
  int32_t iYear;
  int32_t iMonth;
  int32_t iDayOfWeek;
  int32_t iDay;
  int32_t iHour;
  int32_t iMinute;
  int32_t iSecond;

  _DATE_TIME_T__isset __isset;

  void __set_iYear(const int32_t val);

  void __set_iMonth(const int32_t val);

  void __set_iDayOfWeek(const int32_t val);

  void __set_iDay(const int32_t val);

  void __set_iHour(const int32_t val);

  void __set_iMinute(const int32_t val);

  void __set_iSecond(const int32_t val);

  bool operator == (const DATE_TIME_T & rhs) const
  {
    if (!(iYear == rhs.iYear))
      return false;
    if (!(iMonth == rhs.iMonth))
      return false;
    if (!(iDayOfWeek == rhs.iDayOfWeek))
      return false;
    if (!(iDay == rhs.iDay))
      return false;
    if (!(iHour == rhs.iHour))
      return false;
    if (!(iMinute == rhs.iMinute))
      return false;
    if (!(iSecond == rhs.iSecond))
      return false;
    return true;
  }
  bool operator != (const DATE_TIME_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DATE_TIME_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DATE_TIME_T &a, DATE_TIME_T &b);

std::ostream& operator<<(std::ostream& out, const DATE_TIME_T& obj);

typedef struct _CONSUMABLES_INFO_T__isset {
  _CONSUMABLES_INFO_T__isset() : iConsumableType(false), iEnable(false), iIndex(false), iPriorityOfUse(false), strLotNo(false), iSerialNo(false), bInit(false) {}
  bool iConsumableType :1;
  bool iEnable :1;
  bool iIndex :1;
  bool iPriorityOfUse :1;
  bool strLotNo :1;
  bool iSerialNo :1;
  bool bInit :1;
} _CONSUMABLES_INFO_T__isset;

class CONSUMABLES_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  CONSUMABLES_INFO_T(const CONSUMABLES_INFO_T&);
  CONSUMABLES_INFO_T& operator=(const CONSUMABLES_INFO_T&);
  CONSUMABLES_INFO_T() : iConsumableType((REAGENT_SUPPLY_TYPE::type)0), iEnable(0), iIndex(0), iPriorityOfUse(0), strLotNo(), iSerialNo(0), bInit(0) {
  }

  virtual ~CONSUMABLES_INFO_T() throw();
  REAGENT_SUPPLY_TYPE::type iConsumableType;
  int32_t iEnable;
  int32_t iIndex;
  int32_t iPriorityOfUse;
  std::string strLotNo;
  int32_t iSerialNo;
  IBOOL bInit;

  _CONSUMABLES_INFO_T__isset __isset;

  void __set_iConsumableType(const REAGENT_SUPPLY_TYPE::type val);

  void __set_iEnable(const int32_t val);

  void __set_iIndex(const int32_t val);

  void __set_iPriorityOfUse(const int32_t val);

  void __set_strLotNo(const std::string& val);

  void __set_iSerialNo(const int32_t val);

  void __set_bInit(const IBOOL val);

  bool operator == (const CONSUMABLES_INFO_T & rhs) const
  {
    if (!(iConsumableType == rhs.iConsumableType))
      return false;
    if (!(iEnable == rhs.iEnable))
      return false;
    if (!(iIndex == rhs.iIndex))
      return false;
    if (!(iPriorityOfUse == rhs.iPriorityOfUse))
      return false;
    if (!(strLotNo == rhs.strLotNo))
      return false;
    if (!(iSerialNo == rhs.iSerialNo))
      return false;
    if (!(bInit == rhs.bInit))
      return false;
    return true;
  }
  bool operator != (const CONSUMABLES_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CONSUMABLES_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CONSUMABLES_INFO_T &a, CONSUMABLES_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const CONSUMABLES_INFO_T& obj);

typedef struct _REAGENT_SCAN_INFO_T__isset {
  _REAGENT_SCAN_INFO_T__isset() : iReagBracketIndex(false), iIsReagBracketExist(false), iReagPosIndex(false), iExistStatus(false), strBarcode(false) {}
  bool iReagBracketIndex :1;
  bool iIsReagBracketExist :1;
  bool iReagPosIndex :1;
  bool iExistStatus :1;
  bool strBarcode :1;
} _REAGENT_SCAN_INFO_T__isset;

class REAGENT_SCAN_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  REAGENT_SCAN_INFO_T(const REAGENT_SCAN_INFO_T&);
  REAGENT_SCAN_INFO_T& operator=(const REAGENT_SCAN_INFO_T&);
  REAGENT_SCAN_INFO_T() : iReagBracketIndex(0), iIsReagBracketExist(0), iReagPosIndex(0), iExistStatus(0), strBarcode() {
  }

  virtual ~REAGENT_SCAN_INFO_T() throw();
  int32_t iReagBracketIndex;
  int32_t iIsReagBracketExist;
  int32_t iReagPosIndex;
  int32_t iExistStatus;
  std::string strBarcode;

  _REAGENT_SCAN_INFO_T__isset __isset;

  void __set_iReagBracketIndex(const int32_t val);

  void __set_iIsReagBracketExist(const int32_t val);

  void __set_iReagPosIndex(const int32_t val);

  void __set_iExistStatus(const int32_t val);

  void __set_strBarcode(const std::string& val);

  bool operator == (const REAGENT_SCAN_INFO_T & rhs) const
  {
    if (!(iReagBracketIndex == rhs.iReagBracketIndex))
      return false;
    if (!(iIsReagBracketExist == rhs.iIsReagBracketExist))
      return false;
    if (!(iReagPosIndex == rhs.iReagPosIndex))
      return false;
    if (!(iExistStatus == rhs.iExistStatus))
      return false;
    if (!(strBarcode == rhs.strBarcode))
      return false;
    return true;
  }
  bool operator != (const REAGENT_SCAN_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const REAGENT_SCAN_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(REAGENT_SCAN_INFO_T &a, REAGENT_SCAN_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const REAGENT_SCAN_INFO_T& obj);

typedef struct _ENGINEER_DEBUG_VIRTUAL_POS_PARA_T__isset {
  _ENGINEER_DEBUG_VIRTUAL_POS_PARA_T__isset() : iModuleIndex(false), iVirtualPosIndex(false), strVirtualPosName(false), iEnableR(false), iR_Steps(false), iR_MaxSteps(false), iEnableX(false), iX_Steps(false), iX_MaxSteps(false), iEnableY(false), iY_Steps(false), iY_MaxSteps(false), iEnableZ(false), iZ_Steps(false), iZ_MaxSteps(false) {}
  bool iModuleIndex :1;
  bool iVirtualPosIndex :1;
  bool strVirtualPosName :1;
  bool iEnableR :1;
  bool iR_Steps :1;
  bool iR_MaxSteps :1;
  bool iEnableX :1;
  bool iX_Steps :1;
  bool iX_MaxSteps :1;
  bool iEnableY :1;
  bool iY_Steps :1;
  bool iY_MaxSteps :1;
  bool iEnableZ :1;
  bool iZ_Steps :1;
  bool iZ_MaxSteps :1;
} _ENGINEER_DEBUG_VIRTUAL_POS_PARA_T__isset;

class ENGINEER_DEBUG_VIRTUAL_POS_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T&);
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& operator=(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T&);
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T() : iModuleIndex(0), iVirtualPosIndex(0), strVirtualPosName(), iEnableR(0), iR_Steps(0), iR_MaxSteps(0), iEnableX(0), iX_Steps(0), iX_MaxSteps(0), iEnableY(0), iY_Steps(0), iY_MaxSteps(0), iEnableZ(0), iZ_Steps(0), iZ_MaxSteps(0) {
  }

  virtual ~ENGINEER_DEBUG_VIRTUAL_POS_PARA_T() throw();
  int32_t iModuleIndex;
  int32_t iVirtualPosIndex;
  std::string strVirtualPosName;
  int32_t iEnableR;
  int32_t iR_Steps;
  int32_t iR_MaxSteps;
  int32_t iEnableX;
  int32_t iX_Steps;
  int32_t iX_MaxSteps;
  int32_t iEnableY;
  int32_t iY_Steps;
  int32_t iY_MaxSteps;
  int32_t iEnableZ;
  int32_t iZ_Steps;
  int32_t iZ_MaxSteps;

  _ENGINEER_DEBUG_VIRTUAL_POS_PARA_T__isset __isset;

  void __set_iModuleIndex(const int32_t val);

  void __set_iVirtualPosIndex(const int32_t val);

  void __set_strVirtualPosName(const std::string& val);

  void __set_iEnableR(const int32_t val);

  void __set_iR_Steps(const int32_t val);

  void __set_iR_MaxSteps(const int32_t val);

  void __set_iEnableX(const int32_t val);

  void __set_iX_Steps(const int32_t val);

  void __set_iX_MaxSteps(const int32_t val);

  void __set_iEnableY(const int32_t val);

  void __set_iY_Steps(const int32_t val);

  void __set_iY_MaxSteps(const int32_t val);

  void __set_iEnableZ(const int32_t val);

  void __set_iZ_Steps(const int32_t val);

  void __set_iZ_MaxSteps(const int32_t val);

  bool operator == (const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T & rhs) const
  {
    if (!(iModuleIndex == rhs.iModuleIndex))
      return false;
    if (!(iVirtualPosIndex == rhs.iVirtualPosIndex))
      return false;
    if (!(strVirtualPosName == rhs.strVirtualPosName))
      return false;
    if (!(iEnableR == rhs.iEnableR))
      return false;
    if (!(iR_Steps == rhs.iR_Steps))
      return false;
    if (!(iR_MaxSteps == rhs.iR_MaxSteps))
      return false;
    if (!(iEnableX == rhs.iEnableX))
      return false;
    if (!(iX_Steps == rhs.iX_Steps))
      return false;
    if (!(iX_MaxSteps == rhs.iX_MaxSteps))
      return false;
    if (!(iEnableY == rhs.iEnableY))
      return false;
    if (!(iY_Steps == rhs.iY_Steps))
      return false;
    if (!(iY_MaxSteps == rhs.iY_MaxSteps))
      return false;
    if (!(iEnableZ == rhs.iEnableZ))
      return false;
    if (!(iZ_Steps == rhs.iZ_Steps))
      return false;
    if (!(iZ_MaxSteps == rhs.iZ_MaxSteps))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_VIRTUAL_POS_PARA_T &a, ENGINEER_DEBUG_VIRTUAL_POS_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& obj);

typedef struct _ENGINEER_DEBUG_VIRTUAL_POSITION_T__isset {
  _ENGINEER_DEBUG_VIRTUAL_POSITION_T__isset() : tOldVirautlPosPara(false), tCurVirautlPosPara(false) {}
  bool tOldVirautlPosPara :1;
  bool tCurVirautlPosPara :1;
} _ENGINEER_DEBUG_VIRTUAL_POSITION_T__isset;

class ENGINEER_DEBUG_VIRTUAL_POSITION_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_VIRTUAL_POSITION_T(const ENGINEER_DEBUG_VIRTUAL_POSITION_T&);
  ENGINEER_DEBUG_VIRTUAL_POSITION_T& operator=(const ENGINEER_DEBUG_VIRTUAL_POSITION_T&);
  ENGINEER_DEBUG_VIRTUAL_POSITION_T() {
  }

  virtual ~ENGINEER_DEBUG_VIRTUAL_POSITION_T() throw();
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T tOldVirautlPosPara;
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T tCurVirautlPosPara;

  _ENGINEER_DEBUG_VIRTUAL_POSITION_T__isset __isset;

  void __set_tOldVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val);

  void __set_tCurVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val);

  bool operator == (const ENGINEER_DEBUG_VIRTUAL_POSITION_T & rhs) const
  {
    if (!(tOldVirautlPosPara == rhs.tOldVirautlPosPara))
      return false;
    if (!(tCurVirautlPosPara == rhs.tCurVirautlPosPara))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_VIRTUAL_POSITION_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_VIRTUAL_POSITION_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_VIRTUAL_POSITION_T &a, ENGINEER_DEBUG_VIRTUAL_POSITION_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_VIRTUAL_POSITION_T& obj);

typedef struct _ENGINEER_DEBUG_MODULE_PARA_T__isset {
  _ENGINEER_DEBUG_MODULE_PARA_T__isset() : tVirautlPosPara(false), iIsExistRelativeViraultPosPara(false), tRelativeVirautlPosPara(false) {}
  bool tVirautlPosPara :1;
  bool iIsExistRelativeViraultPosPara :1;
  bool tRelativeVirautlPosPara :1;
} _ENGINEER_DEBUG_MODULE_PARA_T__isset;

class ENGINEER_DEBUG_MODULE_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_MODULE_PARA_T(const ENGINEER_DEBUG_MODULE_PARA_T&);
  ENGINEER_DEBUG_MODULE_PARA_T& operator=(const ENGINEER_DEBUG_MODULE_PARA_T&);
  ENGINEER_DEBUG_MODULE_PARA_T() : iIsExistRelativeViraultPosPara(0) {
  }

  virtual ~ENGINEER_DEBUG_MODULE_PARA_T() throw();
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T tVirautlPosPara;
  int32_t iIsExistRelativeViraultPosPara;
  ENGINEER_DEBUG_VIRTUAL_POS_PARA_T tRelativeVirautlPosPara;

  _ENGINEER_DEBUG_MODULE_PARA_T__isset __isset;

  void __set_tVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val);

  void __set_iIsExistRelativeViraultPosPara(const int32_t val);

  void __set_tRelativeVirautlPosPara(const ENGINEER_DEBUG_VIRTUAL_POS_PARA_T& val);

  bool operator == (const ENGINEER_DEBUG_MODULE_PARA_T & rhs) const
  {
    if (!(tVirautlPosPara == rhs.tVirautlPosPara))
      return false;
    if (!(iIsExistRelativeViraultPosPara == rhs.iIsExistRelativeViraultPosPara))
      return false;
    if (!(tRelativeVirautlPosPara == rhs.tRelativeVirautlPosPara))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_MODULE_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_MODULE_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_MODULE_PARA_T &a, ENGINEER_DEBUG_MODULE_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MODULE_PARA_T& obj);

typedef struct _ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T__isset {
  _ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T__isset() : iMotorOrIOIndex(false), iOnOrOff(false) {}
  bool iMotorOrIOIndex :1;
  bool iOnOrOff :1;
} _ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T__isset;

class ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T(const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T&);
  ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& operator=(const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T&);
  ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T() : iMotorOrIOIndex(0), iOnOrOff(0) {
  }

  virtual ~ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T() throw();
  int32_t iMotorOrIOIndex;
  int32_t iOnOrOff;

  _ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T__isset __isset;

  void __set_iMotorOrIOIndex(const int32_t val);

  void __set_iOnOrOff(const int32_t val);

  bool operator == (const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T & rhs) const
  {
    if (!(iMotorOrIOIndex == rhs.iMotorOrIOIndex))
      return false;
    if (!(iOnOrOff == rhs.iOnOrOff))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T &a, ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MOTOR_OR_IO_PARA_T& obj);

typedef struct _ENGINEER_DEBUG_MOTOR_PARA_T__isset {
  _ENGINEER_DEBUG_MOTOR_PARA_T__isset() : iModuleIndex(false), iVirtualPosIndex(false), eAxisType(false), eActionType(false), iSteps(false) {}
  bool iModuleIndex :1;
  bool iVirtualPosIndex :1;
  bool eAxisType :1;
  bool eActionType :1;
  bool iSteps :1;
} _ENGINEER_DEBUG_MOTOR_PARA_T__isset;

class ENGINEER_DEBUG_MOTOR_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_MOTOR_PARA_T(const ENGINEER_DEBUG_MOTOR_PARA_T&);
  ENGINEER_DEBUG_MOTOR_PARA_T& operator=(const ENGINEER_DEBUG_MOTOR_PARA_T&);
  ENGINEER_DEBUG_MOTOR_PARA_T() : iModuleIndex(0), iVirtualPosIndex(0), eAxisType((ENGINEER_DEBUG_AXIS_TYPE::type)0), eActionType((ENGINEER_DEBUG_ACTION_TYPE::type)0), iSteps(0) {
  }

  virtual ~ENGINEER_DEBUG_MOTOR_PARA_T() throw();
  int32_t iModuleIndex;
  int32_t iVirtualPosIndex;
  ENGINEER_DEBUG_AXIS_TYPE::type eAxisType;
  ENGINEER_DEBUG_ACTION_TYPE::type eActionType;
  int32_t iSteps;

  _ENGINEER_DEBUG_MOTOR_PARA_T__isset __isset;

  void __set_iModuleIndex(const int32_t val);

  void __set_iVirtualPosIndex(const int32_t val);

  void __set_eAxisType(const ENGINEER_DEBUG_AXIS_TYPE::type val);

  void __set_eActionType(const ENGINEER_DEBUG_ACTION_TYPE::type val);

  void __set_iSteps(const int32_t val);

  bool operator == (const ENGINEER_DEBUG_MOTOR_PARA_T & rhs) const
  {
    if (!(iModuleIndex == rhs.iModuleIndex))
      return false;
    if (!(iVirtualPosIndex == rhs.iVirtualPosIndex))
      return false;
    if (!(eAxisType == rhs.eAxisType))
      return false;
    if (!(eActionType == rhs.eActionType))
      return false;
    if (!(iSteps == rhs.iSteps))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_MOTOR_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_MOTOR_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_MOTOR_PARA_T &a, ENGINEER_DEBUG_MOTOR_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_MOTOR_PARA_T& obj);

typedef struct _ASSAY_GROUP_TESTS_T__isset {
  _ASSAY_GROUP_TESTS_T__isset() : iAssayGroupID(false), iAssayGroupHostID(false), strAssayGroupName(false), iTests(false) {}
  bool iAssayGroupID :1;
  bool iAssayGroupHostID :1;
  bool strAssayGroupName :1;
  bool iTests :1;
} _ASSAY_GROUP_TESTS_T__isset;

class ASSAY_GROUP_TESTS_T : public virtual ::apache::thrift::TBase {
 public:

  ASSAY_GROUP_TESTS_T(const ASSAY_GROUP_TESTS_T&);
  ASSAY_GROUP_TESTS_T& operator=(const ASSAY_GROUP_TESTS_T&);
  ASSAY_GROUP_TESTS_T() : iAssayGroupID(0), iAssayGroupHostID(0), strAssayGroupName(), iTests(0) {
  }

  virtual ~ASSAY_GROUP_TESTS_T() throw();
  int32_t iAssayGroupID;
  int32_t iAssayGroupHostID;
  std::string strAssayGroupName;
  int32_t iTests;

  _ASSAY_GROUP_TESTS_T__isset __isset;

  void __set_iAssayGroupID(const int32_t val);

  void __set_iAssayGroupHostID(const int32_t val);

  void __set_strAssayGroupName(const std::string& val);

  void __set_iTests(const int32_t val);

  bool operator == (const ASSAY_GROUP_TESTS_T & rhs) const
  {
    if (!(iAssayGroupID == rhs.iAssayGroupID))
      return false;
    if (!(iAssayGroupHostID == rhs.iAssayGroupHostID))
      return false;
    if (!(strAssayGroupName == rhs.strAssayGroupName))
      return false;
    if (!(iTests == rhs.iTests))
      return false;
    return true;
  }
  bool operator != (const ASSAY_GROUP_TESTS_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ASSAY_GROUP_TESTS_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ASSAY_GROUP_TESTS_T &a, ASSAY_GROUP_TESTS_T &b);

std::ostream& operator<<(std::ostream& out, const ASSAY_GROUP_TESTS_T& obj);

typedef struct _ENGINEER_DEBUG_POS_CALIB_T__isset {
  _ENGINEER_DEBUG_POS_CALIB_T__isset() : iCalibID(false), iPosID(false), iOldValue(false), iCurValue(false) {}
  bool iCalibID :1;
  bool iPosID :1;
  bool iOldValue :1;
  bool iCurValue :1;
} _ENGINEER_DEBUG_POS_CALIB_T__isset;

class ENGINEER_DEBUG_POS_CALIB_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_POS_CALIB_T(const ENGINEER_DEBUG_POS_CALIB_T&);
  ENGINEER_DEBUG_POS_CALIB_T& operator=(const ENGINEER_DEBUG_POS_CALIB_T&);
  ENGINEER_DEBUG_POS_CALIB_T() : iCalibID(0), iPosID(0), iOldValue(0), iCurValue(0) {
  }

  virtual ~ENGINEER_DEBUG_POS_CALIB_T() throw();
  int32_t iCalibID;
  int32_t iPosID;
  int32_t iOldValue;
  int32_t iCurValue;

  _ENGINEER_DEBUG_POS_CALIB_T__isset __isset;

  void __set_iCalibID(const int32_t val);

  void __set_iPosID(const int32_t val);

  void __set_iOldValue(const int32_t val);

  void __set_iCurValue(const int32_t val);

  bool operator == (const ENGINEER_DEBUG_POS_CALIB_T & rhs) const
  {
    if (!(iCalibID == rhs.iCalibID))
      return false;
    if (!(iPosID == rhs.iPosID))
      return false;
    if (!(iOldValue == rhs.iOldValue))
      return false;
    if (!(iCurValue == rhs.iCurValue))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_POS_CALIB_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_POS_CALIB_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_POS_CALIB_T &a, ENGINEER_DEBUG_POS_CALIB_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_POS_CALIB_T& obj);

typedef struct _ENGINEER_DEBUG_INJECTOR_KB_T__isset {
  _ENGINEER_DEBUG_INJECTOR_KB_T__isset() : iInjectID(false), strInjectName(false), dK(false), dB(false) {}
  bool iInjectID :1;
  bool strInjectName :1;
  bool dK :1;
  bool dB :1;
} _ENGINEER_DEBUG_INJECTOR_KB_T__isset;

class ENGINEER_DEBUG_INJECTOR_KB_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_INJECTOR_KB_T(const ENGINEER_DEBUG_INJECTOR_KB_T&);
  ENGINEER_DEBUG_INJECTOR_KB_T& operator=(const ENGINEER_DEBUG_INJECTOR_KB_T&);
  ENGINEER_DEBUG_INJECTOR_KB_T() : iInjectID(0), strInjectName(), dK(0), dB(0) {
  }

  virtual ~ENGINEER_DEBUG_INJECTOR_KB_T() throw();
  int32_t iInjectID;
  std::string strInjectName;
  double dK;
  double dB;

  _ENGINEER_DEBUG_INJECTOR_KB_T__isset __isset;

  void __set_iInjectID(const int32_t val);

  void __set_strInjectName(const std::string& val);

  void __set_dK(const double val);

  void __set_dB(const double val);

  bool operator == (const ENGINEER_DEBUG_INJECTOR_KB_T & rhs) const
  {
    if (!(iInjectID == rhs.iInjectID))
      return false;
    if (!(strInjectName == rhs.strInjectName))
      return false;
    if (!(dK == rhs.dK))
      return false;
    if (!(dB == rhs.dB))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_INJECTOR_KB_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_INJECTOR_KB_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_INJECTOR_KB_T &a, ENGINEER_DEBUG_INJECTOR_KB_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_INJECTOR_KB_T& obj);

typedef struct _ENGINEER_DEBUG_RUN_RESULT_T__isset {
  _ENGINEER_DEBUG_RUN_RESULT_T__isset() : iRunResult(false), strBarcode(false) {}
  bool iRunResult :1;
  bool strBarcode :1;
} _ENGINEER_DEBUG_RUN_RESULT_T__isset;

class ENGINEER_DEBUG_RUN_RESULT_T : public virtual ::apache::thrift::TBase {
 public:

  ENGINEER_DEBUG_RUN_RESULT_T(const ENGINEER_DEBUG_RUN_RESULT_T&);
  ENGINEER_DEBUG_RUN_RESULT_T& operator=(const ENGINEER_DEBUG_RUN_RESULT_T&);
  ENGINEER_DEBUG_RUN_RESULT_T() : iRunResult(0), strBarcode() {
  }

  virtual ~ENGINEER_DEBUG_RUN_RESULT_T() throw();
  int32_t iRunResult;
  std::string strBarcode;

  _ENGINEER_DEBUG_RUN_RESULT_T__isset __isset;

  void __set_iRunResult(const int32_t val);

  void __set_strBarcode(const std::string& val);

  bool operator == (const ENGINEER_DEBUG_RUN_RESULT_T & rhs) const
  {
    if (!(iRunResult == rhs.iRunResult))
      return false;
    if (!(strBarcode == rhs.strBarcode))
      return false;
    return true;
  }
  bool operator != (const ENGINEER_DEBUG_RUN_RESULT_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ENGINEER_DEBUG_RUN_RESULT_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ENGINEER_DEBUG_RUN_RESULT_T &a, ENGINEER_DEBUG_RUN_RESULT_T &b);

std::ostream& operator<<(std::ostream& out, const ENGINEER_DEBUG_RUN_RESULT_T& obj);

typedef struct _THRIFT_CONFIG_T__isset {
  _THRIFT_CONFIG_T__isset() : strSlaveIP(false), iSlavePort(false), strHostIP(false), iHostPort(false), iIsPunctureNeedle(false) {}
  bool strSlaveIP :1;
  bool iSlavePort :1;
  bool strHostIP :1;
  bool iHostPort :1;
  bool iIsPunctureNeedle :1;
} _THRIFT_CONFIG_T__isset;

class THRIFT_CONFIG_T : public virtual ::apache::thrift::TBase {
 public:

  THRIFT_CONFIG_T(const THRIFT_CONFIG_T&);
  THRIFT_CONFIG_T& operator=(const THRIFT_CONFIG_T&);
  THRIFT_CONFIG_T() : strSlaveIP(), iSlavePort(0), strHostIP(), iHostPort(0), iIsPunctureNeedle(0) {
  }

  virtual ~THRIFT_CONFIG_T() throw();
  std::string strSlaveIP;
  int32_t iSlavePort;
  std::string strHostIP;
  int32_t iHostPort;
  int32_t iIsPunctureNeedle;

  _THRIFT_CONFIG_T__isset __isset;

  void __set_strSlaveIP(const std::string& val);

  void __set_iSlavePort(const int32_t val);

  void __set_strHostIP(const std::string& val);

  void __set_iHostPort(const int32_t val);

  void __set_iIsPunctureNeedle(const int32_t val);

  bool operator == (const THRIFT_CONFIG_T & rhs) const
  {
    if (!(strSlaveIP == rhs.strSlaveIP))
      return false;
    if (!(iSlavePort == rhs.iSlavePort))
      return false;
    if (!(strHostIP == rhs.strHostIP))
      return false;
    if (!(iHostPort == rhs.iHostPort))
      return false;
    if (!(iIsPunctureNeedle == rhs.iIsPunctureNeedle))
      return false;
    return true;
  }
  bool operator != (const THRIFT_CONFIG_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const THRIFT_CONFIG_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(THRIFT_CONFIG_T &a, THRIFT_CONFIG_T &b);

std::ostream& operator<<(std::ostream& out, const THRIFT_CONFIG_T& obj);

typedef struct _SLAVE_PROGRAM_T__isset {
  _SLAVE_PROGRAM_T__isset() : iSlaveProgramNo(false), strSlaveProgramFileName(false), hexSlaveProgram(false), strMD5(false), iHexSlaveProgramLen(false) {}
  bool iSlaveProgramNo :1;
  bool strSlaveProgramFileName :1;
  bool hexSlaveProgram :1;
  bool strMD5 :1;
  bool iHexSlaveProgramLen :1;
} _SLAVE_PROGRAM_T__isset;

class SLAVE_PROGRAM_T : public virtual ::apache::thrift::TBase {
 public:

  SLAVE_PROGRAM_T(const SLAVE_PROGRAM_T&);
  SLAVE_PROGRAM_T& operator=(const SLAVE_PROGRAM_T&);
  SLAVE_PROGRAM_T() : iSlaveProgramNo(0), strSlaveProgramFileName(), hexSlaveProgram(), strMD5(), iHexSlaveProgramLen(0) {
  }

  virtual ~SLAVE_PROGRAM_T() throw();
  int32_t iSlaveProgramNo;
  std::string strSlaveProgramFileName;
  std::string hexSlaveProgram;
  std::string strMD5;
  int32_t iHexSlaveProgramLen;

  _SLAVE_PROGRAM_T__isset __isset;

  void __set_iSlaveProgramNo(const int32_t val);

  void __set_strSlaveProgramFileName(const std::string& val);

  void __set_hexSlaveProgram(const std::string& val);

  void __set_strMD5(const std::string& val);

  void __set_iHexSlaveProgramLen(const int32_t val);

  bool operator == (const SLAVE_PROGRAM_T & rhs) const
  {
    if (!(iSlaveProgramNo == rhs.iSlaveProgramNo))
      return false;
    if (!(strSlaveProgramFileName == rhs.strSlaveProgramFileName))
      return false;
    if (!(hexSlaveProgram == rhs.hexSlaveProgram))
      return false;
    if (!(strMD5 == rhs.strMD5))
      return false;
    if (!(iHexSlaveProgramLen == rhs.iHexSlaveProgramLen))
      return false;
    return true;
  }
  bool operator != (const SLAVE_PROGRAM_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SLAVE_PROGRAM_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SLAVE_PROGRAM_T &a, SLAVE_PROGRAM_T &b);

std::ostream& operator<<(std::ostream& out, const SLAVE_PROGRAM_T& obj);

typedef struct _SLAVE_PROGRAM_UPDATE_RESULT_T__isset {
  _SLAVE_PROGRAM_UPDATE_RESULT_T__isset() : iSlaveProgramNo(false), iUpdateResult(false) {}
  bool iSlaveProgramNo :1;
  bool iUpdateResult :1;
} _SLAVE_PROGRAM_UPDATE_RESULT_T__isset;

class SLAVE_PROGRAM_UPDATE_RESULT_T : public virtual ::apache::thrift::TBase {
 public:

  SLAVE_PROGRAM_UPDATE_RESULT_T(const SLAVE_PROGRAM_UPDATE_RESULT_T&);
  SLAVE_PROGRAM_UPDATE_RESULT_T& operator=(const SLAVE_PROGRAM_UPDATE_RESULT_T&);
  SLAVE_PROGRAM_UPDATE_RESULT_T() : iSlaveProgramNo(0), iUpdateResult(0) {
  }

  virtual ~SLAVE_PROGRAM_UPDATE_RESULT_T() throw();
  int32_t iSlaveProgramNo;
  int32_t iUpdateResult;

  _SLAVE_PROGRAM_UPDATE_RESULT_T__isset __isset;

  void __set_iSlaveProgramNo(const int32_t val);

  void __set_iUpdateResult(const int32_t val);

  bool operator == (const SLAVE_PROGRAM_UPDATE_RESULT_T & rhs) const
  {
    if (!(iSlaveProgramNo == rhs.iSlaveProgramNo))
      return false;
    if (!(iUpdateResult == rhs.iUpdateResult))
      return false;
    return true;
  }
  bool operator != (const SLAVE_PROGRAM_UPDATE_RESULT_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SLAVE_PROGRAM_UPDATE_RESULT_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SLAVE_PROGRAM_UPDATE_RESULT_T &a, SLAVE_PROGRAM_UPDATE_RESULT_T &b);

std::ostream& operator<<(std::ostream& out, const SLAVE_PROGRAM_UPDATE_RESULT_T& obj);

typedef struct _SLAVE_ASSEMBLY_AGING_PARA_T__isset {
  _SLAVE_ASSEMBLY_AGING_PARA_T__isset() : iIsOnOrOFF(false), iLoopCounts(false), iIsEnableSampler(false), iIsEnableReagentBin(false), iIsEnableGripperA(false), iIsEnableGripperB(false), iIsEnableGripperC(false), iIsEnableSampleNeedle(false), iIsEnableIncubationReagentNeedle(false), iIsEnableDetectionReagentNeedle(false), iIsEnableOnlineLoad(false), iIsEnableReactionCupTransferBelt(false), iIsEnableReactionCupMixing(false), iIsEnableReactionCupLoad(false) {}
  bool iIsOnOrOFF :1;
  bool iLoopCounts :1;
  bool iIsEnableSampler :1;
  bool iIsEnableReagentBin :1;
  bool iIsEnableGripperA :1;
  bool iIsEnableGripperB :1;
  bool iIsEnableGripperC :1;
  bool iIsEnableSampleNeedle :1;
  bool iIsEnableIncubationReagentNeedle :1;
  bool iIsEnableDetectionReagentNeedle :1;
  bool iIsEnableOnlineLoad :1;
  bool iIsEnableReactionCupTransferBelt :1;
  bool iIsEnableReactionCupMixing :1;
  bool iIsEnableReactionCupLoad :1;
} _SLAVE_ASSEMBLY_AGING_PARA_T__isset;

class SLAVE_ASSEMBLY_AGING_PARA_T : public virtual ::apache::thrift::TBase {
 public:

  SLAVE_ASSEMBLY_AGING_PARA_T(const SLAVE_ASSEMBLY_AGING_PARA_T&);
  SLAVE_ASSEMBLY_AGING_PARA_T& operator=(const SLAVE_ASSEMBLY_AGING_PARA_T&);
  SLAVE_ASSEMBLY_AGING_PARA_T() : iIsOnOrOFF(0), iLoopCounts(0), iIsEnableSampler(0), iIsEnableReagentBin(0), iIsEnableGripperA(0), iIsEnableGripperB(0), iIsEnableGripperC(0), iIsEnableSampleNeedle(0), iIsEnableIncubationReagentNeedle(0), iIsEnableDetectionReagentNeedle(0), iIsEnableOnlineLoad(0), iIsEnableReactionCupTransferBelt(0), iIsEnableReactionCupMixing(0), iIsEnableReactionCupLoad(0) {
  }

  virtual ~SLAVE_ASSEMBLY_AGING_PARA_T() throw();
  int32_t iIsOnOrOFF;
  int32_t iLoopCounts;
  int32_t iIsEnableSampler;
  int32_t iIsEnableReagentBin;
  int32_t iIsEnableGripperA;
  int32_t iIsEnableGripperB;
  int32_t iIsEnableGripperC;
  int32_t iIsEnableSampleNeedle;
  int32_t iIsEnableIncubationReagentNeedle;
  int32_t iIsEnableDetectionReagentNeedle;
  int32_t iIsEnableOnlineLoad;
  int32_t iIsEnableReactionCupTransferBelt;
  int32_t iIsEnableReactionCupMixing;
  int32_t iIsEnableReactionCupLoad;

  _SLAVE_ASSEMBLY_AGING_PARA_T__isset __isset;

  void __set_iIsOnOrOFF(const int32_t val);

  void __set_iLoopCounts(const int32_t val);

  void __set_iIsEnableSampler(const int32_t val);

  void __set_iIsEnableReagentBin(const int32_t val);

  void __set_iIsEnableGripperA(const int32_t val);

  void __set_iIsEnableGripperB(const int32_t val);

  void __set_iIsEnableGripperC(const int32_t val);

  void __set_iIsEnableSampleNeedle(const int32_t val);

  void __set_iIsEnableIncubationReagentNeedle(const int32_t val);

  void __set_iIsEnableDetectionReagentNeedle(const int32_t val);

  void __set_iIsEnableOnlineLoad(const int32_t val);

  void __set_iIsEnableReactionCupTransferBelt(const int32_t val);

  void __set_iIsEnableReactionCupMixing(const int32_t val);

  void __set_iIsEnableReactionCupLoad(const int32_t val);

  bool operator == (const SLAVE_ASSEMBLY_AGING_PARA_T & rhs) const
  {
    if (!(iIsOnOrOFF == rhs.iIsOnOrOFF))
      return false;
    if (!(iLoopCounts == rhs.iLoopCounts))
      return false;
    if (!(iIsEnableSampler == rhs.iIsEnableSampler))
      return false;
    if (!(iIsEnableReagentBin == rhs.iIsEnableReagentBin))
      return false;
    if (!(iIsEnableGripperA == rhs.iIsEnableGripperA))
      return false;
    if (!(iIsEnableGripperB == rhs.iIsEnableGripperB))
      return false;
    if (!(iIsEnableGripperC == rhs.iIsEnableGripperC))
      return false;
    if (!(iIsEnableSampleNeedle == rhs.iIsEnableSampleNeedle))
      return false;
    if (!(iIsEnableIncubationReagentNeedle == rhs.iIsEnableIncubationReagentNeedle))
      return false;
    if (!(iIsEnableDetectionReagentNeedle == rhs.iIsEnableDetectionReagentNeedle))
      return false;
    if (!(iIsEnableOnlineLoad == rhs.iIsEnableOnlineLoad))
      return false;
    if (!(iIsEnableReactionCupTransferBelt == rhs.iIsEnableReactionCupTransferBelt))
      return false;
    if (!(iIsEnableReactionCupMixing == rhs.iIsEnableReactionCupMixing))
      return false;
    if (!(iIsEnableReactionCupLoad == rhs.iIsEnableReactionCupLoad))
      return false;
    return true;
  }
  bool operator != (const SLAVE_ASSEMBLY_AGING_PARA_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SLAVE_ASSEMBLY_AGING_PARA_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SLAVE_ASSEMBLY_AGING_PARA_T &a, SLAVE_ASSEMBLY_AGING_PARA_T &b);

std::ostream& operator<<(std::ostream& out, const SLAVE_ASSEMBLY_AGING_PARA_T& obj);

typedef struct _SLAVE_COUNTEROR_TIMER_INFO_T__isset {
  _SLAVE_COUNTEROR_TIMER_INFO_T__isset() : iCounterOrTimerID(false), iNumberOfTimesOrElapsedTime(false), iTotalNumberOfTimesOrElapsedTime(false) {}
  bool iCounterOrTimerID :1;
  bool iNumberOfTimesOrElapsedTime :1;
  bool iTotalNumberOfTimesOrElapsedTime :1;
} _SLAVE_COUNTEROR_TIMER_INFO_T__isset;

class SLAVE_COUNTEROR_TIMER_INFO_T : public virtual ::apache::thrift::TBase {
 public:

  SLAVE_COUNTEROR_TIMER_INFO_T(const SLAVE_COUNTEROR_TIMER_INFO_T&);
  SLAVE_COUNTEROR_TIMER_INFO_T& operator=(const SLAVE_COUNTEROR_TIMER_INFO_T&);
  SLAVE_COUNTEROR_TIMER_INFO_T() : iCounterOrTimerID(0), iNumberOfTimesOrElapsedTime(0), iTotalNumberOfTimesOrElapsedTime(0) {
  }

  virtual ~SLAVE_COUNTEROR_TIMER_INFO_T() throw();
  int32_t iCounterOrTimerID;
  int32_t iNumberOfTimesOrElapsedTime;
  int32_t iTotalNumberOfTimesOrElapsedTime;

  _SLAVE_COUNTEROR_TIMER_INFO_T__isset __isset;

  void __set_iCounterOrTimerID(const int32_t val);

  void __set_iNumberOfTimesOrElapsedTime(const int32_t val);

  void __set_iTotalNumberOfTimesOrElapsedTime(const int32_t val);

  bool operator == (const SLAVE_COUNTEROR_TIMER_INFO_T & rhs) const
  {
    if (!(iCounterOrTimerID == rhs.iCounterOrTimerID))
      return false;
    if (!(iNumberOfTimesOrElapsedTime == rhs.iNumberOfTimesOrElapsedTime))
      return false;
    if (!(iTotalNumberOfTimesOrElapsedTime == rhs.iTotalNumberOfTimesOrElapsedTime))
      return false;
    return true;
  }
  bool operator != (const SLAVE_COUNTEROR_TIMER_INFO_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SLAVE_COUNTEROR_TIMER_INFO_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SLAVE_COUNTEROR_TIMER_INFO_T &a, SLAVE_COUNTEROR_TIMER_INFO_T &b);

std::ostream& operator<<(std::ostream& out, const SLAVE_COUNTEROR_TIMER_INFO_T& obj);

typedef struct _CHANNEL_STATUS_T__isset {
  _CHANNEL_STATUS_T__isset() : iChannelNo(false), iChannelType(false), iDisable(false) {}
  bool iChannelNo :1;
  bool iChannelType :1;
  bool iDisable :1;
} _CHANNEL_STATUS_T__isset;

class CHANNEL_STATUS_T : public virtual ::apache::thrift::TBase {
 public:

  CHANNEL_STATUS_T(const CHANNEL_STATUS_T&);
  CHANNEL_STATUS_T& operator=(const CHANNEL_STATUS_T&);
  CHANNEL_STATUS_T() : iChannelNo(0), iChannelType(0), iDisable(0) {
  }

  virtual ~CHANNEL_STATUS_T() throw();
  int32_t iChannelNo;
  int32_t iChannelType;
  int32_t iDisable;

  _CHANNEL_STATUS_T__isset __isset;

  void __set_iChannelNo(const int32_t val);

  void __set_iChannelType(const int32_t val);

  void __set_iDisable(const int32_t val);

  bool operator == (const CHANNEL_STATUS_T & rhs) const
  {
    if (!(iChannelNo == rhs.iChannelNo))
      return false;
    if (!(iChannelType == rhs.iChannelType))
      return false;
    if (!(iDisable == rhs.iDisable))
      return false;
    return true;
  }
  bool operator != (const CHANNEL_STATUS_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CHANNEL_STATUS_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CHANNEL_STATUS_T &a, CHANNEL_STATUS_T &b);

std::ostream& operator<<(std::ostream& out, const CHANNEL_STATUS_T& obj);

typedef struct _CHANNEL_GAIN_T__isset {
  _CHANNEL_GAIN_T__isset() : i340Gain(false), i405Gain(false), i570Gain(false), i660Gain(false), i800Gain(false) {}
  bool i340Gain :1;
  bool i405Gain :1;
  bool i570Gain :1;
  bool i660Gain :1;
  bool i800Gain :1;
} _CHANNEL_GAIN_T__isset;

class CHANNEL_GAIN_T : public virtual ::apache::thrift::TBase {
 public:

  CHANNEL_GAIN_T(const CHANNEL_GAIN_T&);
  CHANNEL_GAIN_T& operator=(const CHANNEL_GAIN_T&);
  CHANNEL_GAIN_T() : i340Gain(0), i405Gain(0), i570Gain(0), i660Gain(0), i800Gain(0) {
  }

  virtual ~CHANNEL_GAIN_T() throw();
  int32_t i340Gain;
  int32_t i405Gain;
  int32_t i570Gain;
  int32_t i660Gain;
  int32_t i800Gain;

  _CHANNEL_GAIN_T__isset __isset;

  void __set_i340Gain(const int32_t val);

  void __set_i405Gain(const int32_t val);

  void __set_i570Gain(const int32_t val);

  void __set_i660Gain(const int32_t val);

  void __set_i800Gain(const int32_t val);

  bool operator == (const CHANNEL_GAIN_T & rhs) const
  {
    if (!(i340Gain == rhs.i340Gain))
      return false;
    if (!(i405Gain == rhs.i405Gain))
      return false;
    if (!(i570Gain == rhs.i570Gain))
      return false;
    if (!(i660Gain == rhs.i660Gain))
      return false;
    if (!(i800Gain == rhs.i800Gain))
      return false;
    return true;
  }
  bool operator != (const CHANNEL_GAIN_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CHANNEL_GAIN_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CHANNEL_GAIN_T &a, CHANNEL_GAIN_T &b);

std::ostream& operator<<(std::ostream& out, const CHANNEL_GAIN_T& obj);

typedef struct _CHANNEL_AD_T__isset {
  _CHANNEL_AD_T__isset() : iChannelNo(false), iChannelType(false), i340AD(false), i405AD(false), i570AD(false), i660AD(false), i800AD(false), iReserved(false) {}
  bool iChannelNo :1;
  bool iChannelType :1;
  bool i340AD :1;
  bool i405AD :1;
  bool i570AD :1;
  bool i660AD :1;
  bool i800AD :1;
  bool iReserved :1;
} _CHANNEL_AD_T__isset;

class CHANNEL_AD_T : public virtual ::apache::thrift::TBase {
 public:

  CHANNEL_AD_T(const CHANNEL_AD_T&);
  CHANNEL_AD_T& operator=(const CHANNEL_AD_T&);
  CHANNEL_AD_T() : iChannelNo(0), iChannelType(0), i340AD(0), i405AD(0), i570AD(0), i660AD(0), i800AD(0), iReserved(0) {
  }

  virtual ~CHANNEL_AD_T() throw();
  int32_t iChannelNo;
  int32_t iChannelType;
  int32_t i340AD;
  int32_t i405AD;
  int32_t i570AD;
  int32_t i660AD;
  int32_t i800AD;
  int32_t iReserved;

  _CHANNEL_AD_T__isset __isset;

  void __set_iChannelNo(const int32_t val);

  void __set_iChannelType(const int32_t val);

  void __set_i340AD(const int32_t val);

  void __set_i405AD(const int32_t val);

  void __set_i570AD(const int32_t val);

  void __set_i660AD(const int32_t val);

  void __set_i800AD(const int32_t val);

  void __set_iReserved(const int32_t val);

  bool operator == (const CHANNEL_AD_T & rhs) const
  {
    if (!(iChannelNo == rhs.iChannelNo))
      return false;
    if (!(iChannelType == rhs.iChannelType))
      return false;
    if (!(i340AD == rhs.i340AD))
      return false;
    if (!(i405AD == rhs.i405AD))
      return false;
    if (!(i570AD == rhs.i570AD))
      return false;
    if (!(i660AD == rhs.i660AD))
      return false;
    if (!(i800AD == rhs.i800AD))
      return false;
    if (!(iReserved == rhs.iReserved))
      return false;
    return true;
  }
  bool operator != (const CHANNEL_AD_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CHANNEL_AD_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CHANNEL_AD_T &a, CHANNEL_AD_T &b);

std::ostream& operator<<(std::ostream& out, const CHANNEL_AD_T& obj);

typedef struct _MAINTENANCE_ITEM_T__isset {
  _MAINTENANCE_ITEM_T__isset() : iItemID(false), iParam(false) {}
  bool iItemID :1;
  bool iParam :1;
} _MAINTENANCE_ITEM_T__isset;

class MAINTENANCE_ITEM_T : public virtual ::apache::thrift::TBase {
 public:

  MAINTENANCE_ITEM_T(const MAINTENANCE_ITEM_T&);
  MAINTENANCE_ITEM_T& operator=(const MAINTENANCE_ITEM_T&);
  MAINTENANCE_ITEM_T() : iItemID(0), iParam(0) {
  }

  virtual ~MAINTENANCE_ITEM_T() throw();
  int32_t iItemID;
  int32_t iParam;

  _MAINTENANCE_ITEM_T__isset __isset;

  void __set_iItemID(const int32_t val);

  void __set_iParam(const int32_t val);

  bool operator == (const MAINTENANCE_ITEM_T & rhs) const
  {
    if (!(iItemID == rhs.iItemID))
      return false;
    if (!(iParam == rhs.iParam))
      return false;
    return true;
  }
  bool operator != (const MAINTENANCE_ITEM_T &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MAINTENANCE_ITEM_T & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MAINTENANCE_ITEM_T &a, MAINTENANCE_ITEM_T &b);

std::ostream& operator<<(std::ostream& out, const MAINTENANCE_ITEM_T& obj);



#endif
