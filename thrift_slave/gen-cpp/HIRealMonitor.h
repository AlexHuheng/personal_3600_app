/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef HIRealMonitor_H
#define HIRealMonitor_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "H2103_Host_Invoke_types.h"

namespace H2103_Host_Invoke {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class HIRealMonitorIf {
 public:
  virtual ~HIRealMonitorIf() {}
  virtual  ::EXE_STATE::type GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type GetPressureAsync(const int32_t sensor, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type GetLightSignalAsync(const int32_t iWave, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type ManualStopAsync(const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo) = 0;
  virtual int32_t GetCurrentInstrumentState() = 0;
  virtual  ::EXE_STATE::type SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime) = 0;
  virtual  ::EXE_STATE::type SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime) = 0;
  virtual void GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return) = 0;
};

class HIRealMonitorIfFactory {
 public:
  typedef HIRealMonitorIf Handler;

  virtual ~HIRealMonitorIfFactory() {}

  virtual HIRealMonitorIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HIRealMonitorIf* /* handler */) = 0;
};

class HIRealMonitorIfSingletonFactory : virtual public HIRealMonitorIfFactory {
 public:
  HIRealMonitorIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf>& iface) : iface_(iface) {}
  virtual ~HIRealMonitorIfSingletonFactory() {}

  virtual HIRealMonitorIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HIRealMonitorIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> iface_;
};

class HIRealMonitorNull : virtual public HIRealMonitorIf {
 public:
  virtual ~HIRealMonitorNull() {}
   ::EXE_STATE::type GetIOAsync(const  ::OUTPUT_IO::type /* sensor */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type /* sensor */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type GetPressureAsync(const int32_t /* sensor */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetIOAsync(const  ::INPUT_IO::type /* sensor */, const int32_t /* iState */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type ManualUnlockSlotAsync(const  ::INPUT_IO::type /* sensor */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type GetLightSignalAsync(const int32_t /* iWave */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetIndicatorLightAsync(const int32_t /* iIndicatorLightNo */, const int32_t /* iColor */, const int32_t /* iBlink */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetAlarmSoundAsync(const  ::IBOOL /* bOpen */, const int32_t /* iSound */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type ManualStopAsync(const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& /* tConsumablesInfo */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
  int32_t GetCurrentInstrumentState() {
    int32_t _return = 0;
    return _return;
  }
   ::EXE_STATE::type SetCounterOrTimer(const int32_t /* iCounterOrTimerID */, const int32_t /* iNumberOfTimesOrElapsedTime */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetTotalCounterOrTimer(const int32_t /* iCounterOrTimerID */, const int32_t /* iTotalNumberOfTimesOrElapsedTime */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
  void GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & /* _return */) {
    return;
  }
};

typedef struct _HIRealMonitor_GetIOAsync_args__isset {
  _HIRealMonitor_GetIOAsync_args__isset() : sensor(false), iUserData(false) {}
  bool sensor :1;
  bool iUserData :1;
} _HIRealMonitor_GetIOAsync_args__isset;

class HIRealMonitor_GetIOAsync_args {
 public:

  HIRealMonitor_GetIOAsync_args(const HIRealMonitor_GetIOAsync_args&);
  HIRealMonitor_GetIOAsync_args& operator=(const HIRealMonitor_GetIOAsync_args&);
  HIRealMonitor_GetIOAsync_args() : sensor(( ::OUTPUT_IO::type)0), iUserData(0) {
  }

  virtual ~HIRealMonitor_GetIOAsync_args() throw();
   ::OUTPUT_IO::type sensor;
  int32_t iUserData;

  _HIRealMonitor_GetIOAsync_args__isset __isset;

  void __set_sensor(const  ::OUTPUT_IO::type val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_GetIOAsync_args & rhs) const
  {
    if (!(sensor == rhs.sensor))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetIOAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetIOAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetIOAsync_pargs {
 public:


  virtual ~HIRealMonitor_GetIOAsync_pargs() throw();
  const  ::OUTPUT_IO::type* sensor;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetIOAsync_result__isset {
  _HIRealMonitor_GetIOAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetIOAsync_result__isset;

class HIRealMonitor_GetIOAsync_result {
 public:

  HIRealMonitor_GetIOAsync_result(const HIRealMonitor_GetIOAsync_result&);
  HIRealMonitor_GetIOAsync_result& operator=(const HIRealMonitor_GetIOAsync_result&);
  HIRealMonitor_GetIOAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_GetIOAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_GetIOAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_GetIOAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetIOAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetIOAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetIOAsync_presult__isset {
  _HIRealMonitor_GetIOAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetIOAsync_presult__isset;

class HIRealMonitor_GetIOAsync_presult {
 public:


  virtual ~HIRealMonitor_GetIOAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_GetIOAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_GetTemperatureAsync_args__isset {
  _HIRealMonitor_GetTemperatureAsync_args__isset() : sensor(false), iUserData(false) {}
  bool sensor :1;
  bool iUserData :1;
} _HIRealMonitor_GetTemperatureAsync_args__isset;

class HIRealMonitor_GetTemperatureAsync_args {
 public:

  HIRealMonitor_GetTemperatureAsync_args(const HIRealMonitor_GetTemperatureAsync_args&);
  HIRealMonitor_GetTemperatureAsync_args& operator=(const HIRealMonitor_GetTemperatureAsync_args&);
  HIRealMonitor_GetTemperatureAsync_args() : sensor(( ::TEMPERATURE_SENSOR::type)0), iUserData(0) {
  }

  virtual ~HIRealMonitor_GetTemperatureAsync_args() throw();
   ::TEMPERATURE_SENSOR::type sensor;
  int32_t iUserData;

  _HIRealMonitor_GetTemperatureAsync_args__isset __isset;

  void __set_sensor(const  ::TEMPERATURE_SENSOR::type val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_GetTemperatureAsync_args & rhs) const
  {
    if (!(sensor == rhs.sensor))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetTemperatureAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetTemperatureAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetTemperatureAsync_pargs {
 public:


  virtual ~HIRealMonitor_GetTemperatureAsync_pargs() throw();
  const  ::TEMPERATURE_SENSOR::type* sensor;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetTemperatureAsync_result__isset {
  _HIRealMonitor_GetTemperatureAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetTemperatureAsync_result__isset;

class HIRealMonitor_GetTemperatureAsync_result {
 public:

  HIRealMonitor_GetTemperatureAsync_result(const HIRealMonitor_GetTemperatureAsync_result&);
  HIRealMonitor_GetTemperatureAsync_result& operator=(const HIRealMonitor_GetTemperatureAsync_result&);
  HIRealMonitor_GetTemperatureAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_GetTemperatureAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_GetTemperatureAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_GetTemperatureAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetTemperatureAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetTemperatureAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetTemperatureAsync_presult__isset {
  _HIRealMonitor_GetTemperatureAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetTemperatureAsync_presult__isset;

class HIRealMonitor_GetTemperatureAsync_presult {
 public:


  virtual ~HIRealMonitor_GetTemperatureAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_GetTemperatureAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_GetPressureAsync_args__isset {
  _HIRealMonitor_GetPressureAsync_args__isset() : sensor(false), iUserData(false) {}
  bool sensor :1;
  bool iUserData :1;
} _HIRealMonitor_GetPressureAsync_args__isset;

class HIRealMonitor_GetPressureAsync_args {
 public:

  HIRealMonitor_GetPressureAsync_args(const HIRealMonitor_GetPressureAsync_args&);
  HIRealMonitor_GetPressureAsync_args& operator=(const HIRealMonitor_GetPressureAsync_args&);
  HIRealMonitor_GetPressureAsync_args() : sensor(0), iUserData(0) {
  }

  virtual ~HIRealMonitor_GetPressureAsync_args() throw();
  int32_t sensor;
  int32_t iUserData;

  _HIRealMonitor_GetPressureAsync_args__isset __isset;

  void __set_sensor(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_GetPressureAsync_args & rhs) const
  {
    if (!(sensor == rhs.sensor))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetPressureAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetPressureAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetPressureAsync_pargs {
 public:


  virtual ~HIRealMonitor_GetPressureAsync_pargs() throw();
  const int32_t* sensor;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetPressureAsync_result__isset {
  _HIRealMonitor_GetPressureAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetPressureAsync_result__isset;

class HIRealMonitor_GetPressureAsync_result {
 public:

  HIRealMonitor_GetPressureAsync_result(const HIRealMonitor_GetPressureAsync_result&);
  HIRealMonitor_GetPressureAsync_result& operator=(const HIRealMonitor_GetPressureAsync_result&);
  HIRealMonitor_GetPressureAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_GetPressureAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_GetPressureAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_GetPressureAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetPressureAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetPressureAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetPressureAsync_presult__isset {
  _HIRealMonitor_GetPressureAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetPressureAsync_presult__isset;

class HIRealMonitor_GetPressureAsync_presult {
 public:


  virtual ~HIRealMonitor_GetPressureAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_GetPressureAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetIOAsync_args__isset {
  _HIRealMonitor_SetIOAsync_args__isset() : sensor(false), iState(false), iUserData(false) {}
  bool sensor :1;
  bool iState :1;
  bool iUserData :1;
} _HIRealMonitor_SetIOAsync_args__isset;

class HIRealMonitor_SetIOAsync_args {
 public:

  HIRealMonitor_SetIOAsync_args(const HIRealMonitor_SetIOAsync_args&);
  HIRealMonitor_SetIOAsync_args& operator=(const HIRealMonitor_SetIOAsync_args&);
  HIRealMonitor_SetIOAsync_args() : sensor(( ::INPUT_IO::type)0), iState(0), iUserData(0) {
  }

  virtual ~HIRealMonitor_SetIOAsync_args() throw();
   ::INPUT_IO::type sensor;
  int32_t iState;
  int32_t iUserData;

  _HIRealMonitor_SetIOAsync_args__isset __isset;

  void __set_sensor(const  ::INPUT_IO::type val);

  void __set_iState(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_SetIOAsync_args & rhs) const
  {
    if (!(sensor == rhs.sensor))
      return false;
    if (!(iState == rhs.iState))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetIOAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetIOAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetIOAsync_pargs {
 public:


  virtual ~HIRealMonitor_SetIOAsync_pargs() throw();
  const  ::INPUT_IO::type* sensor;
  const int32_t* iState;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetIOAsync_result__isset {
  _HIRealMonitor_SetIOAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetIOAsync_result__isset;

class HIRealMonitor_SetIOAsync_result {
 public:

  HIRealMonitor_SetIOAsync_result(const HIRealMonitor_SetIOAsync_result&);
  HIRealMonitor_SetIOAsync_result& operator=(const HIRealMonitor_SetIOAsync_result&);
  HIRealMonitor_SetIOAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetIOAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetIOAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetIOAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetIOAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetIOAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetIOAsync_presult__isset {
  _HIRealMonitor_SetIOAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetIOAsync_presult__isset;

class HIRealMonitor_SetIOAsync_presult {
 public:


  virtual ~HIRealMonitor_SetIOAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetIOAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_ManualUnlockSlotAsync_args__isset {
  _HIRealMonitor_ManualUnlockSlotAsync_args__isset() : sensor(false), iUserData(false) {}
  bool sensor :1;
  bool iUserData :1;
} _HIRealMonitor_ManualUnlockSlotAsync_args__isset;

class HIRealMonitor_ManualUnlockSlotAsync_args {
 public:

  HIRealMonitor_ManualUnlockSlotAsync_args(const HIRealMonitor_ManualUnlockSlotAsync_args&);
  HIRealMonitor_ManualUnlockSlotAsync_args& operator=(const HIRealMonitor_ManualUnlockSlotAsync_args&);
  HIRealMonitor_ManualUnlockSlotAsync_args() : sensor(( ::INPUT_IO::type)0), iUserData(0) {
  }

  virtual ~HIRealMonitor_ManualUnlockSlotAsync_args() throw();
   ::INPUT_IO::type sensor;
  int32_t iUserData;

  _HIRealMonitor_ManualUnlockSlotAsync_args__isset __isset;

  void __set_sensor(const  ::INPUT_IO::type val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_ManualUnlockSlotAsync_args & rhs) const
  {
    if (!(sensor == rhs.sensor))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_ManualUnlockSlotAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_ManualUnlockSlotAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_ManualUnlockSlotAsync_pargs {
 public:


  virtual ~HIRealMonitor_ManualUnlockSlotAsync_pargs() throw();
  const  ::INPUT_IO::type* sensor;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_ManualUnlockSlotAsync_result__isset {
  _HIRealMonitor_ManualUnlockSlotAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_ManualUnlockSlotAsync_result__isset;

class HIRealMonitor_ManualUnlockSlotAsync_result {
 public:

  HIRealMonitor_ManualUnlockSlotAsync_result(const HIRealMonitor_ManualUnlockSlotAsync_result&);
  HIRealMonitor_ManualUnlockSlotAsync_result& operator=(const HIRealMonitor_ManualUnlockSlotAsync_result&);
  HIRealMonitor_ManualUnlockSlotAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_ManualUnlockSlotAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_ManualUnlockSlotAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_ManualUnlockSlotAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_ManualUnlockSlotAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_ManualUnlockSlotAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_ManualUnlockSlotAsync_presult__isset {
  _HIRealMonitor_ManualUnlockSlotAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_ManualUnlockSlotAsync_presult__isset;

class HIRealMonitor_ManualUnlockSlotAsync_presult {
 public:


  virtual ~HIRealMonitor_ManualUnlockSlotAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_ManualUnlockSlotAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_GetLightSignalAsync_args__isset {
  _HIRealMonitor_GetLightSignalAsync_args__isset() : iWave(false), iUserData(false) {}
  bool iWave :1;
  bool iUserData :1;
} _HIRealMonitor_GetLightSignalAsync_args__isset;

class HIRealMonitor_GetLightSignalAsync_args {
 public:

  HIRealMonitor_GetLightSignalAsync_args(const HIRealMonitor_GetLightSignalAsync_args&);
  HIRealMonitor_GetLightSignalAsync_args& operator=(const HIRealMonitor_GetLightSignalAsync_args&);
  HIRealMonitor_GetLightSignalAsync_args() : iWave(0), iUserData(0) {
  }

  virtual ~HIRealMonitor_GetLightSignalAsync_args() throw();
  int32_t iWave;
  int32_t iUserData;

  _HIRealMonitor_GetLightSignalAsync_args__isset __isset;

  void __set_iWave(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_GetLightSignalAsync_args & rhs) const
  {
    if (!(iWave == rhs.iWave))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetLightSignalAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetLightSignalAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetLightSignalAsync_pargs {
 public:


  virtual ~HIRealMonitor_GetLightSignalAsync_pargs() throw();
  const int32_t* iWave;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetLightSignalAsync_result__isset {
  _HIRealMonitor_GetLightSignalAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetLightSignalAsync_result__isset;

class HIRealMonitor_GetLightSignalAsync_result {
 public:

  HIRealMonitor_GetLightSignalAsync_result(const HIRealMonitor_GetLightSignalAsync_result&);
  HIRealMonitor_GetLightSignalAsync_result& operator=(const HIRealMonitor_GetLightSignalAsync_result&);
  HIRealMonitor_GetLightSignalAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_GetLightSignalAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_GetLightSignalAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_GetLightSignalAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetLightSignalAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetLightSignalAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetLightSignalAsync_presult__isset {
  _HIRealMonitor_GetLightSignalAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetLightSignalAsync_presult__isset;

class HIRealMonitor_GetLightSignalAsync_presult {
 public:


  virtual ~HIRealMonitor_GetLightSignalAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_GetLightSignalAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetIndicatorLightAsync_args__isset {
  _HIRealMonitor_SetIndicatorLightAsync_args__isset() : iIndicatorLightNo(false), iColor(false), iBlink(false), iUserData(false) {}
  bool iIndicatorLightNo :1;
  bool iColor :1;
  bool iBlink :1;
  bool iUserData :1;
} _HIRealMonitor_SetIndicatorLightAsync_args__isset;

class HIRealMonitor_SetIndicatorLightAsync_args {
 public:

  HIRealMonitor_SetIndicatorLightAsync_args(const HIRealMonitor_SetIndicatorLightAsync_args&);
  HIRealMonitor_SetIndicatorLightAsync_args& operator=(const HIRealMonitor_SetIndicatorLightAsync_args&);
  HIRealMonitor_SetIndicatorLightAsync_args() : iIndicatorLightNo(0), iColor(0), iBlink(0), iUserData(0) {
  }

  virtual ~HIRealMonitor_SetIndicatorLightAsync_args() throw();
  int32_t iIndicatorLightNo;
  int32_t iColor;
  int32_t iBlink;
  int32_t iUserData;

  _HIRealMonitor_SetIndicatorLightAsync_args__isset __isset;

  void __set_iIndicatorLightNo(const int32_t val);

  void __set_iColor(const int32_t val);

  void __set_iBlink(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_SetIndicatorLightAsync_args & rhs) const
  {
    if (!(iIndicatorLightNo == rhs.iIndicatorLightNo))
      return false;
    if (!(iColor == rhs.iColor))
      return false;
    if (!(iBlink == rhs.iBlink))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetIndicatorLightAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetIndicatorLightAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetIndicatorLightAsync_pargs {
 public:


  virtual ~HIRealMonitor_SetIndicatorLightAsync_pargs() throw();
  const int32_t* iIndicatorLightNo;
  const int32_t* iColor;
  const int32_t* iBlink;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetIndicatorLightAsync_result__isset {
  _HIRealMonitor_SetIndicatorLightAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetIndicatorLightAsync_result__isset;

class HIRealMonitor_SetIndicatorLightAsync_result {
 public:

  HIRealMonitor_SetIndicatorLightAsync_result(const HIRealMonitor_SetIndicatorLightAsync_result&);
  HIRealMonitor_SetIndicatorLightAsync_result& operator=(const HIRealMonitor_SetIndicatorLightAsync_result&);
  HIRealMonitor_SetIndicatorLightAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetIndicatorLightAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetIndicatorLightAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetIndicatorLightAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetIndicatorLightAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetIndicatorLightAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetIndicatorLightAsync_presult__isset {
  _HIRealMonitor_SetIndicatorLightAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetIndicatorLightAsync_presult__isset;

class HIRealMonitor_SetIndicatorLightAsync_presult {
 public:


  virtual ~HIRealMonitor_SetIndicatorLightAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetIndicatorLightAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetAlarmSoundAsync_args__isset {
  _HIRealMonitor_SetAlarmSoundAsync_args__isset() : bOpen(false), iSound(false), iUserData(false) {}
  bool bOpen :1;
  bool iSound :1;
  bool iUserData :1;
} _HIRealMonitor_SetAlarmSoundAsync_args__isset;

class HIRealMonitor_SetAlarmSoundAsync_args {
 public:

  HIRealMonitor_SetAlarmSoundAsync_args(const HIRealMonitor_SetAlarmSoundAsync_args&);
  HIRealMonitor_SetAlarmSoundAsync_args& operator=(const HIRealMonitor_SetAlarmSoundAsync_args&);
  HIRealMonitor_SetAlarmSoundAsync_args() : bOpen(0), iSound(0), iUserData(0) {
  }

  virtual ~HIRealMonitor_SetAlarmSoundAsync_args() throw();
   ::IBOOL bOpen;
  int32_t iSound;
  int32_t iUserData;

  _HIRealMonitor_SetAlarmSoundAsync_args__isset __isset;

  void __set_bOpen(const  ::IBOOL val);

  void __set_iSound(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_SetAlarmSoundAsync_args & rhs) const
  {
    if (!(bOpen == rhs.bOpen))
      return false;
    if (!(iSound == rhs.iSound))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetAlarmSoundAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetAlarmSoundAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetAlarmSoundAsync_pargs {
 public:


  virtual ~HIRealMonitor_SetAlarmSoundAsync_pargs() throw();
  const  ::IBOOL* bOpen;
  const int32_t* iSound;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetAlarmSoundAsync_result__isset {
  _HIRealMonitor_SetAlarmSoundAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetAlarmSoundAsync_result__isset;

class HIRealMonitor_SetAlarmSoundAsync_result {
 public:

  HIRealMonitor_SetAlarmSoundAsync_result(const HIRealMonitor_SetAlarmSoundAsync_result&);
  HIRealMonitor_SetAlarmSoundAsync_result& operator=(const HIRealMonitor_SetAlarmSoundAsync_result&);
  HIRealMonitor_SetAlarmSoundAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetAlarmSoundAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetAlarmSoundAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetAlarmSoundAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetAlarmSoundAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetAlarmSoundAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetAlarmSoundAsync_presult__isset {
  _HIRealMonitor_SetAlarmSoundAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetAlarmSoundAsync_presult__isset;

class HIRealMonitor_SetAlarmSoundAsync_presult {
 public:


  virtual ~HIRealMonitor_SetAlarmSoundAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetAlarmSoundAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_ManualStopAsync_args__isset {
  _HIRealMonitor_ManualStopAsync_args__isset() : iUserData(false) {}
  bool iUserData :1;
} _HIRealMonitor_ManualStopAsync_args__isset;

class HIRealMonitor_ManualStopAsync_args {
 public:

  HIRealMonitor_ManualStopAsync_args(const HIRealMonitor_ManualStopAsync_args&);
  HIRealMonitor_ManualStopAsync_args& operator=(const HIRealMonitor_ManualStopAsync_args&);
  HIRealMonitor_ManualStopAsync_args() : iUserData(0) {
  }

  virtual ~HIRealMonitor_ManualStopAsync_args() throw();
  int32_t iUserData;

  _HIRealMonitor_ManualStopAsync_args__isset __isset;

  void __set_iUserData(const int32_t val);

  bool operator == (const HIRealMonitor_ManualStopAsync_args & rhs) const
  {
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_ManualStopAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_ManualStopAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_ManualStopAsync_pargs {
 public:


  virtual ~HIRealMonitor_ManualStopAsync_pargs() throw();
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_ManualStopAsync_result__isset {
  _HIRealMonitor_ManualStopAsync_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_ManualStopAsync_result__isset;

class HIRealMonitor_ManualStopAsync_result {
 public:

  HIRealMonitor_ManualStopAsync_result(const HIRealMonitor_ManualStopAsync_result&);
  HIRealMonitor_ManualStopAsync_result& operator=(const HIRealMonitor_ManualStopAsync_result&);
  HIRealMonitor_ManualStopAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_ManualStopAsync_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_ManualStopAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_ManualStopAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_ManualStopAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_ManualStopAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_ManualStopAsync_presult__isset {
  _HIRealMonitor_ManualStopAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_ManualStopAsync_presult__isset;

class HIRealMonitor_ManualStopAsync_presult {
 public:


  virtual ~HIRealMonitor_ManualStopAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_ManualStopAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetConsumablesInfo_args__isset {
  _HIRealMonitor_SetConsumablesInfo_args__isset() : tConsumablesInfo(false) {}
  bool tConsumablesInfo :1;
} _HIRealMonitor_SetConsumablesInfo_args__isset;

class HIRealMonitor_SetConsumablesInfo_args {
 public:

  HIRealMonitor_SetConsumablesInfo_args(const HIRealMonitor_SetConsumablesInfo_args&);
  HIRealMonitor_SetConsumablesInfo_args& operator=(const HIRealMonitor_SetConsumablesInfo_args&);
  HIRealMonitor_SetConsumablesInfo_args() {
  }

  virtual ~HIRealMonitor_SetConsumablesInfo_args() throw();
   ::CONSUMABLES_INFO_T tConsumablesInfo;

  _HIRealMonitor_SetConsumablesInfo_args__isset __isset;

  void __set_tConsumablesInfo(const  ::CONSUMABLES_INFO_T& val);

  bool operator == (const HIRealMonitor_SetConsumablesInfo_args & rhs) const
  {
    if (!(tConsumablesInfo == rhs.tConsumablesInfo))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetConsumablesInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetConsumablesInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetConsumablesInfo_pargs {
 public:


  virtual ~HIRealMonitor_SetConsumablesInfo_pargs() throw();
  const  ::CONSUMABLES_INFO_T* tConsumablesInfo;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetConsumablesInfo_result__isset {
  _HIRealMonitor_SetConsumablesInfo_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetConsumablesInfo_result__isset;

class HIRealMonitor_SetConsumablesInfo_result {
 public:

  HIRealMonitor_SetConsumablesInfo_result(const HIRealMonitor_SetConsumablesInfo_result&);
  HIRealMonitor_SetConsumablesInfo_result& operator=(const HIRealMonitor_SetConsumablesInfo_result&);
  HIRealMonitor_SetConsumablesInfo_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetConsumablesInfo_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetConsumablesInfo_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetConsumablesInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetConsumablesInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetConsumablesInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetConsumablesInfo_presult__isset {
  _HIRealMonitor_SetConsumablesInfo_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetConsumablesInfo_presult__isset;

class HIRealMonitor_SetConsumablesInfo_presult {
 public:


  virtual ~HIRealMonitor_SetConsumablesInfo_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetConsumablesInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class HIRealMonitor_GetCurrentInstrumentState_args {
 public:

  HIRealMonitor_GetCurrentInstrumentState_args(const HIRealMonitor_GetCurrentInstrumentState_args&);
  HIRealMonitor_GetCurrentInstrumentState_args& operator=(const HIRealMonitor_GetCurrentInstrumentState_args&);
  HIRealMonitor_GetCurrentInstrumentState_args() {
  }

  virtual ~HIRealMonitor_GetCurrentInstrumentState_args() throw();

  bool operator == (const HIRealMonitor_GetCurrentInstrumentState_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HIRealMonitor_GetCurrentInstrumentState_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetCurrentInstrumentState_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetCurrentInstrumentState_pargs {
 public:


  virtual ~HIRealMonitor_GetCurrentInstrumentState_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetCurrentInstrumentState_result__isset {
  _HIRealMonitor_GetCurrentInstrumentState_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetCurrentInstrumentState_result__isset;

class HIRealMonitor_GetCurrentInstrumentState_result {
 public:

  HIRealMonitor_GetCurrentInstrumentState_result(const HIRealMonitor_GetCurrentInstrumentState_result&);
  HIRealMonitor_GetCurrentInstrumentState_result& operator=(const HIRealMonitor_GetCurrentInstrumentState_result&);
  HIRealMonitor_GetCurrentInstrumentState_result() : success(0) {
  }

  virtual ~HIRealMonitor_GetCurrentInstrumentState_result() throw();
  int32_t success;

  _HIRealMonitor_GetCurrentInstrumentState_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const HIRealMonitor_GetCurrentInstrumentState_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetCurrentInstrumentState_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetCurrentInstrumentState_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetCurrentInstrumentState_presult__isset {
  _HIRealMonitor_GetCurrentInstrumentState_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetCurrentInstrumentState_presult__isset;

class HIRealMonitor_GetCurrentInstrumentState_presult {
 public:


  virtual ~HIRealMonitor_GetCurrentInstrumentState_presult() throw();
  int32_t* success;

  _HIRealMonitor_GetCurrentInstrumentState_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetCounterOrTimer_args__isset {
  _HIRealMonitor_SetCounterOrTimer_args__isset() : iCounterOrTimerID(false), iNumberOfTimesOrElapsedTime(false) {}
  bool iCounterOrTimerID :1;
  bool iNumberOfTimesOrElapsedTime :1;
} _HIRealMonitor_SetCounterOrTimer_args__isset;

class HIRealMonitor_SetCounterOrTimer_args {
 public:

  HIRealMonitor_SetCounterOrTimer_args(const HIRealMonitor_SetCounterOrTimer_args&);
  HIRealMonitor_SetCounterOrTimer_args& operator=(const HIRealMonitor_SetCounterOrTimer_args&);
  HIRealMonitor_SetCounterOrTimer_args() : iCounterOrTimerID(0), iNumberOfTimesOrElapsedTime(0) {
  }

  virtual ~HIRealMonitor_SetCounterOrTimer_args() throw();
  int32_t iCounterOrTimerID;
  int32_t iNumberOfTimesOrElapsedTime;

  _HIRealMonitor_SetCounterOrTimer_args__isset __isset;

  void __set_iCounterOrTimerID(const int32_t val);

  void __set_iNumberOfTimesOrElapsedTime(const int32_t val);

  bool operator == (const HIRealMonitor_SetCounterOrTimer_args & rhs) const
  {
    if (!(iCounterOrTimerID == rhs.iCounterOrTimerID))
      return false;
    if (!(iNumberOfTimesOrElapsedTime == rhs.iNumberOfTimesOrElapsedTime))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetCounterOrTimer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetCounterOrTimer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetCounterOrTimer_pargs {
 public:


  virtual ~HIRealMonitor_SetCounterOrTimer_pargs() throw();
  const int32_t* iCounterOrTimerID;
  const int32_t* iNumberOfTimesOrElapsedTime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetCounterOrTimer_result__isset {
  _HIRealMonitor_SetCounterOrTimer_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetCounterOrTimer_result__isset;

class HIRealMonitor_SetCounterOrTimer_result {
 public:

  HIRealMonitor_SetCounterOrTimer_result(const HIRealMonitor_SetCounterOrTimer_result&);
  HIRealMonitor_SetCounterOrTimer_result& operator=(const HIRealMonitor_SetCounterOrTimer_result&);
  HIRealMonitor_SetCounterOrTimer_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetCounterOrTimer_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetCounterOrTimer_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetCounterOrTimer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetCounterOrTimer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetCounterOrTimer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetCounterOrTimer_presult__isset {
  _HIRealMonitor_SetCounterOrTimer_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetCounterOrTimer_presult__isset;

class HIRealMonitor_SetCounterOrTimer_presult {
 public:


  virtual ~HIRealMonitor_SetCounterOrTimer_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetCounterOrTimer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIRealMonitor_SetTotalCounterOrTimer_args__isset {
  _HIRealMonitor_SetTotalCounterOrTimer_args__isset() : iCounterOrTimerID(false), iTotalNumberOfTimesOrElapsedTime(false) {}
  bool iCounterOrTimerID :1;
  bool iTotalNumberOfTimesOrElapsedTime :1;
} _HIRealMonitor_SetTotalCounterOrTimer_args__isset;

class HIRealMonitor_SetTotalCounterOrTimer_args {
 public:

  HIRealMonitor_SetTotalCounterOrTimer_args(const HIRealMonitor_SetTotalCounterOrTimer_args&);
  HIRealMonitor_SetTotalCounterOrTimer_args& operator=(const HIRealMonitor_SetTotalCounterOrTimer_args&);
  HIRealMonitor_SetTotalCounterOrTimer_args() : iCounterOrTimerID(0), iTotalNumberOfTimesOrElapsedTime(0) {
  }

  virtual ~HIRealMonitor_SetTotalCounterOrTimer_args() throw();
  int32_t iCounterOrTimerID;
  int32_t iTotalNumberOfTimesOrElapsedTime;

  _HIRealMonitor_SetTotalCounterOrTimer_args__isset __isset;

  void __set_iCounterOrTimerID(const int32_t val);

  void __set_iTotalNumberOfTimesOrElapsedTime(const int32_t val);

  bool operator == (const HIRealMonitor_SetTotalCounterOrTimer_args & rhs) const
  {
    if (!(iCounterOrTimerID == rhs.iCounterOrTimerID))
      return false;
    if (!(iTotalNumberOfTimesOrElapsedTime == rhs.iTotalNumberOfTimesOrElapsedTime))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetTotalCounterOrTimer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetTotalCounterOrTimer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_SetTotalCounterOrTimer_pargs {
 public:


  virtual ~HIRealMonitor_SetTotalCounterOrTimer_pargs() throw();
  const int32_t* iCounterOrTimerID;
  const int32_t* iTotalNumberOfTimesOrElapsedTime;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetTotalCounterOrTimer_result__isset {
  _HIRealMonitor_SetTotalCounterOrTimer_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetTotalCounterOrTimer_result__isset;

class HIRealMonitor_SetTotalCounterOrTimer_result {
 public:

  HIRealMonitor_SetTotalCounterOrTimer_result(const HIRealMonitor_SetTotalCounterOrTimer_result&);
  HIRealMonitor_SetTotalCounterOrTimer_result& operator=(const HIRealMonitor_SetTotalCounterOrTimer_result&);
  HIRealMonitor_SetTotalCounterOrTimer_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIRealMonitor_SetTotalCounterOrTimer_result() throw();
   ::EXE_STATE::type success;

  _HIRealMonitor_SetTotalCounterOrTimer_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIRealMonitor_SetTotalCounterOrTimer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_SetTotalCounterOrTimer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_SetTotalCounterOrTimer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_SetTotalCounterOrTimer_presult__isset {
  _HIRealMonitor_SetTotalCounterOrTimer_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_SetTotalCounterOrTimer_presult__isset;

class HIRealMonitor_SetTotalCounterOrTimer_presult {
 public:


  virtual ~HIRealMonitor_SetTotalCounterOrTimer_presult() throw();
   ::EXE_STATE::type* success;

  _HIRealMonitor_SetTotalCounterOrTimer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class HIRealMonitor_GetAllCounterOrTimer_args {
 public:

  HIRealMonitor_GetAllCounterOrTimer_args(const HIRealMonitor_GetAllCounterOrTimer_args&);
  HIRealMonitor_GetAllCounterOrTimer_args& operator=(const HIRealMonitor_GetAllCounterOrTimer_args&);
  HIRealMonitor_GetAllCounterOrTimer_args() {
  }

  virtual ~HIRealMonitor_GetAllCounterOrTimer_args() throw();

  bool operator == (const HIRealMonitor_GetAllCounterOrTimer_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HIRealMonitor_GetAllCounterOrTimer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetAllCounterOrTimer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIRealMonitor_GetAllCounterOrTimer_pargs {
 public:


  virtual ~HIRealMonitor_GetAllCounterOrTimer_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetAllCounterOrTimer_result__isset {
  _HIRealMonitor_GetAllCounterOrTimer_result__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetAllCounterOrTimer_result__isset;

class HIRealMonitor_GetAllCounterOrTimer_result {
 public:

  HIRealMonitor_GetAllCounterOrTimer_result(const HIRealMonitor_GetAllCounterOrTimer_result&);
  HIRealMonitor_GetAllCounterOrTimer_result& operator=(const HIRealMonitor_GetAllCounterOrTimer_result&);
  HIRealMonitor_GetAllCounterOrTimer_result() {
  }

  virtual ~HIRealMonitor_GetAllCounterOrTimer_result() throw();
  std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T>  success;

  _HIRealMonitor_GetAllCounterOrTimer_result__isset __isset;

  void __set_success(const std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & val);

  bool operator == (const HIRealMonitor_GetAllCounterOrTimer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIRealMonitor_GetAllCounterOrTimer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIRealMonitor_GetAllCounterOrTimer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIRealMonitor_GetAllCounterOrTimer_presult__isset {
  _HIRealMonitor_GetAllCounterOrTimer_presult__isset() : success(false) {}
  bool success :1;
} _HIRealMonitor_GetAllCounterOrTimer_presult__isset;

class HIRealMonitor_GetAllCounterOrTimer_presult {
 public:


  virtual ~HIRealMonitor_GetAllCounterOrTimer_presult() throw();
  std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> * success;

  _HIRealMonitor_GetAllCounterOrTimer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class HIRealMonitorClient : virtual public HIRealMonitorIf {
 public:
  HIRealMonitorClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HIRealMonitorClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
   ::EXE_STATE::type GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData);
  void send_GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetIOAsync();
   ::EXE_STATE::type GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData);
  void send_GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetTemperatureAsync();
   ::EXE_STATE::type GetPressureAsync(const int32_t sensor, const int32_t iUserData);
  void send_GetPressureAsync(const int32_t sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetPressureAsync();
   ::EXE_STATE::type SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData);
  void send_SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData);
   ::EXE_STATE::type recv_SetIOAsync();
   ::EXE_STATE::type ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData);
  void send_ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_ManualUnlockSlotAsync();
   ::EXE_STATE::type GetLightSignalAsync(const int32_t iWave, const int32_t iUserData);
  void send_GetLightSignalAsync(const int32_t iWave, const int32_t iUserData);
   ::EXE_STATE::type recv_GetLightSignalAsync();
   ::EXE_STATE::type SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData);
  void send_SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData);
   ::EXE_STATE::type recv_SetIndicatorLightAsync();
   ::EXE_STATE::type SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData);
  void send_SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData);
   ::EXE_STATE::type recv_SetAlarmSoundAsync();
   ::EXE_STATE::type ManualStopAsync(const int32_t iUserData);
  void send_ManualStopAsync(const int32_t iUserData);
   ::EXE_STATE::type recv_ManualStopAsync();
   ::EXE_STATE::type SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo);
  void send_SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo);
   ::EXE_STATE::type recv_SetConsumablesInfo();
  int32_t GetCurrentInstrumentState();
  void send_GetCurrentInstrumentState();
  int32_t recv_GetCurrentInstrumentState();
   ::EXE_STATE::type SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime);
  void send_SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime);
   ::EXE_STATE::type recv_SetCounterOrTimer();
   ::EXE_STATE::type SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime);
  void send_SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime);
   ::EXE_STATE::type recv_SetTotalCounterOrTimer();
  void GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return);
  void send_GetAllCounterOrTimer();
  void recv_GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HIRealMonitorProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HIRealMonitorProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_GetIOAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetTemperatureAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetPressureAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetIOAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ManualUnlockSlotAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetLightSignalAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetIndicatorLightAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetAlarmSoundAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ManualStopAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetConsumablesInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetCurrentInstrumentState(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetTotalCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetAllCounterOrTimer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HIRealMonitorProcessor(::apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> iface) :
    iface_(iface) {
    processMap_["GetIOAsync"] = &HIRealMonitorProcessor::process_GetIOAsync;
    processMap_["GetTemperatureAsync"] = &HIRealMonitorProcessor::process_GetTemperatureAsync;
    processMap_["GetPressureAsync"] = &HIRealMonitorProcessor::process_GetPressureAsync;
    processMap_["SetIOAsync"] = &HIRealMonitorProcessor::process_SetIOAsync;
    processMap_["ManualUnlockSlotAsync"] = &HIRealMonitorProcessor::process_ManualUnlockSlotAsync;
    processMap_["GetLightSignalAsync"] = &HIRealMonitorProcessor::process_GetLightSignalAsync;
    processMap_["SetIndicatorLightAsync"] = &HIRealMonitorProcessor::process_SetIndicatorLightAsync;
    processMap_["SetAlarmSoundAsync"] = &HIRealMonitorProcessor::process_SetAlarmSoundAsync;
    processMap_["ManualStopAsync"] = &HIRealMonitorProcessor::process_ManualStopAsync;
    processMap_["SetConsumablesInfo"] = &HIRealMonitorProcessor::process_SetConsumablesInfo;
    processMap_["GetCurrentInstrumentState"] = &HIRealMonitorProcessor::process_GetCurrentInstrumentState;
    processMap_["SetCounterOrTimer"] = &HIRealMonitorProcessor::process_SetCounterOrTimer;
    processMap_["SetTotalCounterOrTimer"] = &HIRealMonitorProcessor::process_SetTotalCounterOrTimer;
    processMap_["GetAllCounterOrTimer"] = &HIRealMonitorProcessor::process_GetAllCounterOrTimer;
  }

  virtual ~HIRealMonitorProcessor() {}
};

class HIRealMonitorProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HIRealMonitorProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< HIRealMonitorIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< HIRealMonitorIfFactory > handlerFactory_;
};

class HIRealMonitorMultiface : virtual public HIRealMonitorIf {
 public:
  HIRealMonitorMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HIRealMonitorMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> > ifaces_;
  HIRealMonitorMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<HIRealMonitorIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
   ::EXE_STATE::type GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetIOAsync(sensor, iUserData);
    }
    return ifaces_[i]->GetIOAsync(sensor, iUserData);
  }

   ::EXE_STATE::type GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetTemperatureAsync(sensor, iUserData);
    }
    return ifaces_[i]->GetTemperatureAsync(sensor, iUserData);
  }

   ::EXE_STATE::type GetPressureAsync(const int32_t sensor, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetPressureAsync(sensor, iUserData);
    }
    return ifaces_[i]->GetPressureAsync(sensor, iUserData);
  }

   ::EXE_STATE::type SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetIOAsync(sensor, iState, iUserData);
    }
    return ifaces_[i]->SetIOAsync(sensor, iState, iUserData);
  }

   ::EXE_STATE::type ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ManualUnlockSlotAsync(sensor, iUserData);
    }
    return ifaces_[i]->ManualUnlockSlotAsync(sensor, iUserData);
  }

   ::EXE_STATE::type GetLightSignalAsync(const int32_t iWave, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetLightSignalAsync(iWave, iUserData);
    }
    return ifaces_[i]->GetLightSignalAsync(iWave, iUserData);
  }

   ::EXE_STATE::type SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetIndicatorLightAsync(iIndicatorLightNo, iColor, iBlink, iUserData);
    }
    return ifaces_[i]->SetIndicatorLightAsync(iIndicatorLightNo, iColor, iBlink, iUserData);
  }

   ::EXE_STATE::type SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetAlarmSoundAsync(bOpen, iSound, iUserData);
    }
    return ifaces_[i]->SetAlarmSoundAsync(bOpen, iSound, iUserData);
  }

   ::EXE_STATE::type ManualStopAsync(const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ManualStopAsync(iUserData);
    }
    return ifaces_[i]->ManualStopAsync(iUserData);
  }

   ::EXE_STATE::type SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetConsumablesInfo(tConsumablesInfo);
    }
    return ifaces_[i]->SetConsumablesInfo(tConsumablesInfo);
  }

  int32_t GetCurrentInstrumentState() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetCurrentInstrumentState();
    }
    return ifaces_[i]->GetCurrentInstrumentState();
  }

   ::EXE_STATE::type SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetCounterOrTimer(iCounterOrTimerID, iNumberOfTimesOrElapsedTime);
    }
    return ifaces_[i]->SetCounterOrTimer(iCounterOrTimerID, iNumberOfTimesOrElapsedTime);
  }

   ::EXE_STATE::type SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetTotalCounterOrTimer(iCounterOrTimerID, iTotalNumberOfTimesOrElapsedTime);
    }
    return ifaces_[i]->SetTotalCounterOrTimer(iCounterOrTimerID, iTotalNumberOfTimesOrElapsedTime);
  }

  void GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetAllCounterOrTimer(_return);
    }
    ifaces_[i]->GetAllCounterOrTimer(_return);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class HIRealMonitorConcurrentClient : virtual public HIRealMonitorIf {
 public:
  HIRealMonitorConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HIRealMonitorConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
   ::EXE_STATE::type GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData);
  int32_t send_GetIOAsync(const  ::OUTPUT_IO::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetIOAsync(const int32_t seqid);
   ::EXE_STATE::type GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData);
  int32_t send_GetTemperatureAsync(const  ::TEMPERATURE_SENSOR::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetTemperatureAsync(const int32_t seqid);
   ::EXE_STATE::type GetPressureAsync(const int32_t sensor, const int32_t iUserData);
  int32_t send_GetPressureAsync(const int32_t sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_GetPressureAsync(const int32_t seqid);
   ::EXE_STATE::type SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData);
  int32_t send_SetIOAsync(const  ::INPUT_IO::type sensor, const int32_t iState, const int32_t iUserData);
   ::EXE_STATE::type recv_SetIOAsync(const int32_t seqid);
   ::EXE_STATE::type ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData);
  int32_t send_ManualUnlockSlotAsync(const  ::INPUT_IO::type sensor, const int32_t iUserData);
   ::EXE_STATE::type recv_ManualUnlockSlotAsync(const int32_t seqid);
   ::EXE_STATE::type GetLightSignalAsync(const int32_t iWave, const int32_t iUserData);
  int32_t send_GetLightSignalAsync(const int32_t iWave, const int32_t iUserData);
   ::EXE_STATE::type recv_GetLightSignalAsync(const int32_t seqid);
   ::EXE_STATE::type SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData);
  int32_t send_SetIndicatorLightAsync(const int32_t iIndicatorLightNo, const int32_t iColor, const int32_t iBlink, const int32_t iUserData);
   ::EXE_STATE::type recv_SetIndicatorLightAsync(const int32_t seqid);
   ::EXE_STATE::type SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData);
  int32_t send_SetAlarmSoundAsync(const  ::IBOOL bOpen, const int32_t iSound, const int32_t iUserData);
   ::EXE_STATE::type recv_SetAlarmSoundAsync(const int32_t seqid);
   ::EXE_STATE::type ManualStopAsync(const int32_t iUserData);
  int32_t send_ManualStopAsync(const int32_t iUserData);
   ::EXE_STATE::type recv_ManualStopAsync(const int32_t seqid);
   ::EXE_STATE::type SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo);
  int32_t send_SetConsumablesInfo(const  ::CONSUMABLES_INFO_T& tConsumablesInfo);
   ::EXE_STATE::type recv_SetConsumablesInfo(const int32_t seqid);
  int32_t GetCurrentInstrumentState();
  int32_t send_GetCurrentInstrumentState();
  int32_t recv_GetCurrentInstrumentState(const int32_t seqid);
   ::EXE_STATE::type SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime);
  int32_t send_SetCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iNumberOfTimesOrElapsedTime);
   ::EXE_STATE::type recv_SetCounterOrTimer(const int32_t seqid);
   ::EXE_STATE::type SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime);
  int32_t send_SetTotalCounterOrTimer(const int32_t iCounterOrTimerID, const int32_t iTotalNumberOfTimesOrElapsedTime);
   ::EXE_STATE::type recv_SetTotalCounterOrTimer(const int32_t seqid);
  void GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return);
  int32_t send_GetAllCounterOrTimer();
  void recv_GetAllCounterOrTimer(std::vector< ::SLAVE_COUNTEROR_TIMER_INFO_T> & _return, const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
