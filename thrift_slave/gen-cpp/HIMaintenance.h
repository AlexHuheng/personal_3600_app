/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef HIMaintenance_H
#define HIMaintenance_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "H2103_Host_Invoke_types.h"

namespace H2103_Host_Invoke {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class HIMaintenanceIf {
 public:
  virtual ~HIMaintenanceIf() {}
  virtual  ::EXE_STATE::type ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type ActiveMachineAsync(const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData) = 0;
  virtual int32_t GetFluxMode() = 0;
  virtual  ::EXE_STATE::type ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData) = 0;
  virtual  ::EXE_STATE::type RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData) = 0;
};

class HIMaintenanceIfFactory {
 public:
  typedef HIMaintenanceIf Handler;

  virtual ~HIMaintenanceIfFactory() {}

  virtual HIMaintenanceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HIMaintenanceIf* /* handler */) = 0;
};

class HIMaintenanceIfSingletonFactory : virtual public HIMaintenanceIfFactory {
 public:
  HIMaintenanceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf>& iface) : iface_(iface) {}
  virtual ~HIMaintenanceIfSingletonFactory() {}

  virtual HIMaintenanceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HIMaintenanceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> iface_;
};

class HIMaintenanceNull : virtual public HIMaintenanceIf {
 public:
  virtual ~HIMaintenanceNull() {}
   ::EXE_STATE::type ReagentScanAsync(const int32_t /* iAreaIndex */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type ActiveMachineAsync(const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type SetFluxModeAsync(const int32_t /* iFluxMode */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
  int32_t GetFluxMode() {
    int32_t _return = 0;
    return _return;
  }
   ::EXE_STATE::type ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & /* lstReagPosInfo */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & /* lstReagMixInfo */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type RunMaintenance(const int32_t /* iMainID */, const int32_t /* iKeepCool */, const std::vector<int32_t> & /* lstReserved1 */, const std::vector<std::string> & /* lstReserved2 */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
   ::EXE_STATE::type RunMaintenanceGroup(const int32_t /* iGroupID */, const std::vector< ::MAINTENANCE_ITEM_T> & /* lstItems */, const int32_t /* iUserData */) {
     ::EXE_STATE::type _return = ( ::EXE_STATE::type)0;
    return _return;
  }
};

typedef struct _HIMaintenance_ReagentScanAsync_args__isset {
  _HIMaintenance_ReagentScanAsync_args__isset() : iAreaIndex(false), iUserData(false) {}
  bool iAreaIndex :1;
  bool iUserData :1;
} _HIMaintenance_ReagentScanAsync_args__isset;

class HIMaintenance_ReagentScanAsync_args {
 public:

  HIMaintenance_ReagentScanAsync_args(const HIMaintenance_ReagentScanAsync_args&);
  HIMaintenance_ReagentScanAsync_args& operator=(const HIMaintenance_ReagentScanAsync_args&);
  HIMaintenance_ReagentScanAsync_args() : iAreaIndex(0), iUserData(0) {
  }

  virtual ~HIMaintenance_ReagentScanAsync_args() throw();
  int32_t iAreaIndex;
  int32_t iUserData;

  _HIMaintenance_ReagentScanAsync_args__isset __isset;

  void __set_iAreaIndex(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_ReagentScanAsync_args & rhs) const
  {
    if (!(iAreaIndex == rhs.iAreaIndex))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentScanAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentScanAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_ReagentScanAsync_pargs {
 public:


  virtual ~HIMaintenance_ReagentScanAsync_pargs() throw();
  const int32_t* iAreaIndex;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentScanAsync_result__isset {
  _HIMaintenance_ReagentScanAsync_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentScanAsync_result__isset;

class HIMaintenance_ReagentScanAsync_result {
 public:

  HIMaintenance_ReagentScanAsync_result(const HIMaintenance_ReagentScanAsync_result&);
  HIMaintenance_ReagentScanAsync_result& operator=(const HIMaintenance_ReagentScanAsync_result&);
  HIMaintenance_ReagentScanAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_ReagentScanAsync_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_ReagentScanAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_ReagentScanAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentScanAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentScanAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentScanAsync_presult__isset {
  _HIMaintenance_ReagentScanAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentScanAsync_presult__isset;

class HIMaintenance_ReagentScanAsync_presult {
 public:


  virtual ~HIMaintenance_ReagentScanAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_ReagentScanAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_ActiveMachineAsync_args__isset {
  _HIMaintenance_ActiveMachineAsync_args__isset() : iUserData(false) {}
  bool iUserData :1;
} _HIMaintenance_ActiveMachineAsync_args__isset;

class HIMaintenance_ActiveMachineAsync_args {
 public:

  HIMaintenance_ActiveMachineAsync_args(const HIMaintenance_ActiveMachineAsync_args&);
  HIMaintenance_ActiveMachineAsync_args& operator=(const HIMaintenance_ActiveMachineAsync_args&);
  HIMaintenance_ActiveMachineAsync_args() : iUserData(0) {
  }

  virtual ~HIMaintenance_ActiveMachineAsync_args() throw();
  int32_t iUserData;

  _HIMaintenance_ActiveMachineAsync_args__isset __isset;

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_ActiveMachineAsync_args & rhs) const
  {
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ActiveMachineAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ActiveMachineAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_ActiveMachineAsync_pargs {
 public:


  virtual ~HIMaintenance_ActiveMachineAsync_pargs() throw();
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ActiveMachineAsync_result__isset {
  _HIMaintenance_ActiveMachineAsync_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ActiveMachineAsync_result__isset;

class HIMaintenance_ActiveMachineAsync_result {
 public:

  HIMaintenance_ActiveMachineAsync_result(const HIMaintenance_ActiveMachineAsync_result&);
  HIMaintenance_ActiveMachineAsync_result& operator=(const HIMaintenance_ActiveMachineAsync_result&);
  HIMaintenance_ActiveMachineAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_ActiveMachineAsync_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_ActiveMachineAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_ActiveMachineAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ActiveMachineAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ActiveMachineAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ActiveMachineAsync_presult__isset {
  _HIMaintenance_ActiveMachineAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ActiveMachineAsync_presult__isset;

class HIMaintenance_ActiveMachineAsync_presult {
 public:


  virtual ~HIMaintenance_ActiveMachineAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_ActiveMachineAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_SetFluxModeAsync_args__isset {
  _HIMaintenance_SetFluxModeAsync_args__isset() : iFluxMode(false), iUserData(false) {}
  bool iFluxMode :1;
  bool iUserData :1;
} _HIMaintenance_SetFluxModeAsync_args__isset;

class HIMaintenance_SetFluxModeAsync_args {
 public:

  HIMaintenance_SetFluxModeAsync_args(const HIMaintenance_SetFluxModeAsync_args&);
  HIMaintenance_SetFluxModeAsync_args& operator=(const HIMaintenance_SetFluxModeAsync_args&);
  HIMaintenance_SetFluxModeAsync_args() : iFluxMode(0), iUserData(0) {
  }

  virtual ~HIMaintenance_SetFluxModeAsync_args() throw();
  int32_t iFluxMode;
  int32_t iUserData;

  _HIMaintenance_SetFluxModeAsync_args__isset __isset;

  void __set_iFluxMode(const int32_t val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_SetFluxModeAsync_args & rhs) const
  {
    if (!(iFluxMode == rhs.iFluxMode))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_SetFluxModeAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_SetFluxModeAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_SetFluxModeAsync_pargs {
 public:


  virtual ~HIMaintenance_SetFluxModeAsync_pargs() throw();
  const int32_t* iFluxMode;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_SetFluxModeAsync_result__isset {
  _HIMaintenance_SetFluxModeAsync_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_SetFluxModeAsync_result__isset;

class HIMaintenance_SetFluxModeAsync_result {
 public:

  HIMaintenance_SetFluxModeAsync_result(const HIMaintenance_SetFluxModeAsync_result&);
  HIMaintenance_SetFluxModeAsync_result& operator=(const HIMaintenance_SetFluxModeAsync_result&);
  HIMaintenance_SetFluxModeAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_SetFluxModeAsync_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_SetFluxModeAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_SetFluxModeAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_SetFluxModeAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_SetFluxModeAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_SetFluxModeAsync_presult__isset {
  _HIMaintenance_SetFluxModeAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_SetFluxModeAsync_presult__isset;

class HIMaintenance_SetFluxModeAsync_presult {
 public:


  virtual ~HIMaintenance_SetFluxModeAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_SetFluxModeAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class HIMaintenance_GetFluxMode_args {
 public:

  HIMaintenance_GetFluxMode_args(const HIMaintenance_GetFluxMode_args&);
  HIMaintenance_GetFluxMode_args& operator=(const HIMaintenance_GetFluxMode_args&);
  HIMaintenance_GetFluxMode_args() {
  }

  virtual ~HIMaintenance_GetFluxMode_args() throw();

  bool operator == (const HIMaintenance_GetFluxMode_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const HIMaintenance_GetFluxMode_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_GetFluxMode_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_GetFluxMode_pargs {
 public:


  virtual ~HIMaintenance_GetFluxMode_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_GetFluxMode_result__isset {
  _HIMaintenance_GetFluxMode_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_GetFluxMode_result__isset;

class HIMaintenance_GetFluxMode_result {
 public:

  HIMaintenance_GetFluxMode_result(const HIMaintenance_GetFluxMode_result&);
  HIMaintenance_GetFluxMode_result& operator=(const HIMaintenance_GetFluxMode_result&);
  HIMaintenance_GetFluxMode_result() : success(0) {
  }

  virtual ~HIMaintenance_GetFluxMode_result() throw();
  int32_t success;

  _HIMaintenance_GetFluxMode_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const HIMaintenance_GetFluxMode_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_GetFluxMode_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_GetFluxMode_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_GetFluxMode_presult__isset {
  _HIMaintenance_GetFluxMode_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_GetFluxMode_presult__isset;

class HIMaintenance_GetFluxMode_presult {
 public:


  virtual ~HIMaintenance_GetFluxMode_presult() throw();
  int32_t* success;

  _HIMaintenance_GetFluxMode_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_ReagentRemainDetectAsync_args__isset {
  _HIMaintenance_ReagentRemainDetectAsync_args__isset() : lstReagPosInfo(false), iUserData(false) {}
  bool lstReagPosInfo :1;
  bool iUserData :1;
} _HIMaintenance_ReagentRemainDetectAsync_args__isset;

class HIMaintenance_ReagentRemainDetectAsync_args {
 public:

  HIMaintenance_ReagentRemainDetectAsync_args(const HIMaintenance_ReagentRemainDetectAsync_args&);
  HIMaintenance_ReagentRemainDetectAsync_args& operator=(const HIMaintenance_ReagentRemainDetectAsync_args&);
  HIMaintenance_ReagentRemainDetectAsync_args() : iUserData(0) {
  }

  virtual ~HIMaintenance_ReagentRemainDetectAsync_args() throw();
  std::vector< ::REAGENT_POS_INFO_T>  lstReagPosInfo;
  int32_t iUserData;

  _HIMaintenance_ReagentRemainDetectAsync_args__isset __isset;

  void __set_lstReagPosInfo(const std::vector< ::REAGENT_POS_INFO_T> & val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_ReagentRemainDetectAsync_args & rhs) const
  {
    if (!(lstReagPosInfo == rhs.lstReagPosInfo))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentRemainDetectAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentRemainDetectAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_ReagentRemainDetectAsync_pargs {
 public:


  virtual ~HIMaintenance_ReagentRemainDetectAsync_pargs() throw();
  const std::vector< ::REAGENT_POS_INFO_T> * lstReagPosInfo;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentRemainDetectAsync_result__isset {
  _HIMaintenance_ReagentRemainDetectAsync_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentRemainDetectAsync_result__isset;

class HIMaintenance_ReagentRemainDetectAsync_result {
 public:

  HIMaintenance_ReagentRemainDetectAsync_result(const HIMaintenance_ReagentRemainDetectAsync_result&);
  HIMaintenance_ReagentRemainDetectAsync_result& operator=(const HIMaintenance_ReagentRemainDetectAsync_result&);
  HIMaintenance_ReagentRemainDetectAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_ReagentRemainDetectAsync_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_ReagentRemainDetectAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_ReagentRemainDetectAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentRemainDetectAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentRemainDetectAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentRemainDetectAsync_presult__isset {
  _HIMaintenance_ReagentRemainDetectAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentRemainDetectAsync_presult__isset;

class HIMaintenance_ReagentRemainDetectAsync_presult {
 public:


  virtual ~HIMaintenance_ReagentRemainDetectAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_ReagentRemainDetectAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_ReagentMixingAsync_args__isset {
  _HIMaintenance_ReagentMixingAsync_args__isset() : lstReagMixInfo(false), iUserData(false) {}
  bool lstReagMixInfo :1;
  bool iUserData :1;
} _HIMaintenance_ReagentMixingAsync_args__isset;

class HIMaintenance_ReagentMixingAsync_args {
 public:

  HIMaintenance_ReagentMixingAsync_args(const HIMaintenance_ReagentMixingAsync_args&);
  HIMaintenance_ReagentMixingAsync_args& operator=(const HIMaintenance_ReagentMixingAsync_args&);
  HIMaintenance_ReagentMixingAsync_args() : iUserData(0) {
  }

  virtual ~HIMaintenance_ReagentMixingAsync_args() throw();
  std::vector< ::REAGENT_MIX_INFO_T>  lstReagMixInfo;
  int32_t iUserData;

  _HIMaintenance_ReagentMixingAsync_args__isset __isset;

  void __set_lstReagMixInfo(const std::vector< ::REAGENT_MIX_INFO_T> & val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_ReagentMixingAsync_args & rhs) const
  {
    if (!(lstReagMixInfo == rhs.lstReagMixInfo))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentMixingAsync_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentMixingAsync_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_ReagentMixingAsync_pargs {
 public:


  virtual ~HIMaintenance_ReagentMixingAsync_pargs() throw();
  const std::vector< ::REAGENT_MIX_INFO_T> * lstReagMixInfo;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentMixingAsync_result__isset {
  _HIMaintenance_ReagentMixingAsync_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentMixingAsync_result__isset;

class HIMaintenance_ReagentMixingAsync_result {
 public:

  HIMaintenance_ReagentMixingAsync_result(const HIMaintenance_ReagentMixingAsync_result&);
  HIMaintenance_ReagentMixingAsync_result& operator=(const HIMaintenance_ReagentMixingAsync_result&);
  HIMaintenance_ReagentMixingAsync_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_ReagentMixingAsync_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_ReagentMixingAsync_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_ReagentMixingAsync_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_ReagentMixingAsync_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_ReagentMixingAsync_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_ReagentMixingAsync_presult__isset {
  _HIMaintenance_ReagentMixingAsync_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_ReagentMixingAsync_presult__isset;

class HIMaintenance_ReagentMixingAsync_presult {
 public:


  virtual ~HIMaintenance_ReagentMixingAsync_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_ReagentMixingAsync_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_RunMaintenance_args__isset {
  _HIMaintenance_RunMaintenance_args__isset() : iMainID(false), iKeepCool(false), lstReserved1(false), lstReserved2(false), iUserData(false) {}
  bool iMainID :1;
  bool iKeepCool :1;
  bool lstReserved1 :1;
  bool lstReserved2 :1;
  bool iUserData :1;
} _HIMaintenance_RunMaintenance_args__isset;

class HIMaintenance_RunMaintenance_args {
 public:

  HIMaintenance_RunMaintenance_args(const HIMaintenance_RunMaintenance_args&);
  HIMaintenance_RunMaintenance_args& operator=(const HIMaintenance_RunMaintenance_args&);
  HIMaintenance_RunMaintenance_args() : iMainID(0), iKeepCool(0), iUserData(0) {
  }

  virtual ~HIMaintenance_RunMaintenance_args() throw();
  int32_t iMainID;
  int32_t iKeepCool;
  std::vector<int32_t>  lstReserved1;
  std::vector<std::string>  lstReserved2;
  int32_t iUserData;

  _HIMaintenance_RunMaintenance_args__isset __isset;

  void __set_iMainID(const int32_t val);

  void __set_iKeepCool(const int32_t val);

  void __set_lstReserved1(const std::vector<int32_t> & val);

  void __set_lstReserved2(const std::vector<std::string> & val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_RunMaintenance_args & rhs) const
  {
    if (!(iMainID == rhs.iMainID))
      return false;
    if (!(iKeepCool == rhs.iKeepCool))
      return false;
    if (!(lstReserved1 == rhs.lstReserved1))
      return false;
    if (!(lstReserved2 == rhs.lstReserved2))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_RunMaintenance_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_RunMaintenance_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_RunMaintenance_pargs {
 public:


  virtual ~HIMaintenance_RunMaintenance_pargs() throw();
  const int32_t* iMainID;
  const int32_t* iKeepCool;
  const std::vector<int32_t> * lstReserved1;
  const std::vector<std::string> * lstReserved2;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_RunMaintenance_result__isset {
  _HIMaintenance_RunMaintenance_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_RunMaintenance_result__isset;

class HIMaintenance_RunMaintenance_result {
 public:

  HIMaintenance_RunMaintenance_result(const HIMaintenance_RunMaintenance_result&);
  HIMaintenance_RunMaintenance_result& operator=(const HIMaintenance_RunMaintenance_result&);
  HIMaintenance_RunMaintenance_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_RunMaintenance_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_RunMaintenance_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_RunMaintenance_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_RunMaintenance_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_RunMaintenance_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_RunMaintenance_presult__isset {
  _HIMaintenance_RunMaintenance_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_RunMaintenance_presult__isset;

class HIMaintenance_RunMaintenance_presult {
 public:


  virtual ~HIMaintenance_RunMaintenance_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_RunMaintenance_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _HIMaintenance_RunMaintenanceGroup_args__isset {
  _HIMaintenance_RunMaintenanceGroup_args__isset() : iGroupID(false), lstItems(false), iUserData(false) {}
  bool iGroupID :1;
  bool lstItems :1;
  bool iUserData :1;
} _HIMaintenance_RunMaintenanceGroup_args__isset;

class HIMaintenance_RunMaintenanceGroup_args {
 public:

  HIMaintenance_RunMaintenanceGroup_args(const HIMaintenance_RunMaintenanceGroup_args&);
  HIMaintenance_RunMaintenanceGroup_args& operator=(const HIMaintenance_RunMaintenanceGroup_args&);
  HIMaintenance_RunMaintenanceGroup_args() : iGroupID(0), iUserData(0) {
  }

  virtual ~HIMaintenance_RunMaintenanceGroup_args() throw();
  int32_t iGroupID;
  std::vector< ::MAINTENANCE_ITEM_T>  lstItems;
  int32_t iUserData;

  _HIMaintenance_RunMaintenanceGroup_args__isset __isset;

  void __set_iGroupID(const int32_t val);

  void __set_lstItems(const std::vector< ::MAINTENANCE_ITEM_T> & val);

  void __set_iUserData(const int32_t val);

  bool operator == (const HIMaintenance_RunMaintenanceGroup_args & rhs) const
  {
    if (!(iGroupID == rhs.iGroupID))
      return false;
    if (!(lstItems == rhs.lstItems))
      return false;
    if (!(iUserData == rhs.iUserData))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_RunMaintenanceGroup_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_RunMaintenanceGroup_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class HIMaintenance_RunMaintenanceGroup_pargs {
 public:


  virtual ~HIMaintenance_RunMaintenanceGroup_pargs() throw();
  const int32_t* iGroupID;
  const std::vector< ::MAINTENANCE_ITEM_T> * lstItems;
  const int32_t* iUserData;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_RunMaintenanceGroup_result__isset {
  _HIMaintenance_RunMaintenanceGroup_result__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_RunMaintenanceGroup_result__isset;

class HIMaintenance_RunMaintenanceGroup_result {
 public:

  HIMaintenance_RunMaintenanceGroup_result(const HIMaintenance_RunMaintenanceGroup_result&);
  HIMaintenance_RunMaintenanceGroup_result& operator=(const HIMaintenance_RunMaintenanceGroup_result&);
  HIMaintenance_RunMaintenanceGroup_result() : success(( ::EXE_STATE::type)0) {
  }

  virtual ~HIMaintenance_RunMaintenanceGroup_result() throw();
   ::EXE_STATE::type success;

  _HIMaintenance_RunMaintenanceGroup_result__isset __isset;

  void __set_success(const  ::EXE_STATE::type val);

  bool operator == (const HIMaintenance_RunMaintenanceGroup_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const HIMaintenance_RunMaintenanceGroup_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HIMaintenance_RunMaintenanceGroup_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _HIMaintenance_RunMaintenanceGroup_presult__isset {
  _HIMaintenance_RunMaintenanceGroup_presult__isset() : success(false) {}
  bool success :1;
} _HIMaintenance_RunMaintenanceGroup_presult__isset;

class HIMaintenance_RunMaintenanceGroup_presult {
 public:


  virtual ~HIMaintenance_RunMaintenanceGroup_presult() throw();
   ::EXE_STATE::type* success;

  _HIMaintenance_RunMaintenanceGroup_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class HIMaintenanceClient : virtual public HIMaintenanceIf {
 public:
  HIMaintenanceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HIMaintenanceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
   ::EXE_STATE::type ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData);
  void send_ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentScanAsync();
   ::EXE_STATE::type ActiveMachineAsync(const int32_t iUserData);
  void send_ActiveMachineAsync(const int32_t iUserData);
   ::EXE_STATE::type recv_ActiveMachineAsync();
   ::EXE_STATE::type SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData);
  void send_SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData);
   ::EXE_STATE::type recv_SetFluxModeAsync();
  int32_t GetFluxMode();
  void send_GetFluxMode();
  int32_t recv_GetFluxMode();
   ::EXE_STATE::type ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData);
  void send_ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentRemainDetectAsync();
   ::EXE_STATE::type ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData);
  void send_ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentMixingAsync();
   ::EXE_STATE::type RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData);
  void send_RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData);
   ::EXE_STATE::type recv_RunMaintenance();
   ::EXE_STATE::type RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData);
  void send_RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData);
   ::EXE_STATE::type recv_RunMaintenanceGroup();
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HIMaintenanceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HIMaintenanceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_ReagentScanAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ActiveMachineAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SetFluxModeAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetFluxMode(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReagentRemainDetectAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_ReagentMixingAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RunMaintenance(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_RunMaintenanceGroup(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HIMaintenanceProcessor(::apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> iface) :
    iface_(iface) {
    processMap_["ReagentScanAsync"] = &HIMaintenanceProcessor::process_ReagentScanAsync;
    processMap_["ActiveMachineAsync"] = &HIMaintenanceProcessor::process_ActiveMachineAsync;
    processMap_["SetFluxModeAsync"] = &HIMaintenanceProcessor::process_SetFluxModeAsync;
    processMap_["GetFluxMode"] = &HIMaintenanceProcessor::process_GetFluxMode;
    processMap_["ReagentRemainDetectAsync"] = &HIMaintenanceProcessor::process_ReagentRemainDetectAsync;
    processMap_["ReagentMixingAsync"] = &HIMaintenanceProcessor::process_ReagentMixingAsync;
    processMap_["RunMaintenance"] = &HIMaintenanceProcessor::process_RunMaintenance;
    processMap_["RunMaintenanceGroup"] = &HIMaintenanceProcessor::process_RunMaintenanceGroup;
  }

  virtual ~HIMaintenanceProcessor() {}
};

class HIMaintenanceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HIMaintenanceProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< HIMaintenanceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< HIMaintenanceIfFactory > handlerFactory_;
};

class HIMaintenanceMultiface : virtual public HIMaintenanceIf {
 public:
  HIMaintenanceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HIMaintenanceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> > ifaces_;
  HIMaintenanceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<HIMaintenanceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
   ::EXE_STATE::type ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReagentScanAsync(iAreaIndex, iUserData);
    }
    return ifaces_[i]->ReagentScanAsync(iAreaIndex, iUserData);
  }

   ::EXE_STATE::type ActiveMachineAsync(const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ActiveMachineAsync(iUserData);
    }
    return ifaces_[i]->ActiveMachineAsync(iUserData);
  }

   ::EXE_STATE::type SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SetFluxModeAsync(iFluxMode, iUserData);
    }
    return ifaces_[i]->SetFluxModeAsync(iFluxMode, iUserData);
  }

  int32_t GetFluxMode() {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetFluxMode();
    }
    return ifaces_[i]->GetFluxMode();
  }

   ::EXE_STATE::type ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReagentRemainDetectAsync(lstReagPosInfo, iUserData);
    }
    return ifaces_[i]->ReagentRemainDetectAsync(lstReagPosInfo, iUserData);
  }

   ::EXE_STATE::type ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->ReagentMixingAsync(lstReagMixInfo, iUserData);
    }
    return ifaces_[i]->ReagentMixingAsync(lstReagMixInfo, iUserData);
  }

   ::EXE_STATE::type RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RunMaintenance(iMainID, iKeepCool, lstReserved1, lstReserved2, iUserData);
    }
    return ifaces_[i]->RunMaintenance(iMainID, iKeepCool, lstReserved1, lstReserved2, iUserData);
  }

   ::EXE_STATE::type RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->RunMaintenanceGroup(iGroupID, lstItems, iUserData);
    }
    return ifaces_[i]->RunMaintenanceGroup(iGroupID, lstItems, iUserData);
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class HIMaintenanceConcurrentClient : virtual public HIMaintenanceIf {
 public:
  HIMaintenanceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  HIMaintenanceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
   ::EXE_STATE::type ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData);
  int32_t send_ReagentScanAsync(const int32_t iAreaIndex, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentScanAsync(const int32_t seqid);
   ::EXE_STATE::type ActiveMachineAsync(const int32_t iUserData);
  int32_t send_ActiveMachineAsync(const int32_t iUserData);
   ::EXE_STATE::type recv_ActiveMachineAsync(const int32_t seqid);
   ::EXE_STATE::type SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData);
  int32_t send_SetFluxModeAsync(const int32_t iFluxMode, const int32_t iUserData);
   ::EXE_STATE::type recv_SetFluxModeAsync(const int32_t seqid);
  int32_t GetFluxMode();
  int32_t send_GetFluxMode();
  int32_t recv_GetFluxMode(const int32_t seqid);
   ::EXE_STATE::type ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData);
  int32_t send_ReagentRemainDetectAsync(const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentRemainDetectAsync(const int32_t seqid);
   ::EXE_STATE::type ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData);
  int32_t send_ReagentMixingAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const int32_t iUserData);
   ::EXE_STATE::type recv_ReagentMixingAsync(const int32_t seqid);
   ::EXE_STATE::type RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData);
  int32_t send_RunMaintenance(const int32_t iMainID, const int32_t iKeepCool, const std::vector<int32_t> & lstReserved1, const std::vector<std::string> & lstReserved2, const int32_t iUserData);
   ::EXE_STATE::type recv_RunMaintenance(const int32_t seqid);
   ::EXE_STATE::type RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData);
  int32_t send_RunMaintenanceGroup(const int32_t iGroupID, const std::vector< ::MAINTENANCE_ITEM_T> & lstItems, const int32_t iUserData);
   ::EXE_STATE::type recv_RunMaintenanceGroup(const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

} // namespace

#endif
