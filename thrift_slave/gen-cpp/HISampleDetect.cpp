/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "HISampleDetect.h"

namespace H2103_Host_Invoke {


HISampleDetect_InstrumentSelfTestAsync_args::~HISampleDetect_InstrumentSelfTestAsync_args() throw() {
}


uint32_t HISampleDetect_InstrumentSelfTestAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstReagMixInfo.clear();
            uint32_t _size88;
            ::apache::thrift::protocol::TType _etype91;
            xfer += iprot->readListBegin(_etype91, _size88);
            this->lstReagMixInfo.resize(_size88);
            uint32_t _i92;
            for (_i92 = 0; _i92 < _size88; ++_i92)
            {
              xfer += this->lstReagMixInfo[_i92].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstReagMixInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->lstReagPosInfo.clear();
            uint32_t _size93;
            ::apache::thrift::protocol::TType _etype96;
            xfer += iprot->readListBegin(_etype96, _size93);
            this->lstReagPosInfo.resize(_size93);
            uint32_t _i97;
            for (_i97 = 0; _i97 < _size93; ++_i97)
            {
              xfer += this->lstReagPosInfo[_i97].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.lstReagPosInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_InstrumentSelfTestAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_InstrumentSelfTestAsync_args");

  xfer += oprot->writeFieldBegin("lstReagMixInfo", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lstReagMixInfo.size()));
    std::vector< ::REAGENT_MIX_INFO_T> ::const_iterator _iter98;
    for (_iter98 = this->lstReagMixInfo.begin(); _iter98 != this->lstReagMixInfo.end(); ++_iter98)
    {
      xfer += (*_iter98).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstReagPosInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->lstReagPosInfo.size()));
    std::vector< ::REAGENT_POS_INFO_T> ::const_iterator _iter99;
    for (_iter99 = this->lstReagPosInfo.begin(); _iter99 != this->lstReagPosInfo.end(); ++_iter99)
    {
      xfer += (*_iter99).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_InstrumentSelfTestAsync_pargs::~HISampleDetect_InstrumentSelfTestAsync_pargs() throw() {
}


uint32_t HISampleDetect_InstrumentSelfTestAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_InstrumentSelfTestAsync_pargs");

  xfer += oprot->writeFieldBegin("lstReagMixInfo", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->lstReagMixInfo)).size()));
    std::vector< ::REAGENT_MIX_INFO_T> ::const_iterator _iter100;
    for (_iter100 = (*(this->lstReagMixInfo)).begin(); _iter100 != (*(this->lstReagMixInfo)).end(); ++_iter100)
    {
      xfer += (*_iter100).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lstReagPosInfo", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>((*(this->lstReagPosInfo)).size()));
    std::vector< ::REAGENT_POS_INFO_T> ::const_iterator _iter101;
    for (_iter101 = (*(this->lstReagPosInfo)).begin(); _iter101 != (*(this->lstReagPosInfo)).end(); ++_iter101)
    {
      xfer += (*_iter101).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_InstrumentSelfTestAsync_result::~HISampleDetect_InstrumentSelfTestAsync_result() throw() {
}


uint32_t HISampleDetect_InstrumentSelfTestAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast102;
          xfer += iprot->readI32(ecast102);
          this->success = ( ::EXE_STATE::type)ecast102;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_InstrumentSelfTestAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_InstrumentSelfTestAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_InstrumentSelfTestAsync_presult::~HISampleDetect_InstrumentSelfTestAsync_presult() throw() {
}


uint32_t HISampleDetect_InstrumentSelfTestAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast103;
          xfer += iprot->readI32(ecast103);
          (*(this->success)) = ( ::EXE_STATE::type)ecast103;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_CreateSampleOrder_args::~HISampleDetect_CreateSampleOrder_args() throw() {
}


uint32_t HISampleDetect_CreateSampleOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tSampleOrderInfo.read(iprot);
          this->__isset.tSampleOrderInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_CreateSampleOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_CreateSampleOrder_args");

  xfer += oprot->writeFieldBegin("tSampleOrderInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->tSampleOrderInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_CreateSampleOrder_pargs::~HISampleDetect_CreateSampleOrder_pargs() throw() {
}


uint32_t HISampleDetect_CreateSampleOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_CreateSampleOrder_pargs");

  xfer += oprot->writeFieldBegin("tSampleOrderInfo", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += (*(this->tSampleOrderInfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_CreateSampleOrder_result::~HISampleDetect_CreateSampleOrder_result() throw() {
}


uint32_t HISampleDetect_CreateSampleOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->success = ( ::EXE_STATE::type)ecast104;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_CreateSampleOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_CreateSampleOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_CreateSampleOrder_presult::~HISampleDetect_CreateSampleOrder_presult() throw() {
}


uint32_t HISampleDetect_CreateSampleOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          (*(this->success)) = ( ::EXE_STATE::type)ecast105;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_UpdateSTATSampleOrder_args::~HISampleDetect_UpdateSTATSampleOrder_args() throw() {
}


uint32_t HISampleDetect_UpdateSTATSampleOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSampleOrderNo);
          this->__isset.iSampleOrderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_UpdateSTATSampleOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_UpdateSTATSampleOrder_args");

  xfer += oprot->writeFieldBegin("iSampleOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSampleOrderNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateSTATSampleOrder_pargs::~HISampleDetect_UpdateSTATSampleOrder_pargs() throw() {
}


uint32_t HISampleDetect_UpdateSTATSampleOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_UpdateSTATSampleOrder_pargs");

  xfer += oprot->writeFieldBegin("iSampleOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iSampleOrderNo)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateSTATSampleOrder_result::~HISampleDetect_UpdateSTATSampleOrder_result() throw() {
}


uint32_t HISampleDetect_UpdateSTATSampleOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast106;
          xfer += iprot->readI32(ecast106);
          this->success = ( ::EXE_STATE::type)ecast106;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_UpdateSTATSampleOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_UpdateSTATSampleOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateSTATSampleOrder_presult::~HISampleDetect_UpdateSTATSampleOrder_presult() throw() {
}


uint32_t HISampleDetect_UpdateSTATSampleOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast107;
          xfer += iprot->readI32(ecast107);
          (*(this->success)) = ( ::EXE_STATE::type)ecast107;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_RemoveSlotOrder_args::~HISampleDetect_RemoveSlotOrder_args() throw() {
}


uint32_t HISampleDetect_RemoveSlotOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSlotNo);
          this->__isset.iSlotNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_RemoveSlotOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_RemoveSlotOrder_args");

  xfer += oprot->writeFieldBegin("iSlotNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSlotNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_RemoveSlotOrder_pargs::~HISampleDetect_RemoveSlotOrder_pargs() throw() {
}


uint32_t HISampleDetect_RemoveSlotOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_RemoveSlotOrder_pargs");

  xfer += oprot->writeFieldBegin("iSlotNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iSlotNo)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_RemoveSlotOrder_result::~HISampleDetect_RemoveSlotOrder_result() throw() {
}


uint32_t HISampleDetect_RemoveSlotOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast108;
          xfer += iprot->readI32(ecast108);
          this->success = ( ::EXE_STATE::type)ecast108;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_RemoveSlotOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_RemoveSlotOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_RemoveSlotOrder_presult::~HISampleDetect_RemoveSlotOrder_presult() throw() {
}


uint32_t HISampleDetect_RemoveSlotOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          (*(this->success)) = ( ::EXE_STATE::type)ecast109;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_IsTestFinished_args::~HISampleDetect_IsTestFinished_args() throw() {
}


uint32_t HISampleDetect_IsTestFinished_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_IsTestFinished_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_IsTestFinished_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_IsTestFinished_pargs::~HISampleDetect_IsTestFinished_pargs() throw() {
}


uint32_t HISampleDetect_IsTestFinished_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_IsTestFinished_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_IsTestFinished_result::~HISampleDetect_IsTestFinished_result() throw() {
}


uint32_t HISampleDetect_IsTestFinished_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_IsTestFinished_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_IsTestFinished_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32(this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_IsTestFinished_presult::~HISampleDetect_IsTestFinished_presult() throw() {
}


uint32_t HISampleDetect_IsTestFinished_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32((*(this->success)));
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_NormalStopAsync_args::~HISampleDetect_NormalStopAsync_args() throw() {
}


uint32_t HISampleDetect_NormalStopAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_NormalStopAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_NormalStopAsync_args");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_NormalStopAsync_pargs::~HISampleDetect_NormalStopAsync_pargs() throw() {
}


uint32_t HISampleDetect_NormalStopAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_NormalStopAsync_pargs");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_NormalStopAsync_result::~HISampleDetect_NormalStopAsync_result() throw() {
}


uint32_t HISampleDetect_NormalStopAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast110;
          xfer += iprot->readI32(ecast110);
          this->success = ( ::EXE_STATE::type)ecast110;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_NormalStopAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_NormalStopAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_NormalStopAsync_presult::~HISampleDetect_NormalStopAsync_presult() throw() {
}


uint32_t HISampleDetect_NormalStopAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast111;
          xfer += iprot->readI32(ecast111);
          (*(this->success)) = ( ::EXE_STATE::type)ecast111;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_ConsumablesStopAsync_args::~HISampleDetect_ConsumablesStopAsync_args() throw() {
}


uint32_t HISampleDetect_ConsumablesStopAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_ConsumablesStopAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_ConsumablesStopAsync_args");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_ConsumablesStopAsync_pargs::~HISampleDetect_ConsumablesStopAsync_pargs() throw() {
}


uint32_t HISampleDetect_ConsumablesStopAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_ConsumablesStopAsync_pargs");

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_ConsumablesStopAsync_result::~HISampleDetect_ConsumablesStopAsync_result() throw() {
}


uint32_t HISampleDetect_ConsumablesStopAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast112;
          xfer += iprot->readI32(ecast112);
          this->success = ( ::EXE_STATE::type)ecast112;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_ConsumablesStopAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_ConsumablesStopAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_ConsumablesStopAsync_presult::~HISampleDetect_ConsumablesStopAsync_presult() throw() {
}


uint32_t HISampleDetect_ConsumablesStopAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast113;
          xfer += iprot->readI32(ecast113);
          (*(this->success)) = ( ::EXE_STATE::type)ecast113;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_SetSampleStopAsync_args::~HISampleDetect_SetSampleStopAsync_args() throw() {
}


uint32_t HISampleDetect_SetSampleStopAsync_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSampleStop);
          this->__isset.iSampleStop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iUserData);
          this->__isset.iUserData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_SetSampleStopAsync_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_SetSampleStopAsync_args");

  xfer += oprot->writeFieldBegin("iSampleStop", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iSampleStop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iUserData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_SetSampleStopAsync_pargs::~HISampleDetect_SetSampleStopAsync_pargs() throw() {
}


uint32_t HISampleDetect_SetSampleStopAsync_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_SetSampleStopAsync_pargs");

  xfer += oprot->writeFieldBegin("iSampleStop", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iSampleStop)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iUserData", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iUserData)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_SetSampleStopAsync_result::~HISampleDetect_SetSampleStopAsync_result() throw() {
}


uint32_t HISampleDetect_SetSampleStopAsync_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast114;
          xfer += iprot->readI32(ecast114);
          this->success = ( ::EXE_STATE::type)ecast114;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_SetSampleStopAsync_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_SetSampleStopAsync_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_SetSampleStopAsync_presult::~HISampleDetect_SetSampleStopAsync_presult() throw() {
}


uint32_t HISampleDetect_SetSampleStopAsync_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast115;
          xfer += iprot->readI32(ecast115);
          (*(this->success)) = ( ::EXE_STATE::type)ecast115;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args::~HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args() throw() {
}


uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs::~HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs() throw() {
}


uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result::~HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result() throw() {
}


uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->success.clear();
            uint32_t _size116;
            ::apache::thrift::protocol::TType _etype119;
            xfer += iprot->readListBegin(_etype119, _size116);
            this->success.resize(_size116);
            uint32_t _i120;
            for (_i120 = 0; _i120 < _size116; ++_i120)
            {
              xfer += iprot->readI32(this->success[_i120]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_LIST, 0);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->success.size()));
      std::vector<int32_t> ::const_iterator _iter121;
      for (_iter121 = this->success.begin(); _iter121 != this->success.end(); ++_iter121)
      {
        xfer += oprot->writeI32((*_iter121));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_presult::~HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_presult() throw() {
}


uint32_t HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            (*(this->success)).clear();
            uint32_t _size122;
            ::apache::thrift::protocol::TType _etype125;
            xfer += iprot->readListBegin(_etype125, _size122);
            (*(this->success)).resize(_size122);
            uint32_t _i126;
            for (_i126 = 0; _i126 < _size122; ++_i126)
            {
              xfer += iprot->readI32((*(this->success))[_i126]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_DeleteOrder_args::~HISampleDetect_DeleteOrder_args() throw() {
}


uint32_t HISampleDetect_DeleteOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOrderNo);
          this->__isset.iOrderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_DeleteOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_DeleteOrder_args");

  xfer += oprot->writeFieldBegin("iOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iOrderNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_DeleteOrder_pargs::~HISampleDetect_DeleteOrder_pargs() throw() {
}


uint32_t HISampleDetect_DeleteOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_DeleteOrder_pargs");

  xfer += oprot->writeFieldBegin("iOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iOrderNo)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_DeleteOrder_result::~HISampleDetect_DeleteOrder_result() throw() {
}


uint32_t HISampleDetect_DeleteOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast127;
          xfer += iprot->readI32(ecast127);
          this->success = ( ::EXE_STATE::type)ecast127;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_DeleteOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_DeleteOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_DeleteOrder_presult::~HISampleDetect_DeleteOrder_presult() throw() {
}


uint32_t HISampleDetect_DeleteOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast128;
          xfer += iprot->readI32(ecast128);
          (*(this->success)) = ( ::EXE_STATE::type)ecast128;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}


HISampleDetect_UpdateOrder_args::~HISampleDetect_UpdateOrder_args() throw() {
}


uint32_t HISampleDetect_UpdateOrder_args::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iOrderNo);
          this->__isset.iOrderNo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iReagentType);
          this->__isset.iReagentType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tOrderInfo.read(iprot);
          this->__isset.tOrderInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iSamplePos);
          this->__isset.iSamplePos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_UpdateOrder_args::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_UpdateOrder_args");

  xfer += oprot->writeFieldBegin("iOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->iOrderNo);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->iReagentType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tOrderInfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->tOrderInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSamplePos", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->iSamplePos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateOrder_pargs::~HISampleDetect_UpdateOrder_pargs() throw() {
}


uint32_t HISampleDetect_UpdateOrder_pargs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HISampleDetect_UpdateOrder_pargs");

  xfer += oprot->writeFieldBegin("iOrderNo", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((*(this->iOrderNo)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iReagentType", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((*(this->iReagentType)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tOrderInfo", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += (*(this->tOrderInfo)).write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iSamplePos", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32((*(this->iSamplePos)));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateOrder_result::~HISampleDetect_UpdateOrder_result() throw() {
}


uint32_t HISampleDetect_UpdateOrder_result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast129;
          xfer += iprot->readI32(ecast129);
          this->success = ( ::EXE_STATE::type)ecast129;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HISampleDetect_UpdateOrder_result::write(::apache::thrift::protocol::TProtocol* oprot) const {

  uint32_t xfer = 0;

  xfer += oprot->writeStructBegin("HISampleDetect_UpdateOrder_result");

  if (this->__isset.success) {
    xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_I32, 0);
    xfer += oprot->writeI32((int32_t)this->success);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}


HISampleDetect_UpdateOrder_presult::~HISampleDetect_UpdateOrder_presult() throw() {
}


uint32_t HISampleDetect_UpdateOrder_presult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 0:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast130;
          xfer += iprot->readI32(ecast130);
          (*(this->success)) = ( ::EXE_STATE::type)ecast130;
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

 ::EXE_STATE::type HISampleDetectClient::InstrumentSelfTestAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData)
{
  send_InstrumentSelfTestAsync(lstReagMixInfo, lstReagPosInfo, iUserData);
  return recv_InstrumentSelfTestAsync();
}

void HISampleDetectClient::send_InstrumentSelfTestAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("InstrumentSelfTestAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_InstrumentSelfTestAsync_pargs args;
  args.lstReagMixInfo = &lstReagMixInfo;
  args.lstReagPosInfo = &lstReagPosInfo;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_InstrumentSelfTestAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("InstrumentSelfTestAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_InstrumentSelfTestAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "InstrumentSelfTestAsync failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::CreateSampleOrder(const  ::SAMPLE_ORDER_INFO_T& tSampleOrderInfo)
{
  send_CreateSampleOrder(tSampleOrderInfo);
  return recv_CreateSampleOrder();
}

void HISampleDetectClient::send_CreateSampleOrder(const  ::SAMPLE_ORDER_INFO_T& tSampleOrderInfo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("CreateSampleOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_CreateSampleOrder_pargs args;
  args.tSampleOrderInfo = &tSampleOrderInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_CreateSampleOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("CreateSampleOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_CreateSampleOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CreateSampleOrder failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::UpdateSTATSampleOrder(const int32_t iSampleOrderNo)
{
  send_UpdateSTATSampleOrder(iSampleOrderNo);
  return recv_UpdateSTATSampleOrder();
}

void HISampleDetectClient::send_UpdateSTATSampleOrder(const int32_t iSampleOrderNo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateSTATSampleOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_UpdateSTATSampleOrder_pargs args;
  args.iSampleOrderNo = &iSampleOrderNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_UpdateSTATSampleOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("UpdateSTATSampleOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_UpdateSTATSampleOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "UpdateSTATSampleOrder failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::RemoveSlotOrder(const int32_t iSlotNo)
{
  send_RemoveSlotOrder(iSlotNo);
  return recv_RemoveSlotOrder();
}

void HISampleDetectClient::send_RemoveSlotOrder(const int32_t iSlotNo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("RemoveSlotOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_RemoveSlotOrder_pargs args;
  args.iSlotNo = &iSlotNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_RemoveSlotOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("RemoveSlotOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_RemoveSlotOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RemoveSlotOrder failed: unknown result");
}

int32_t HISampleDetectClient::IsTestFinished()
{
  send_IsTestFinished();
  return recv_IsTestFinished();
}

void HISampleDetectClient::send_IsTestFinished()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("IsTestFinished", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_IsTestFinished_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

int32_t HISampleDetectClient::recv_IsTestFinished()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("IsTestFinished") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  int32_t _return;
  HISampleDetect_IsTestFinished_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "IsTestFinished failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::NormalStopAsync(const int32_t iUserData)
{
  send_NormalStopAsync(iUserData);
  return recv_NormalStopAsync();
}

void HISampleDetectClient::send_NormalStopAsync(const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("NormalStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_NormalStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_NormalStopAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("NormalStopAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_NormalStopAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "NormalStopAsync failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::ConsumablesStopAsync(const int32_t iUserData)
{
  send_ConsumablesStopAsync(iUserData);
  return recv_ConsumablesStopAsync();
}

void HISampleDetectClient::send_ConsumablesStopAsync(const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("ConsumablesStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_ConsumablesStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_ConsumablesStopAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("ConsumablesStopAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_ConsumablesStopAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ConsumablesStopAsync failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::SetSampleStopAsync(const int32_t iSampleStop, const int32_t iUserData)
{
  send_SetSampleStopAsync(iSampleStop, iUserData);
  return recv_SetSampleStopAsync();
}

void HISampleDetectClient::send_SetSampleStopAsync(const int32_t iSampleStop, const int32_t iUserData)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("SetSampleStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_SetSampleStopAsync_pargs args;
  args.iSampleStop = &iSampleStop;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_SetSampleStopAsync()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("SetSampleStopAsync") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_SetSampleStopAsync_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetSampleStopAsync failed: unknown result");
}

void HISampleDetectClient::QueryIsOpenReagentBinCoverOrDiluentCover(std::vector<int32_t> & _return)
{
  send_QueryIsOpenReagentBinCoverOrDiluentCover();
  recv_QueryIsOpenReagentBinCoverOrDiluentCover(_return);
}

void HISampleDetectClient::send_QueryIsOpenReagentBinCoverOrDiluentCover()
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("QueryIsOpenReagentBinCoverOrDiluentCover", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

void HISampleDetectClient::recv_QueryIsOpenReagentBinCoverOrDiluentCover(std::vector<int32_t> & _return)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("QueryIsOpenReagentBinCoverOrDiluentCover") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    // _return pointer has now been filled
    return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QueryIsOpenReagentBinCoverOrDiluentCover failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::DeleteOrder(const int32_t iOrderNo)
{
  send_DeleteOrder(iOrderNo);
  return recv_DeleteOrder();
}

void HISampleDetectClient::send_DeleteOrder(const int32_t iOrderNo)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("DeleteOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_DeleteOrder_pargs args;
  args.iOrderNo = &iOrderNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_DeleteOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("DeleteOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_DeleteOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DeleteOrder failed: unknown result");
}

 ::EXE_STATE::type HISampleDetectClient::UpdateOrder(const int32_t iOrderNo, const int32_t iReagentType, const  ::ORDER_INFO_T& tOrderInfo, const int32_t iSamplePos)
{
  send_UpdateOrder(iOrderNo, iReagentType, tOrderInfo, iSamplePos);
  return recv_UpdateOrder();
}

void HISampleDetectClient::send_UpdateOrder(const int32_t iOrderNo, const int32_t iReagentType, const  ::ORDER_INFO_T& tOrderInfo, const int32_t iSamplePos)
{
  int32_t cseqid = 0;
  oprot_->writeMessageBegin("UpdateOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_UpdateOrder_pargs args;
  args.iOrderNo = &iOrderNo;
  args.iReagentType = &iReagentType;
  args.tOrderInfo = &tOrderInfo;
  args.iSamplePos = &iSamplePos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();
}

 ::EXE_STATE::type HISampleDetectClient::recv_UpdateOrder()
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  iprot_->readMessageBegin(fname, mtype, rseqid);
  if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
    ::apache::thrift::TApplicationException x;
    x.read(iprot_);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
    throw x;
  }
  if (mtype != ::apache::thrift::protocol::T_REPLY) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
  if (fname.compare("UpdateOrder") != 0) {
    iprot_->skip(::apache::thrift::protocol::T_STRUCT);
    iprot_->readMessageEnd();
    iprot_->getTransport()->readEnd();
  }
   ::EXE_STATE::type _return;
  HISampleDetect_UpdateOrder_presult result;
  result.success = &_return;
  result.read(iprot_);
  iprot_->readMessageEnd();
  iprot_->getTransport()->readEnd();

  if (result.__isset.success) {
    return _return;
  }
  throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "UpdateOrder failed: unknown result");
}

bool HISampleDetectProcessor::dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext) {
  ProcessMap::iterator pfn;
  pfn = processMap_.find(fname);
  if (pfn == processMap_.end()) {
    iprot->skip(::apache::thrift::protocol::T_STRUCT);
    iprot->readMessageEnd();
    iprot->getTransport()->readEnd();
    ::apache::thrift::TApplicationException x(::apache::thrift::TApplicationException::UNKNOWN_METHOD, "Invalid method name: '"+fname+"'");
    oprot->writeMessageBegin(fname, ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return true;
  }
  (this->*(pfn->second))(seqid, iprot, oprot, callContext);
  return true;
}

void HISampleDetectProcessor::process_InstrumentSelfTestAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.InstrumentSelfTestAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.InstrumentSelfTestAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.InstrumentSelfTestAsync");
  }

  HISampleDetect_InstrumentSelfTestAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.InstrumentSelfTestAsync", bytes);
  }

  HISampleDetect_InstrumentSelfTestAsync_result result;
  try {
    result.success = iface_->InstrumentSelfTestAsync(args.lstReagMixInfo, args.lstReagPosInfo, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.InstrumentSelfTestAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("InstrumentSelfTestAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.InstrumentSelfTestAsync");
  }

  oprot->writeMessageBegin("InstrumentSelfTestAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.InstrumentSelfTestAsync", bytes);
  }
}

void HISampleDetectProcessor::process_CreateSampleOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.CreateSampleOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.CreateSampleOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.CreateSampleOrder");
  }

  HISampleDetect_CreateSampleOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.CreateSampleOrder", bytes);
  }

  HISampleDetect_CreateSampleOrder_result result;
  try {
    result.success = iface_->CreateSampleOrder(args.tSampleOrderInfo);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.CreateSampleOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("CreateSampleOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.CreateSampleOrder");
  }

  oprot->writeMessageBegin("CreateSampleOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.CreateSampleOrder", bytes);
  }
}

void HISampleDetectProcessor::process_UpdateSTATSampleOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.UpdateSTATSampleOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.UpdateSTATSampleOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.UpdateSTATSampleOrder");
  }

  HISampleDetect_UpdateSTATSampleOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.UpdateSTATSampleOrder", bytes);
  }

  HISampleDetect_UpdateSTATSampleOrder_result result;
  try {
    result.success = iface_->UpdateSTATSampleOrder(args.iSampleOrderNo);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.UpdateSTATSampleOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("UpdateSTATSampleOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.UpdateSTATSampleOrder");
  }

  oprot->writeMessageBegin("UpdateSTATSampleOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.UpdateSTATSampleOrder", bytes);
  }
}

void HISampleDetectProcessor::process_RemoveSlotOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.RemoveSlotOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.RemoveSlotOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.RemoveSlotOrder");
  }

  HISampleDetect_RemoveSlotOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.RemoveSlotOrder", bytes);
  }

  HISampleDetect_RemoveSlotOrder_result result;
  try {
    result.success = iface_->RemoveSlotOrder(args.iSlotNo);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.RemoveSlotOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("RemoveSlotOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.RemoveSlotOrder");
  }

  oprot->writeMessageBegin("RemoveSlotOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.RemoveSlotOrder", bytes);
  }
}

void HISampleDetectProcessor::process_IsTestFinished(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.IsTestFinished", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.IsTestFinished");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.IsTestFinished");
  }

  HISampleDetect_IsTestFinished_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.IsTestFinished", bytes);
  }

  HISampleDetect_IsTestFinished_result result;
  try {
    result.success = iface_->IsTestFinished();
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.IsTestFinished");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("IsTestFinished", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.IsTestFinished");
  }

  oprot->writeMessageBegin("IsTestFinished", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.IsTestFinished", bytes);
  }
}

void HISampleDetectProcessor::process_NormalStopAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.NormalStopAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.NormalStopAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.NormalStopAsync");
  }

  HISampleDetect_NormalStopAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.NormalStopAsync", bytes);
  }

  HISampleDetect_NormalStopAsync_result result;
  try {
    result.success = iface_->NormalStopAsync(args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.NormalStopAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("NormalStopAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.NormalStopAsync");
  }

  oprot->writeMessageBegin("NormalStopAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.NormalStopAsync", bytes);
  }
}

void HISampleDetectProcessor::process_ConsumablesStopAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.ConsumablesStopAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.ConsumablesStopAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.ConsumablesStopAsync");
  }

  HISampleDetect_ConsumablesStopAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.ConsumablesStopAsync", bytes);
  }

  HISampleDetect_ConsumablesStopAsync_result result;
  try {
    result.success = iface_->ConsumablesStopAsync(args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.ConsumablesStopAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("ConsumablesStopAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.ConsumablesStopAsync");
  }

  oprot->writeMessageBegin("ConsumablesStopAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.ConsumablesStopAsync", bytes);
  }
}

void HISampleDetectProcessor::process_SetSampleStopAsync(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.SetSampleStopAsync", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.SetSampleStopAsync");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.SetSampleStopAsync");
  }

  HISampleDetect_SetSampleStopAsync_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.SetSampleStopAsync", bytes);
  }

  HISampleDetect_SetSampleStopAsync_result result;
  try {
    result.success = iface_->SetSampleStopAsync(args.iSampleStop, args.iUserData);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.SetSampleStopAsync");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("SetSampleStopAsync", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.SetSampleStopAsync");
  }

  oprot->writeMessageBegin("SetSampleStopAsync", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.SetSampleStopAsync", bytes);
  }
}

void HISampleDetectProcessor::process_QueryIsOpenReagentBinCoverOrDiluentCover(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover");
  }

  HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover", bytes);
  }

  HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_result result;
  try {
    iface_->QueryIsOpenReagentBinCoverOrDiluentCover(result.success);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("QueryIsOpenReagentBinCoverOrDiluentCover", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover");
  }

  oprot->writeMessageBegin("QueryIsOpenReagentBinCoverOrDiluentCover", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.QueryIsOpenReagentBinCoverOrDiluentCover", bytes);
  }
}

void HISampleDetectProcessor::process_DeleteOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.DeleteOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.DeleteOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.DeleteOrder");
  }

  HISampleDetect_DeleteOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.DeleteOrder", bytes);
  }

  HISampleDetect_DeleteOrder_result result;
  try {
    result.success = iface_->DeleteOrder(args.iOrderNo);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.DeleteOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("DeleteOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.DeleteOrder");
  }

  oprot->writeMessageBegin("DeleteOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.DeleteOrder", bytes);
  }
}

void HISampleDetectProcessor::process_UpdateOrder(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext)
{
  void* ctx = NULL;
  if (this->eventHandler_.get() != NULL) {
    ctx = this->eventHandler_->getContext("HISampleDetect.UpdateOrder", callContext);
  }
  ::apache::thrift::TProcessorContextFreer freer(this->eventHandler_.get(), ctx, "HISampleDetect.UpdateOrder");

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preRead(ctx, "HISampleDetect.UpdateOrder");
  }

  HISampleDetect_UpdateOrder_args args;
  args.read(iprot);
  iprot->readMessageEnd();
  uint32_t bytes = iprot->getTransport()->readEnd();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postRead(ctx, "HISampleDetect.UpdateOrder", bytes);
  }

  HISampleDetect_UpdateOrder_result result;
  try {
    result.success = iface_->UpdateOrder(args.iOrderNo, args.iReagentType, args.tOrderInfo, args.iSamplePos);
    result.__isset.success = true;
  } catch (const std::exception& e) {
    if (this->eventHandler_.get() != NULL) {
      this->eventHandler_->handlerError(ctx, "HISampleDetect.UpdateOrder");
    }

    ::apache::thrift::TApplicationException x(e.what());
    oprot->writeMessageBegin("UpdateOrder", ::apache::thrift::protocol::T_EXCEPTION, seqid);
    x.write(oprot);
    oprot->writeMessageEnd();
    oprot->getTransport()->writeEnd();
    oprot->getTransport()->flush();
    return;
  }

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->preWrite(ctx, "HISampleDetect.UpdateOrder");
  }

  oprot->writeMessageBegin("UpdateOrder", ::apache::thrift::protocol::T_REPLY, seqid);
  result.write(oprot);
  oprot->writeMessageEnd();
  bytes = oprot->getTransport()->writeEnd();
  oprot->getTransport()->flush();

  if (this->eventHandler_.get() != NULL) {
    this->eventHandler_->postWrite(ctx, "HISampleDetect.UpdateOrder", bytes);
  }
}

::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > HISampleDetectProcessorFactory::getProcessor(const ::apache::thrift::TConnectionInfo& connInfo) {
  ::apache::thrift::ReleaseHandler< HISampleDetectIfFactory > cleanup(handlerFactory_);
  ::apache::thrift::stdcxx::shared_ptr< HISampleDetectIf > handler(handlerFactory_->getHandler(connInfo), cleanup);
  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > processor(new HISampleDetectProcessor(handler));
  return processor;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::InstrumentSelfTestAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData)
{
  int32_t seqid = send_InstrumentSelfTestAsync(lstReagMixInfo, lstReagPosInfo, iUserData);
  return recv_InstrumentSelfTestAsync(seqid);
}

int32_t HISampleDetectConcurrentClient::send_InstrumentSelfTestAsync(const std::vector< ::REAGENT_MIX_INFO_T> & lstReagMixInfo, const std::vector< ::REAGENT_POS_INFO_T> & lstReagPosInfo, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("InstrumentSelfTestAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_InstrumentSelfTestAsync_pargs args;
  args.lstReagMixInfo = &lstReagMixInfo;
  args.lstReagPosInfo = &lstReagPosInfo;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_InstrumentSelfTestAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("InstrumentSelfTestAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_InstrumentSelfTestAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "InstrumentSelfTestAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::CreateSampleOrder(const  ::SAMPLE_ORDER_INFO_T& tSampleOrderInfo)
{
  int32_t seqid = send_CreateSampleOrder(tSampleOrderInfo);
  return recv_CreateSampleOrder(seqid);
}

int32_t HISampleDetectConcurrentClient::send_CreateSampleOrder(const  ::SAMPLE_ORDER_INFO_T& tSampleOrderInfo)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("CreateSampleOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_CreateSampleOrder_pargs args;
  args.tSampleOrderInfo = &tSampleOrderInfo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_CreateSampleOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("CreateSampleOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_CreateSampleOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "CreateSampleOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::UpdateSTATSampleOrder(const int32_t iSampleOrderNo)
{
  int32_t seqid = send_UpdateSTATSampleOrder(iSampleOrderNo);
  return recv_UpdateSTATSampleOrder(seqid);
}

int32_t HISampleDetectConcurrentClient::send_UpdateSTATSampleOrder(const int32_t iSampleOrderNo)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateSTATSampleOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_UpdateSTATSampleOrder_pargs args;
  args.iSampleOrderNo = &iSampleOrderNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_UpdateSTATSampleOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("UpdateSTATSampleOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_UpdateSTATSampleOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "UpdateSTATSampleOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::RemoveSlotOrder(const int32_t iSlotNo)
{
  int32_t seqid = send_RemoveSlotOrder(iSlotNo);
  return recv_RemoveSlotOrder(seqid);
}

int32_t HISampleDetectConcurrentClient::send_RemoveSlotOrder(const int32_t iSlotNo)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("RemoveSlotOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_RemoveSlotOrder_pargs args;
  args.iSlotNo = &iSlotNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_RemoveSlotOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("RemoveSlotOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_RemoveSlotOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "RemoveSlotOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

int32_t HISampleDetectConcurrentClient::IsTestFinished()
{
  int32_t seqid = send_IsTestFinished();
  return recv_IsTestFinished(seqid);
}

int32_t HISampleDetectConcurrentClient::send_IsTestFinished()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("IsTestFinished", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_IsTestFinished_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

int32_t HISampleDetectConcurrentClient::recv_IsTestFinished(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("IsTestFinished") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      int32_t _return;
      HISampleDetect_IsTestFinished_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "IsTestFinished failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::NormalStopAsync(const int32_t iUserData)
{
  int32_t seqid = send_NormalStopAsync(iUserData);
  return recv_NormalStopAsync(seqid);
}

int32_t HISampleDetectConcurrentClient::send_NormalStopAsync(const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("NormalStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_NormalStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_NormalStopAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("NormalStopAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_NormalStopAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "NormalStopAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::ConsumablesStopAsync(const int32_t iUserData)
{
  int32_t seqid = send_ConsumablesStopAsync(iUserData);
  return recv_ConsumablesStopAsync(seqid);
}

int32_t HISampleDetectConcurrentClient::send_ConsumablesStopAsync(const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("ConsumablesStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_ConsumablesStopAsync_pargs args;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_ConsumablesStopAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("ConsumablesStopAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_ConsumablesStopAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "ConsumablesStopAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::SetSampleStopAsync(const int32_t iSampleStop, const int32_t iUserData)
{
  int32_t seqid = send_SetSampleStopAsync(iSampleStop, iUserData);
  return recv_SetSampleStopAsync(seqid);
}

int32_t HISampleDetectConcurrentClient::send_SetSampleStopAsync(const int32_t iSampleStop, const int32_t iUserData)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("SetSampleStopAsync", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_SetSampleStopAsync_pargs args;
  args.iSampleStop = &iSampleStop;
  args.iUserData = &iUserData;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_SetSampleStopAsync(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("SetSampleStopAsync") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_SetSampleStopAsync_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "SetSampleStopAsync failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

void HISampleDetectConcurrentClient::QueryIsOpenReagentBinCoverOrDiluentCover(std::vector<int32_t> & _return)
{
  int32_t seqid = send_QueryIsOpenReagentBinCoverOrDiluentCover();
  recv_QueryIsOpenReagentBinCoverOrDiluentCover(_return, seqid);
}

int32_t HISampleDetectConcurrentClient::send_QueryIsOpenReagentBinCoverOrDiluentCover()
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("QueryIsOpenReagentBinCoverOrDiluentCover", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_pargs args;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

void HISampleDetectConcurrentClient::recv_QueryIsOpenReagentBinCoverOrDiluentCover(std::vector<int32_t> & _return, const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("QueryIsOpenReagentBinCoverOrDiluentCover") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
      HISampleDetect_QueryIsOpenReagentBinCoverOrDiluentCover_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        // _return pointer has now been filled
        sentry.commit();
        return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "QueryIsOpenReagentBinCoverOrDiluentCover failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::DeleteOrder(const int32_t iOrderNo)
{
  int32_t seqid = send_DeleteOrder(iOrderNo);
  return recv_DeleteOrder(seqid);
}

int32_t HISampleDetectConcurrentClient::send_DeleteOrder(const int32_t iOrderNo)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("DeleteOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_DeleteOrder_pargs args;
  args.iOrderNo = &iOrderNo;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_DeleteOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("DeleteOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_DeleteOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "DeleteOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::UpdateOrder(const int32_t iOrderNo, const int32_t iReagentType, const  ::ORDER_INFO_T& tOrderInfo, const int32_t iSamplePos)
{
  int32_t seqid = send_UpdateOrder(iOrderNo, iReagentType, tOrderInfo, iSamplePos);
  return recv_UpdateOrder(seqid);
}

int32_t HISampleDetectConcurrentClient::send_UpdateOrder(const int32_t iOrderNo, const int32_t iReagentType, const  ::ORDER_INFO_T& tOrderInfo, const int32_t iSamplePos)
{
  int32_t cseqid = this->sync_.generateSeqId();
  ::apache::thrift::async::TConcurrentSendSentry sentry(&this->sync_);
  oprot_->writeMessageBegin("UpdateOrder", ::apache::thrift::protocol::T_CALL, cseqid);

  HISampleDetect_UpdateOrder_pargs args;
  args.iOrderNo = &iOrderNo;
  args.iReagentType = &iReagentType;
  args.tOrderInfo = &tOrderInfo;
  args.iSamplePos = &iSamplePos;
  args.write(oprot_);

  oprot_->writeMessageEnd();
  oprot_->getTransport()->writeEnd();
  oprot_->getTransport()->flush();

  sentry.commit();
  return cseqid;
}

 ::EXE_STATE::type HISampleDetectConcurrentClient::recv_UpdateOrder(const int32_t seqid)
{

  int32_t rseqid = 0;
  std::string fname;
  ::apache::thrift::protocol::TMessageType mtype;

  // the read mutex gets dropped and reacquired as part of waitForWork()
  // The destructor of this sentry wakes up other clients
  ::apache::thrift::async::TConcurrentRecvSentry sentry(&this->sync_, seqid);

  while(true) {
    if(!this->sync_.getPending(fname, mtype, rseqid)) {
      iprot_->readMessageBegin(fname, mtype, rseqid);
    }
    if(seqid == rseqid) {
      if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {
        ::apache::thrift::TApplicationException x;
        x.read(iprot_);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
        sentry.commit();
        throw x;
      }
      if (mtype != ::apache::thrift::protocol::T_REPLY) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();
      }
      if (fname.compare("UpdateOrder") != 0) {
        iprot_->skip(::apache::thrift::protocol::T_STRUCT);
        iprot_->readMessageEnd();
        iprot_->getTransport()->readEnd();

        // in a bad state, don't commit
        using ::apache::thrift::protocol::TProtocolException;
        throw TProtocolException(TProtocolException::INVALID_DATA);
      }
       ::EXE_STATE::type _return;
      HISampleDetect_UpdateOrder_presult result;
      result.success = &_return;
      result.read(iprot_);
      iprot_->readMessageEnd();
      iprot_->getTransport()->readEnd();

      if (result.__isset.success) {
        sentry.commit();
        return _return;
      }
      // in a bad state, don't commit
      throw ::apache::thrift::TApplicationException(::apache::thrift::TApplicationException::MISSING_RESULT, "UpdateOrder failed: unknown result");
    }
    // seqid != rseqid
    this->sync_.updatePending(fname, mtype, rseqid);

    // this will temporarily unlock the readMutex, and let other clients get work done
    this->sync_.waitForWork(seqid);
  } // end while(true)
}

} // namespace

